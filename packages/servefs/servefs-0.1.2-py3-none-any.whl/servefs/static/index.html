<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ServeFS</title>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <!-- Import Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Import Element Plus -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <script src="https://unpkg.com/element-plus"></script>
    <!-- Import Element Plus Icons -->
    <script src="https://unpkg.com/@element-plus/icons-vue"></script>
    <style>
        .file-browser {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
        }
        .path-nav {
            margin-bottom: 20px;
        }
        .path-nav .el-breadcrumb__item {
            cursor: pointer;
            font-weight: 500;
        }
        .path-nav .el-breadcrumb__item:hover {
            color: #409EFF;
        }
        .file-list {
            border: 1px solid #ebeef5;
            border-radius: 4px;
        }
        .file-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #ebeef5;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .file-icon {
            display: flex;
            justify-content: center;
            margin-right: 10px;
            width: 24px;
            text-align: center;
            color: #606266;
        }
        .file-name {
            cursor: pointer;
            flex-grow: 1;
            margin-right: 16px;
        }
        .file-name:hover {
            color: #409EFF;
        }
        .file-size {
            color: #909399;
            margin-right: 16px;
            font-size: 0.9em;
            width: 80px;
            text-align: right;
        }
        .file-actions {
            margin-left: auto;
        }
        .file-actions .el-button {
            margin-left: 8px;
        }
        .image-preview {
            position: relative;
            outline: none;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            max-height: 70vh;
        }
        .image-preview img {
            max-width: 100%;
            max-height: 70vh;
            height: auto;
            object-fit: contain;
            border: 1px solid lightgray;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .video-preview {
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            max-height: 70vh;
        }
        .video-preview video {
            max-width: 100%;
            max-height: 70vh;
            border: 1px solid lightgray;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .upload-area {
            border: 2px dashed #dcdfe6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area.drag-over {
            border-color: #409eff;
            background-color: rgba(64, 158, 255, 0.1);
        }
        .upload-area .el-icon {
            font-size: 48px;
            color: #909399;
            margin-bottom: 10px;
        }
        .upload-text {
            color: #606266;
            margin: 10px 0;
        }
        .upload-tip {
            color: #909399;
            font-size: 0.9em;
        }
        .upload-progress {
            margin-top: 10px;
        }
        .file-info-card {
            padding: 20px;
            text-align: center;
            background-color: #f5f7fa;
            border-radius: 8px;
            margin: 20px 0;
        }
        .file-info-icon {
            font-size: 48px;
            color: #909399;
            margin-bottom: 20px;
        }
        .file-info-name {
            font-size: 18px;
            font-weight: 500;
            color: #303133;
            margin-bottom: 10px;
        }
        .file-info-details {
            color: #606266;
            margin: 5px 0;
        }
        .file-info-actions {
            margin-top: 20px;
        }
        .font-preview {
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .preview-text {
            margin-bottom: 20px;
        }
        .preview-sizes div {
            margin: 10px 0;
        }
        .editor-content {
            font-family: 'JetBrains Mono', 'Fira Code', 'Source Code Pro', 'Menlo', 'Monaco', 'Consolas', 'Courier New', monospace;
            line-height: 1.5;
            padding: 10px;
            white-space: pre-wrap;
            word-break: break-all;
            tab-size: 4;
        }
        .preview-nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 50%;
            font-size: 20px;
            transition: all 0.3s;
            z-index: 10;
            opacity: 0;
        }
        .image-preview:hover .preview-nav-button {
            opacity: 1;
        }
        .preview-nav-button:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: translateY(-50%) scale(1.1);
        }
        .preview-prev {
            left: 20px;
        }
        .preview-next {
            right: 20px;
        }
    </style>
</head>
<body>
    <div id="app" class="file-browser">
        <el-container>
            <el-header>
                <h1>ServeFS File Browser</h1>
            </el-header>
            
            <el-main>
                <!-- ‰∏ä‰º†Âå∫Âüü -->
                <div
                    class="upload-area"
                    :class="{ 'drag-over': isDragOver }"
                    @dragenter.prevent="isDragOver = true"
                    @dragleave.prevent="isDragOver = false"
                    @dragover.prevent
                    @drop.prevent="handleFileDrop">
                    <input
                        type="file"
                        ref="fileInput"
                        multiple
                        style="display: none"
                        @change="handleFileSelect">
                    <input
                        type="file"
                        ref="folderInput"
                        multiple
                        webkitdirectory
                        style="display: none"
                        @change="handleFileSelect">
                    <el-icon><upload-filled /></el-icon>
                    <div class="upload-text">
                        <span>ÈÄâÊã©Ë¶Å‰∏ä‰º†ÁöÑÊñá‰ª∂ÊàñÊñá‰ª∂Â§πÔºàÊîØÊåÅÂ§öÈÄâÔºâ</span>
                        <div class="upload-tip">ÂèØÊãñÊãΩÊñá‰ª∂ÊàñÊñá‰ª∂Â§πÂà∞Ê≠§Â§Ñ</div>
                    </div>
                    <div class="upload-actions">
                        <el-button type="primary" @click="$refs.fileInput.click()">
                            ‰∏ä‰º†Êñá‰ª∂
                        </el-button>
                        <el-button type="primary" @click="$refs.folderInput.click()">
                            ‰∏ä‰º†Êñá‰ª∂Â§π
                        </el-button>
                    </div>
                </div>

                <!-- ‰∏ä‰º†ËøõÂ∫¶ -->
                <div v-if="uploadProgress.length > 0" class="upload-progress">
                    <el-progress
                        v-for="(progress, index) in uploadProgress"
                        :key="index"
                        :percentage="progress.percentage"
                        :text="progress.filename"
                        :status="progress.status === 'primary' ? '' : progress.status">
                    </el-progress>
                </div>

                <div class="path-nav">
                    <el-breadcrumb separator="/">
                        <el-breadcrumb-item @click="navigateTo('')">üè† Home</el-breadcrumb-item>
                        <el-breadcrumb-item 
                            v-for="(segment, index) in pathSegments" 
                            :key="index"
                            @click="navigateTo(getPathUpTo(index))">
                            {{ segment }}
                        </el-breadcrumb-item>
                    </el-breadcrumb>
                </div>

                <div class="file-list">
                    <template v-if="fileList.length">
                        <div v-for="item in fileList" :key="item.path" class="file-item">
                            <div class="file-icon">
                                <el-icon v-if="item.type === 'directory'"><folder /></el-icon>
                                <el-icon v-else-if="isImageFile(item.name)"><picture-filled /></el-icon>
                                <el-icon v-else-if="isVideoFile(item.name)"><video-play /></el-icon>
                                <el-icon v-else><document /></el-icon>
                            </div>
                            <span class="file-name" @click="handleItemClick(item)">
                                {{ item.name }}
                            </span>
                            <span v-if="item.type === 'file'" class="file-size">
                                {{ formatFileSize(item.size) }}
                            </span>
                            <div class="file-actions">
                                <el-button-group>
                                    <a 
                                        v-if="item.type === 'file'" 
                                        :href="item.download_url"
                                        target="_blank"
                                        class="el-button el-button--primary el-button--small"
                                        style="text-decoration: none;">
                                        <el-icon><Download /></el-icon>
                                    </a>
                                    <el-button 
                                        type="primary"
                                        size="small"
                                        @click.stop="renameFile(item)">
                                        <el-icon><Edit /></el-icon>
                                    </el-button>
                                    <el-button 
                                        type="danger" 
                                        size="small" 
                                        @click.stop="showDeleteDialog(item)">
                                        <el-icon><Delete /></el-icon>
                                    </el-button>
                                </el-button-group>
                            </div>
                        </div>
                    </template>
                    <template v-else>
                        <div class="file-item">
                            <span>No files found</span>
                        </div>
                    </template>
                </div>
            </el-main>
        </el-container>

        <!-- File Preview Dialog -->
        <el-dialog 
            v-model="previewDialog.visible" 
            :title="previewDialog.title" 
            width="70%"
            :top="'5vh'"
            :fullscreen="false">
            <!-- ÂõæÁâáÈ¢ÑËßà -->
            <div v-if="previewDialog.isImage" class="image-preview" tabindex="0" ref="imagePreview" @keydown="handleImageKeydown">
                <el-icon class="preview-nav-button preview-prev" @click="showPrevImage" v-if="hasPrevImage"><arrow-left /></el-icon>
                <img :src="previewDialog.content" :alt="previewDialog.title">
                <el-icon class="preview-nav-button preview-next" @click="showNextImage" v-if="hasNextImage"><arrow-right /></el-icon>
            </div>
            <!-- ËßÜÈ¢ëÈ¢ÑËßà -->
            <div v-else-if="previewDialog.isVideo" class="video-preview">
                <video controls :src="previewDialog.content">
                    Your browser does not support the video tag.
                </video>
            </div>
            <!-- ÊñáÊú¨ÁºñËæëÂô® -->
            <el-input
                v-else-if="previewDialog.isText"
                v-model="previewDialog.content"
                type="textarea"
                :rows="20"
                :readonly="!previewDialog.editable"
                class="editor-content"
            >
            </el-input>
            <!-- Â≠ó‰ΩìÈ¢ÑËßà -->
            <div v-else-if="previewDialog.isFont" class="font-preview">
                <div class="preview-text">
                    <el-input v-model="previewText" placeholder="ËæìÂÖ•È¢ÑËßàÊñáÂ≠ó">
                    </el-input>
                </div>
                <div class="preview-sizes">
                    <div v-for="size in [12, 16, 24, 32, 48]" :key="size">
                        <div>{{ size }}px</div>
                        <div :style="{
                            fontSize: size + 'px',
                            fontFamily: previewDialog.fontFamily
                        }">{{ previewText }}</div>
                    </div>
                </div>
            </div>
            <!-- Êñá‰ª∂‰ø°ÊÅØÂç°Áâá -->
            <div v-else class="file-info-card">
                <div class="file-info-icon">
                    <el-icon><Document /></el-icon>
                </div>
                <div class="file-info-name">{{ previewDialog.title }}</div>
                <div class="file-info-details">
                    <div>Êñá‰ª∂Â§ßÂ∞èÔºö{{ formatFileSize(previewDialog.fileSize) }}</div>
                    <div>Êñá‰ª∂Á±ªÂûãÔºö{{ previewDialog.mimeType || 'Êú™Áü•' }}</div>
                </div>
                <div class="file-info-actions">
                    <el-button type="primary" @click="downloadFile(previewDialog.currentFile)">
                        ‰∏ãËΩΩÊñá‰ª∂
                    </el-button>
                </div>
            </div>
            <template #footer>
                <span class="dialog-footer">
                    <el-button @click="previewDialog.visible = false">ÂÖ≥Èó≠</el-button>
                    <template v-if="previewDialog.isText">
                        <el-button type="primary" @click="saveFile">
                            ‰øùÂ≠ò
                        </el-button>
                        <el-button type="primary" @click="saveAndClose">
                            ‰øùÂ≠òÂπ∂ÂÖ≥Èó≠
                        </el-button>
                    </template>
                </span>
            </template>
        </el-dialog>

        <!-- Delete Confirmation Dialog -->
        <el-dialog
            v-model="deleteDialog.visible"
            :title="deleteDialog.title"
            width="30%"
            center>
            <span>{{ deleteDialog.message }}</span>
            <template #footer>
                <span class="dialog-footer">
                    <el-button @click="deleteDialog.visible = false">Cancel</el-button>
                    <el-button type="danger" @click="confirmDelete">
                        Delete
                    </el-button>
                </span>
            </template>
        </el-dialog>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, watch, nextTick } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;
        
        const app = createApp({
            setup() {
                const currentPath = ref('');
                const fileList = ref([]);
                const isDragOver = ref(false);
                const uploadProgress = ref([]);
                const fileInput = ref(null);
                const folderInput = ref(null);
                const previewDialog = ref({
                    visible: false,
                    title: '',
                    content: '',
                    editable: false,
                    currentFile: null,
                    isImage: false,
                    isVideo: false,
                    isText: false,
                    isFont: false,
                    fontUrl: '',
                    fontFamily: '',
                    fileSize: 0,
                    mimeType: '',
                    currentImageIndex: -1
                });
                const deleteDialog = ref({
                    visible: false,
                    title: '',
                    message: ''
                });
                const previewText = ref('Hello ‰Ω†Â•Ω „Åì„Çì„Å´„Å°„ÅØ 123');

                // Get initial path from URL
                const initPath = () => {
                    const path = window.location.pathname;
                    if (path.startsWith('/blob/')) {
                        return path.substring(6); // Remove '/blob/' prefix
                    }
                    return '';
                };

                const pathSegments = computed(() => {
                    return currentPath.value ? currentPath.value.split('/') : [];
                });

                const getPathUpTo = (index) => {
                    return pathSegments.value.slice(0, index + 1).join('/');
                };

                const navigateTo = (path) => {
                    const urlPath = path ? `/blob/${path}` : '/';
                    history.pushState(null, '', urlPath);
                    loadFiles(path);
                };

                const loadFiles = async (path = '') => {
                    try {
                        const response = await fetch(`/api/files?path=${encodeURIComponent(path)}`);
                        const data = await response.json();
                        if (data.error) {
                            ElMessage.error(data.error);
                            return;
                        }
                        fileList.value = data.items;
                        currentPath.value = data.current_path;
                    } catch (error) {
                        ElMessage.error('Failed to load files');
                    }
                };

                const handleItemClick = (item) => {
                    if (item.type === 'directory') {
                        navigateTo(item.path);
                    } else {
                        openFile(item);
                    }
                };

                // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶‰∏∫ÂõæÁâá
                const isImageFile = (filename) => {
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
                    return imageExtensions.some(ext => filename.toLowerCase().endsWith(ext));
                };

                // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶‰∏∫ËßÜÈ¢ë
                const isVideoFile = (filename) => {
                    const videoExtensions = ['.mp4', '.webm', '.ogg', '.mov', '.mkv', '.avi'];
                    return videoExtensions.some(ext => filename.toLowerCase().endsWith(ext));
                };

                const formatFileSize = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                const createPreviewConfig = (item, type) => {
                    return {
                        visible: true,
                        title: item.name,
                        content: (type === 'image' || type === 'video') ? `/raw/${item.path}` : '',
                        editable: type === 'text',
                        currentFile: item,
                        isImage: type === 'image',
                        isVideo: type === 'video',
                        isText: type === 'text',
                        isFont: type === 'font',
                        fontUrl: type === 'font' ? `/raw/${item.path}` : '',
                        fontFamily: '',
                        fileSize: item.size || 0,
                        mimeType: item.mime_type || ''
                    };
                };

                const openFile = async (item) => {
                    try {
                        if (isImageFile(item.name)) {
                            previewDialog.value = createPreviewConfig(item, 'image');
                        } else if (isVideoFile(item.name)) {
                            previewDialog.value = createPreviewConfig(item, 'video');
                        } else if (item.name.toLowerCase().endsWith('.ttf')) {
                            previewDialog.value = createPreviewConfig(item, 'font');
                        } else if (item.mime_type.startsWith('text/') || item.mime_type === 'application/json') {
                            const response = await fetch(`/api/files/${encodeURIComponent(item.path)}`);
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            const data = await response.json();
                            if (data.error) {
                                ElMessage.error(data.error);
                                return;
                            }
                            const config = createPreviewConfig(item, 'text');
                            config.content = data.content;
                            previewDialog.value = config;
                        } else {
                            previewDialog.value = createPreviewConfig(item, 'unknown');
                        }
                    } catch (error) {
                        console.error('Error opening file:', error);
                        ElMessage.error('ÊâìÂºÄÊñá‰ª∂Êó∂ÂèëÁîüÈîôËØØ');
                    }
                };

                const saveFile = async () => {
                    try {
                        const response = await fetch(`/api/files/${previewDialog.value.currentFile.path}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                content: previewDialog.value.content
                            })
                        });
                        const data = await response.json();
                        if (data.error) {
                            ElMessage.error(data.error);
                            return;
                        }
                        ElMessage.success('File saved successfully');
                    } catch (error) {
                        ElMessage.error('Failed to save file');
                    }
                };

                const saveAndClose = async () => {
                    await saveFile();
                    previewDialog.value.visible = false;
                };

                const showDeleteDialog = (item) => {
                    deleteDialog.value = {
                        visible: true,
                        title: `Delete ${item.name}?`,
                        message: `Are you sure you want to delete ${item.name}?`
                    };
                    deleteDialog.value.currentFile = item;
                };

                const confirmDelete = async () => {
                    try {
                        const response = await fetch(`/api/files/${deleteDialog.value.currentFile.path}`, {
                            method: 'DELETE'
                        });
                        const data = await response.json();
                        if (data.error) {
                            ElMessage.error(data.error);
                            return;
                        }
                        ElMessage.success('Item deleted successfully');
                        await loadFiles(currentPath.value);
                        deleteDialog.value.visible = false;
                    } catch (error) {
                        ElMessage.error('Failed to delete item');
                    }
                };

                const downloadFile = (item) => {
                    const a = document.createElement('a');
                    a.href = item.download_url;
                    a.download = item.name;
                    a.click();
                };

                // Â§ÑÁêÜÊñá‰ª∂‰∏ä‰º†
                const uploadFiles = async (files) => {
                    const formData = new FormData();
                    const totalFiles = files.length;
                    let processedFiles = 0;

                    // ÂàõÂª∫‰∏Ä‰∏™ Map Êù•Â≠òÂÇ®Êñá‰ª∂Â§πÁªìÊûÑ
                    const folderStructure = new Map();

                    // Â§ÑÁêÜÊâÄÊúâÊñá‰ª∂ÔºåÊûÑÂª∫Êñá‰ª∂Â§πÁªìÊûÑ
                    for (const file of files) {
                        const relativePath = file.webkitRelativePath || file.name;
                        const pathParts = relativePath.split('/');
                        
                        // Â¶ÇÊûúÊòØÊñá‰ª∂Â§π‰∏≠ÁöÑÊñá‰ª∂
                        if (pathParts.length > 1) {
                            const folderPath = pathParts.slice(0, -1).join('/');
                            // ËÆ∞ÂΩïÊñá‰ª∂Â§πË∑ØÂæÑ
                            folderStructure.set(folderPath, true);
                        }

                        formData.append('files', file);
                        // Ê∑ªÂä†Êñá‰ª∂ÁöÑÁõ∏ÂØπË∑ØÂæÑ‰ø°ÊÅØ
                        formData.append('paths', relativePath);
                        
                        // Ê∑ªÂä†‰∏ä‰º†ËøõÂ∫¶Êù°
                        uploadProgress.value.push({
                            filename: relativePath,
                            percentage: 0,
                            status: ''  // ÈªòËÆ§Áä∂ÊÄÅ‰∏∫Á©∫
                        });
                    }

                    try {
                        const response = await fetch(`/api/upload/${currentPath.value}`, {
                            method: 'POST',
                            body: formData
                        });
                        const data = await response.json();
                        if (data.error) {
                            ElMessage.error(data.error);
                            uploadProgress.value.forEach(p => p.status = 'error');
                            return;
                        }
                        ElMessage.success('Êñá‰ª∂‰∏ä‰º†ÊàêÂäü');
                        // Êõ¥Êñ∞ËøõÂ∫¶Êù°
                        uploadProgress.value.forEach(p => {
                            p.percentage = 100;
                            p.status = 'success';
                        });
                        // Ê∏ÖÁêÜËøõÂ∫¶Êù°
                        setTimeout(() => {
                            uploadProgress.value = [];
                        }, 2000);
                        // Âà∑Êñ∞Êñá‰ª∂ÂàóË°®
                        await loadFiles(currentPath.value);
                    } catch (error) {
                        ElMessage.error('Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•');
                        uploadProgress.value.forEach(p => p.status = 'error');
                    }
                };

                const handleFileSelect = (event) => {
                    const files = event.target.files;
                    if (files.length > 0) {
                        uploadFiles(files);
                        event.target.value = ''; // Ê∏ÖÁêÜÈÄâÊã©ÔºåÂÖÅËÆ∏ÈáçÂ§çÈÄâÊã©Áõ∏ÂêåÊñá‰ª∂
                    }
                };

                const handleFileDrop = async (event) => {
                    isDragOver.value = false;
                    const items = event.dataTransfer.items;
                    const files = [];

                    // ÈÄíÂΩíËé∑ÂèñÊñá‰ª∂Â§π‰∏≠ÁöÑÊâÄÊúâÊñá‰ª∂
                    const getFiles = async (entry) => {
                        if (entry.isFile) {
                            const file = await new Promise((resolve) => entry.file(resolve));
                            // ‰øùÂ≠òÂÆåÊï¥Ë∑ØÂæÑ‰ø°ÊÅØ
                            file.webkitRelativePath = entry.fullPath.substring(1); // ÁßªÈô§ÂºÄÂ§¥ÁöÑ '/'
                            files.push(file);
                        } else if (entry.isDirectory) {
                            const reader = entry.createReader();
                            const entries = await new Promise((resolve) => {
                                reader.readEntries(resolve);
                            });
                            for (const childEntry of entries) {
                                await getFiles(childEntry);
                            }
                        }
                    };

                    // Â§ÑÁêÜÊâÄÊúâÊãñÊîæÁöÑÈ°πÁõÆ
                    for (const item of items) {
                        if (item.kind === 'file') {
                            const entry = item.webkitGetAsEntry();
                            if (entry) {
                                await getFiles(entry);
                            }
                        }
                    }

                    if (files.length > 0) {
                        uploadFiles(files);
                    }
                };

                // Ê∑ªÂä†ÈîÆÁõòÂø´Êç∑ÈîÆÊîØÊåÅ
                const handleKeydown = (e) => {
                    if (previewDialog.value.visible && (e.metaKey || e.ctrlKey) && e.key === 's') {
                        e.preventDefault(); // ÈòªÊ≠¢ÊµèËßàÂô®ÈªòËÆ§ÁöÑ‰øùÂ≠òË°å‰∏∫
                        saveFile();
                    }
                };

                // Handle browser back/forward buttons
                window.addEventListener('popstate', () => {
                    loadFiles(initPath());
                });

                // Load initial files based on URL path
                onMounted(() => {
                    loadFiles(initPath());
                    window.addEventListener('keydown', handleKeydown);
                });

                onUnmounted(() => {
                    window.removeEventListener('keydown', handleKeydown);
                });

                watch(() => previewDialog.value.fontUrl, (newUrl) => {
                    if (newUrl && previewDialog.value.isFont) {
                        const fontFamily = 'PreviewFont_' + Date.now();
                        const style = document.createElement('style');
                        style.textContent = `
                            @font-face {
                                font-family: '${fontFamily}';
                                src: url('${newUrl}') format('truetype');
                            }
                        `;
                        document.head.appendChild(style);
                        previewDialog.value.fontFamily = fontFamily;
                    }
                });

                // ÂõæÁâáÂØºËà™Áõ∏ÂÖ≥
                const imageList = ref([]);
                const hasPrevImage = computed(() => previewDialog.value.isImage && previewDialog.value.currentImageIndex > 0);
                const hasNextImage = computed(() => previewDialog.value.isImage && previewDialog.value.currentImageIndex < imageList.value.length - 1);
                const imagePreview = ref(null);

                // Ëé∑ÂèñÂêåÁ∫ßÁõÆÂΩï‰∏≠ÁöÑÊâÄÊúâÂõæÁâá
                const getImageListInCurrentDir = () => {
                    return fileList.value.filter(file => isImageFile(file.name));
                };

                // ÊòæÁ§∫‰∏ä‰∏ÄÂº†ÂõæÁâá
                const showPrevImage = () => {
                    if (hasPrevImage.value) {
                        const prevImage = imageList.value[previewDialog.value.currentImageIndex - 1];
                        updatePreviewImage(prevImage, previewDialog.value.currentImageIndex - 1);
                    }
                };

                // ÊòæÁ§∫‰∏ã‰∏ÄÂº†ÂõæÁâá
                const showNextImage = () => {
                    if (hasNextImage.value) {
                        const nextImage = imageList.value[previewDialog.value.currentImageIndex + 1];
                        updatePreviewImage(nextImage, previewDialog.value.currentImageIndex + 1);
                    }
                };

                // Êõ¥Êñ∞È¢ÑËßàÂõæÁâá
                const updatePreviewImage = (image, index) => {
                    if (image) {
                        previewDialog.value.currentImageIndex = index;
                        previewDialog.value.title = image.name;
                        previewDialog.value.content = `/raw/${image.path}`;
                        previewDialog.value.currentFile = image;
                    }
                };

                // Â§ÑÁêÜÂõæÁâáÈ¢ÑËßàÊó∂ÁöÑÈîÆÁõò‰∫ã‰ª∂
                const handleImageKeydown = (event) => {
                    if (event.key === 'ArrowLeft') {
                        showPrevImage();
                    } else if (event.key === 'ArrowRight') {
                        showNextImage();
                    }
                };

                // ÁõëÂê¨È¢ÑËßàÂØπËØùÊ°ÜÊòæÁ§∫Áä∂ÊÄÅ
                watch(() => previewDialog.value.visible, (newVisible) => {
                    if (newVisible && previewDialog.value.isImage) {
                        // ÂΩìÊòæÁ§∫ÂõæÁâáÈ¢ÑËßàÊó∂ÔºåËé∑ÂèñÂêåÁ∫ßÁõÆÂΩïÁöÑÂõæÁâáÂàóË°®
                        imageList.value = getImageListInCurrentDir();
                        // ËÆæÁΩÆÂΩìÂâçÂõæÁâáÁ¥¢Âºï
                        previewDialog.value.currentImageIndex = imageList.value.findIndex(
                            img => img.path === previewDialog.value.currentFile.path
                        );
                        // Âú®‰∏ã‰∏Ä‰∏™‰∫ã‰ª∂Âæ™ÁéØ‰∏≠ËÅöÁÑ¶ÂõæÁâáÈ¢ÑËßàÂå∫Âüü‰ª•ÂêØÁî®ÈîÆÁõò‰∫ã‰ª∂
                        nextTick(() => {
                            if (imagePreview.value) {
                                imagePreview.value.focus();
                            }
                        });
                    }
                });

                // ÈáçÂëΩÂêçÊñá‰ª∂
                const renameFile = async (file) => {
                    try {
                        const { value: newName } = await ElMessageBox.prompt('ËØ∑ËæìÂÖ•Êñ∞ÂêçÁß∞', 'ÈáçÂëΩÂêç', {
                            confirmButtonText: 'Á°ÆÂÆö',
                            cancelButtonText: 'ÂèñÊ∂à',
                            inputValue: file.name,
                            inputValidator: (value) => {
                                if (!value) {
                                    return 'ÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫';
                                }
                                if (value === file.name) {
                                    return 'Êñ∞ÂêçÁß∞‰∏çËÉΩ‰∏éÂéüÂêçÁß∞Áõ∏Âêå';
                                }
                                if (fileList.value.some(f => f.name === value && f.path !== file.path)) {
                                    return 'ËØ•ÂêçÁß∞Â∑≤Â≠òÂú®';
                                }
                                return true;
                            }
                        });

                        if (newName) {
                            const response = await fetch(`/api/files/${encodeURIComponent(file.path)}/rename`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    new_name: newName
                                })
                            });

                            const data = await response.json();
                            if (data.error) {
                                ElMessage.error(data.error);
                                return;
                            }

                            ElMessage.success('ÈáçÂëΩÂêçÊàêÂäü');
                            await loadFiles(currentPath.value);
                        }
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('ÈáçÂëΩÂêçÂ§±Ë¥•:', error);
                            ElMessage.error('ÈáçÂëΩÂêçÂ§±Ë¥•');
                        }
                    }
                };

                return {
                    fileList,
                    currentPath,
                    pathSegments,
                    previewDialog,
                    deleteDialog,
                    isDragOver,
                    uploadProgress,
                    fileInput,
                    folderInput,
                    handleItemClick,
                    navigateTo,
                    getPathUpTo,
                    saveFile,
                    saveAndClose,
                    showDeleteDialog,
                    confirmDelete,
                    isImageFile,
                    isVideoFile,
                    formatFileSize,
                    handleFileSelect,
                    handleFileDrop,
                    downloadFile,
                    previewText,
                    // Ê∑ªÂä†ÂõæÁâáÂØºËà™Áõ∏ÂÖ≥ÁöÑÊñπÊ≥ïÂíåÂ±ûÊÄß
                    hasPrevImage,
                    hasNextImage,
                    showPrevImage,
                    showNextImage,
                    handleImageKeydown,
                    imagePreview,
                    renameFile
                };
            }
        });

        // Use Element Plus
        app.use(ElementPlus);
        // Register all icons
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
            app.component(key, component);
            // console.log(key);
        }
        app.mount('#app');
    </script>
</body>
</html>
