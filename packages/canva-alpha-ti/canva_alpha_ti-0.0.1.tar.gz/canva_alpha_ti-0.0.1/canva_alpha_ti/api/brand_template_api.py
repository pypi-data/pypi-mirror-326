# coding: utf-8

"""
    Canva Connect API

    API for building integrations with Canva via a REST api

    The version of the OpenAPI document: latest
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from canva_alpha_ti.models.dataset_filter import DatasetFilter
from canva_alpha_ti.models.get_brand_template_dataset_response import GetBrandTemplateDatasetResponse
from canva_alpha_ti.models.get_brand_template_response import GetBrandTemplateResponse
from canva_alpha_ti.models.list_brand_templates_response import ListBrandTemplatesResponse
from canva_alpha_ti.models.ownership_type import OwnershipType
from canva_alpha_ti.models.sort_by_type import SortByType

from canva_alpha_ti.api_client import ApiClient, RequestSerialized
from canva_alpha_ti.api_response import ApiResponse
from canva_alpha_ti.rest import RESTResponseType


class BrandTemplateApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_brand_template(
        self,
        brand_template_id: Annotated[str, Field(strict=True, description="The brand template ID.")],
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> GetBrandTemplateResponse:
        """get_brand_template

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Retrieves the metadata for a brand template.

        :param brand_template_id: The brand template ID. (required)
        :type brand_template_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_brand_template_serialize(
            brand_template_id=brand_template_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBrandTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_brand_template_with_http_info(
        self,
        brand_template_id: Annotated[str, Field(strict=True, description="The brand template ID.")],
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[GetBrandTemplateResponse]:
        """get_brand_template

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Retrieves the metadata for a brand template.

        :param brand_template_id: The brand template ID. (required)
        :type brand_template_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_brand_template_serialize(
            brand_template_id=brand_template_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBrandTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_brand_template_without_preload_content(
        self,
        brand_template_id: Annotated[str, Field(strict=True, description="The brand template ID.")],
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """get_brand_template

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Retrieves the metadata for a brand template.

        :param brand_template_id: The brand template ID. (required)
        :type brand_template_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_brand_template_serialize(
            brand_template_id=brand_template_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBrandTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _get_brand_template_serialize(
        self,
        brand_template_id,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if brand_template_id is not None:
            _path_params['brandTemplateId'] = brand_template_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauthAuthCode'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/brand-templates/{brandTemplateId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def get_brand_template_dataset(
        self,
        brand_template_id: Annotated[str, Field(strict=True, description="The brand template ID.")],
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> GetBrandTemplateDatasetResponse:
        """get_brand_template_dataset

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Gets the dataset definition of a brand template. If the brand template contains autofill data fields, this API returns an object with the data field names and the type of data they accept.  Available data field types include:  - Images - Text - Charts  You can autofill a brand template using the [Create a design autofill job API](https://www.canva.dev/docs/connect/api-reference/autofills/create-design-autofill-job/).  WARNING: Chart data fields are a [preview feature](https://www.canva.dev/docs/connect/#preview-apis). There might be unannounced breaking changes to this feature which won't produce a new API version.

        :param brand_template_id: The brand template ID. (required)
        :type brand_template_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_brand_template_dataset_serialize(
            brand_template_id=brand_template_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBrandTemplateDatasetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_brand_template_dataset_with_http_info(
        self,
        brand_template_id: Annotated[str, Field(strict=True, description="The brand template ID.")],
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[GetBrandTemplateDatasetResponse]:
        """get_brand_template_dataset

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Gets the dataset definition of a brand template. If the brand template contains autofill data fields, this API returns an object with the data field names and the type of data they accept.  Available data field types include:  - Images - Text - Charts  You can autofill a brand template using the [Create a design autofill job API](https://www.canva.dev/docs/connect/api-reference/autofills/create-design-autofill-job/).  WARNING: Chart data fields are a [preview feature](https://www.canva.dev/docs/connect/#preview-apis). There might be unannounced breaking changes to this feature which won't produce a new API version.

        :param brand_template_id: The brand template ID. (required)
        :type brand_template_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_brand_template_dataset_serialize(
            brand_template_id=brand_template_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBrandTemplateDatasetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_brand_template_dataset_without_preload_content(
        self,
        brand_template_id: Annotated[str, Field(strict=True, description="The brand template ID.")],
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """get_brand_template_dataset

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Gets the dataset definition of a brand template. If the brand template contains autofill data fields, this API returns an object with the data field names and the type of data they accept.  Available data field types include:  - Images - Text - Charts  You can autofill a brand template using the [Create a design autofill job API](https://www.canva.dev/docs/connect/api-reference/autofills/create-design-autofill-job/).  WARNING: Chart data fields are a [preview feature](https://www.canva.dev/docs/connect/#preview-apis). There might be unannounced breaking changes to this feature which won't produce a new API version.

        :param brand_template_id: The brand template ID. (required)
        :type brand_template_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_brand_template_dataset_serialize(
            brand_template_id=brand_template_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetBrandTemplateDatasetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _get_brand_template_dataset_serialize(
        self,
        brand_template_id,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if brand_template_id is not None:
            _path_params['brandTemplateId'] = brand_template_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauthAuthCode'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/brand-templates/{brandTemplateId}/dataset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def list_brand_templates(
        self,
        query: Annotated[Optional[StrictStr], Field(description="Lets you search the brand templates available to the user using a search term or terms.")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="If the success response contains a continuation token, the user has access to more brand templates you can list. You can use this token as a query parameter and retrieve more templates from the list, for example `/v1/brand-templates?continuation={continuation}`. To retrieve all the brand templates available to the user, you might need to make multiple requests.")] = None,
        ownership: Annotated[Optional[OwnershipType], Field(description="Filter the list of brand templates based on the user's ownership of the brand templates. This can be one of the following:  - `any`: (Default) Brand templates owned by and shared with the user. - `owned`: Brand templates owned by the user. - `shared`: Brand templates shared with the user.")] = None,
        sort_by: Annotated[Optional[SortByType], Field(description="Sort the list of brand templates. This can be one of the following:  - `relevance`: (Default) Sort results using a relevance algorithm. - `modified_descending`: Sort results by the date last modified in descending order. - `modified_ascending`: Sort results by the date last modified in ascending order. - `title_descending`: Sort results by title in descending order. - `title_ascending`: Sort results by title in ascending order.")] = None,
        dataset: Annotated[Optional[DatasetFilter], Field(description="Filter the list of brand templates based on the brand templates' dataset definitions. Brand templates with dataset definitions are mainly used with the [Autofill APIs](https://www.canva.dev/docs/connect/api-reference/autofills/). This can be one of the following:  - `any`: (Default) Brand templates with and without dataset definitions. - `non_empty`: Brand templates with one or more data fields defined. - `empty`: Brand templates with no data fields defined.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ListBrandTemplatesResponse:
        """list_brand_templates

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Get a list of the [brand templates](https://www.canva.com/help/publish-team-template/) the user has access to.

        :param query: Lets you search the brand templates available to the user using a search term or terms.
        :type query: str
        :param continuation: If the success response contains a continuation token, the user has access to more brand templates you can list. You can use this token as a query parameter and retrieve more templates from the list, for example `/v1/brand-templates?continuation={continuation}`. To retrieve all the brand templates available to the user, you might need to make multiple requests.
        :type continuation: str
        :param ownership: Filter the list of brand templates based on the user's ownership of the brand templates. This can be one of the following:  - `any`: (Default) Brand templates owned by and shared with the user. - `owned`: Brand templates owned by the user. - `shared`: Brand templates shared with the user.
        :type ownership: OwnershipType
        :param sort_by: Sort the list of brand templates. This can be one of the following:  - `relevance`: (Default) Sort results using a relevance algorithm. - `modified_descending`: Sort results by the date last modified in descending order. - `modified_ascending`: Sort results by the date last modified in ascending order. - `title_descending`: Sort results by title in descending order. - `title_ascending`: Sort results by title in ascending order.
        :type sort_by: SortByType
        :param dataset: Filter the list of brand templates based on the brand templates' dataset definitions. Brand templates with dataset definitions are mainly used with the [Autofill APIs](https://www.canva.dev/docs/connect/api-reference/autofills/). This can be one of the following:  - `any`: (Default) Brand templates with and without dataset definitions. - `non_empty`: Brand templates with one or more data fields defined. - `empty`: Brand templates with no data fields defined.
        :type dataset: DatasetFilter
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_brand_templates_serialize(
            query=query,
            continuation=continuation,
            ownership=ownership,
            sort_by=sort_by,
            dataset=dataset,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBrandTemplatesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_brand_templates_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="Lets you search the brand templates available to the user using a search term or terms.")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="If the success response contains a continuation token, the user has access to more brand templates you can list. You can use this token as a query parameter and retrieve more templates from the list, for example `/v1/brand-templates?continuation={continuation}`. To retrieve all the brand templates available to the user, you might need to make multiple requests.")] = None,
        ownership: Annotated[Optional[OwnershipType], Field(description="Filter the list of brand templates based on the user's ownership of the brand templates. This can be one of the following:  - `any`: (Default) Brand templates owned by and shared with the user. - `owned`: Brand templates owned by the user. - `shared`: Brand templates shared with the user.")] = None,
        sort_by: Annotated[Optional[SortByType], Field(description="Sort the list of brand templates. This can be one of the following:  - `relevance`: (Default) Sort results using a relevance algorithm. - `modified_descending`: Sort results by the date last modified in descending order. - `modified_ascending`: Sort results by the date last modified in ascending order. - `title_descending`: Sort results by title in descending order. - `title_ascending`: Sort results by title in ascending order.")] = None,
        dataset: Annotated[Optional[DatasetFilter], Field(description="Filter the list of brand templates based on the brand templates' dataset definitions. Brand templates with dataset definitions are mainly used with the [Autofill APIs](https://www.canva.dev/docs/connect/api-reference/autofills/). This can be one of the following:  - `any`: (Default) Brand templates with and without dataset definitions. - `non_empty`: Brand templates with one or more data fields defined. - `empty`: Brand templates with no data fields defined.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[ListBrandTemplatesResponse]:
        """list_brand_templates

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Get a list of the [brand templates](https://www.canva.com/help/publish-team-template/) the user has access to.

        :param query: Lets you search the brand templates available to the user using a search term or terms.
        :type query: str
        :param continuation: If the success response contains a continuation token, the user has access to more brand templates you can list. You can use this token as a query parameter and retrieve more templates from the list, for example `/v1/brand-templates?continuation={continuation}`. To retrieve all the brand templates available to the user, you might need to make multiple requests.
        :type continuation: str
        :param ownership: Filter the list of brand templates based on the user's ownership of the brand templates. This can be one of the following:  - `any`: (Default) Brand templates owned by and shared with the user. - `owned`: Brand templates owned by the user. - `shared`: Brand templates shared with the user.
        :type ownership: OwnershipType
        :param sort_by: Sort the list of brand templates. This can be one of the following:  - `relevance`: (Default) Sort results using a relevance algorithm. - `modified_descending`: Sort results by the date last modified in descending order. - `modified_ascending`: Sort results by the date last modified in ascending order. - `title_descending`: Sort results by title in descending order. - `title_ascending`: Sort results by title in ascending order.
        :type sort_by: SortByType
        :param dataset: Filter the list of brand templates based on the brand templates' dataset definitions. Brand templates with dataset definitions are mainly used with the [Autofill APIs](https://www.canva.dev/docs/connect/api-reference/autofills/). This can be one of the following:  - `any`: (Default) Brand templates with and without dataset definitions. - `non_empty`: Brand templates with one or more data fields defined. - `empty`: Brand templates with no data fields defined.
        :type dataset: DatasetFilter
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_brand_templates_serialize(
            query=query,
            continuation=continuation,
            ownership=ownership,
            sort_by=sort_by,
            dataset=dataset,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBrandTemplatesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_brand_templates_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="Lets you search the brand templates available to the user using a search term or terms.")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="If the success response contains a continuation token, the user has access to more brand templates you can list. You can use this token as a query parameter and retrieve more templates from the list, for example `/v1/brand-templates?continuation={continuation}`. To retrieve all the brand templates available to the user, you might need to make multiple requests.")] = None,
        ownership: Annotated[Optional[OwnershipType], Field(description="Filter the list of brand templates based on the user's ownership of the brand templates. This can be one of the following:  - `any`: (Default) Brand templates owned by and shared with the user. - `owned`: Brand templates owned by the user. - `shared`: Brand templates shared with the user.")] = None,
        sort_by: Annotated[Optional[SortByType], Field(description="Sort the list of brand templates. This can be one of the following:  - `relevance`: (Default) Sort results using a relevance algorithm. - `modified_descending`: Sort results by the date last modified in descending order. - `modified_ascending`: Sort results by the date last modified in ascending order. - `title_descending`: Sort results by title in descending order. - `title_ascending`: Sort results by title in ascending order.")] = None,
        dataset: Annotated[Optional[DatasetFilter], Field(description="Filter the list of brand templates based on the brand templates' dataset definitions. Brand templates with dataset definitions are mainly used with the [Autofill APIs](https://www.canva.dev/docs/connect/api-reference/autofills/). This can be one of the following:  - `any`: (Default) Brand templates with and without dataset definitions. - `non_empty`: Brand templates with one or more data fields defined. - `empty`: Brand templates with no data fields defined.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """list_brand_templates

        <Warning>  Later this year, we'll be updating all brand template IDs. If your integration stores brand template IDs, you'll need to migrate to the new IDs. Once we implement this change, you'll have 6 months to update the IDs.  </Warning>  <Note>  To use this API, your integration must act on behalf of a user that's a member of a [Canva Enterprise](https://www.canva.com/enterprise/) organization.  </Note>  Get a list of the [brand templates](https://www.canva.com/help/publish-team-template/) the user has access to.

        :param query: Lets you search the brand templates available to the user using a search term or terms.
        :type query: str
        :param continuation: If the success response contains a continuation token, the user has access to more brand templates you can list. You can use this token as a query parameter and retrieve more templates from the list, for example `/v1/brand-templates?continuation={continuation}`. To retrieve all the brand templates available to the user, you might need to make multiple requests.
        :type continuation: str
        :param ownership: Filter the list of brand templates based on the user's ownership of the brand templates. This can be one of the following:  - `any`: (Default) Brand templates owned by and shared with the user. - `owned`: Brand templates owned by the user. - `shared`: Brand templates shared with the user.
        :type ownership: OwnershipType
        :param sort_by: Sort the list of brand templates. This can be one of the following:  - `relevance`: (Default) Sort results using a relevance algorithm. - `modified_descending`: Sort results by the date last modified in descending order. - `modified_ascending`: Sort results by the date last modified in ascending order. - `title_descending`: Sort results by title in descending order. - `title_ascending`: Sort results by title in ascending order.
        :type sort_by: SortByType
        :param dataset: Filter the list of brand templates based on the brand templates' dataset definitions. Brand templates with dataset definitions are mainly used with the [Autofill APIs](https://www.canva.dev/docs/connect/api-reference/autofills/). This can be one of the following:  - `any`: (Default) Brand templates with and without dataset definitions. - `non_empty`: Brand templates with one or more data fields defined. - `empty`: Brand templates with no data fields defined.
        :type dataset: DatasetFilter
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_brand_templates_serialize(
            query=query,
            continuation=continuation,
            ownership=ownership,
            sort_by=sort_by,
            dataset=dataset,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBrandTemplatesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _list_brand_templates_serialize(
        self,
        query,
        continuation,
        ownership,
        sort_by,
        dataset,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if continuation is not None:
            
            _query_params.append(('continuation', continuation))
            
        if ownership is not None:
            
            _query_params.append(('ownership', ownership.value))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by.value))
            
        if dataset is not None:
            
            _query_params.append(('dataset', dataset.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauthAuthCode'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/brand-templates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )


