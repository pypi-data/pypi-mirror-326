# coding: utf-8

"""
    Canva Connect API

    API for building integrations with Canva via a REST api

    The version of the OpenAPI document: latest
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import Any, Dict, Optional
from typing_extensions import Annotated
from canva_alpha_ti.models.exchange_access_token_response import ExchangeAccessTokenResponse
from canva_alpha_ti.models.introspect_token_response import IntrospectTokenResponse

from canva_alpha_ti.api_client import ApiClient, RequestSerialized
from canva_alpha_ti.api_response import ApiResponse
from canva_alpha_ti.rest import RESTResponseType


class OauthApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def exchange_access_token(
        self,
        grant_type: Annotated[Optional[StrictStr], Field(description="For generating an access token using a refresh token.")] = None,
        code_verifier: Annotated[Optional[StrictStr], Field(description="The `code_verifier` value that you generated when creating the user authorization URL.")] = None,
        code: Annotated[Optional[StrictStr], Field(description="The authorization code you received after the user authorized the integration.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="Only required if a redirect URL was supplied when you [created the user authorization URL](https://www.canva.dev/docs/connect/authentication/#create-the-authorization-url).  Must be one of those already specified by the client. If not supplied, the first redirect_uri defined for the client will be used by default. ")] = None,
        refresh_token: Annotated[Optional[StrictStr], Field(description="The refresh token to be exchanged. You can copy this value from the successful response received when generating an access token.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Optional scope value when refreshing an access token. Separate multiple [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) with a single space between each scope.  The requested scope cannot include any permissions not already granted, so this parameter allows you to limit the scope when refreshing a token. If omitted, the scope for the token remains unchanged. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ExchangeAccessTokenResponse:
        """exchange_access_token

        This endpoint implements the OAuth 2.0 `token` endpoint, as part of the Authorization Code flow with Proof Key for Code Exchange (PKCE). For more information, see [Authentication](https://www.canva.dev/docs/connect/authentication/).  To generate an access token, you must provide one of the following:  - An authorization code - A refresh token  Generating a token using either an authorization code or a refresh token allows your integration to act on behalf of a user. You must first [obtain user authorization and get an authorization code](https://www.canva.dev/docs/connect/authentication/#obtain-user-authorization).  Access tokens may be up to 4 KB in size, and are only valid for a specified period of time. The expiry time (currently 4 hours) is shown in the endpoint response and is subject to change.  **Endpoint authentication**  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.  **Generate an access token using an authorization code**  To generate an access token with an authorization code, you must:  - Set `grant_type` to `authorization_code`. - Provide the `code_verifier` value that you generated when creating the user authorization URL. - Provide the authorization code you received after the user authorized the integration.  **Generate an access token using a refresh token**  Using the `refresh_token` value from a previous user token request, you can get a new access token with the same or smaller scope as the previous one, but with a refreshed expiry time. You will also receive a new refresh token that you can use to refresh the access token again.  To refresh an existing access token, you must:  - Set `grant_type` to `refresh_token`. - Provide the `refresh_token` from a previous token request.

        :param grant_type: For generating an access token using a refresh token.
        :type grant_type: str
        :param code_verifier: The `code_verifier` value that you generated when creating the user authorization URL.
        :type code_verifier: str
        :param code: The authorization code you received after the user authorized the integration.
        :type code: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :param redirect_uri: Only required if a redirect URL was supplied when you [created the user authorization URL](https://www.canva.dev/docs/connect/authentication/#create-the-authorization-url).  Must be one of those already specified by the client. If not supplied, the first redirect_uri defined for the client will be used by default. 
        :type redirect_uri: str
        :param refresh_token: The refresh token to be exchanged. You can copy this value from the successful response received when generating an access token.
        :type refresh_token: str
        :param scope: Optional scope value when refreshing an access token. Separate multiple [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) with a single space between each scope.  The requested scope cannot include any permissions not already granted, so this parameter allows you to limit the scope when refreshing a token. If omitted, the scope for the token remains unchanged. 
        :type scope: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exchange_access_token_serialize(
            grant_type=grant_type,
            code_verifier=code_verifier,
            code=code,
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            refresh_token=refresh_token,
            scope=scope,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangeAccessTokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def exchange_access_token_with_http_info(
        self,
        grant_type: Annotated[Optional[StrictStr], Field(description="For generating an access token using a refresh token.")] = None,
        code_verifier: Annotated[Optional[StrictStr], Field(description="The `code_verifier` value that you generated when creating the user authorization URL.")] = None,
        code: Annotated[Optional[StrictStr], Field(description="The authorization code you received after the user authorized the integration.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="Only required if a redirect URL was supplied when you [created the user authorization URL](https://www.canva.dev/docs/connect/authentication/#create-the-authorization-url).  Must be one of those already specified by the client. If not supplied, the first redirect_uri defined for the client will be used by default. ")] = None,
        refresh_token: Annotated[Optional[StrictStr], Field(description="The refresh token to be exchanged. You can copy this value from the successful response received when generating an access token.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Optional scope value when refreshing an access token. Separate multiple [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) with a single space between each scope.  The requested scope cannot include any permissions not already granted, so this parameter allows you to limit the scope when refreshing a token. If omitted, the scope for the token remains unchanged. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[ExchangeAccessTokenResponse]:
        """exchange_access_token

        This endpoint implements the OAuth 2.0 `token` endpoint, as part of the Authorization Code flow with Proof Key for Code Exchange (PKCE). For more information, see [Authentication](https://www.canva.dev/docs/connect/authentication/).  To generate an access token, you must provide one of the following:  - An authorization code - A refresh token  Generating a token using either an authorization code or a refresh token allows your integration to act on behalf of a user. You must first [obtain user authorization and get an authorization code](https://www.canva.dev/docs/connect/authentication/#obtain-user-authorization).  Access tokens may be up to 4 KB in size, and are only valid for a specified period of time. The expiry time (currently 4 hours) is shown in the endpoint response and is subject to change.  **Endpoint authentication**  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.  **Generate an access token using an authorization code**  To generate an access token with an authorization code, you must:  - Set `grant_type` to `authorization_code`. - Provide the `code_verifier` value that you generated when creating the user authorization URL. - Provide the authorization code you received after the user authorized the integration.  **Generate an access token using a refresh token**  Using the `refresh_token` value from a previous user token request, you can get a new access token with the same or smaller scope as the previous one, but with a refreshed expiry time. You will also receive a new refresh token that you can use to refresh the access token again.  To refresh an existing access token, you must:  - Set `grant_type` to `refresh_token`. - Provide the `refresh_token` from a previous token request.

        :param grant_type: For generating an access token using a refresh token.
        :type grant_type: str
        :param code_verifier: The `code_verifier` value that you generated when creating the user authorization URL.
        :type code_verifier: str
        :param code: The authorization code you received after the user authorized the integration.
        :type code: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :param redirect_uri: Only required if a redirect URL was supplied when you [created the user authorization URL](https://www.canva.dev/docs/connect/authentication/#create-the-authorization-url).  Must be one of those already specified by the client. If not supplied, the first redirect_uri defined for the client will be used by default. 
        :type redirect_uri: str
        :param refresh_token: The refresh token to be exchanged. You can copy this value from the successful response received when generating an access token.
        :type refresh_token: str
        :param scope: Optional scope value when refreshing an access token. Separate multiple [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) with a single space between each scope.  The requested scope cannot include any permissions not already granted, so this parameter allows you to limit the scope when refreshing a token. If omitted, the scope for the token remains unchanged. 
        :type scope: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exchange_access_token_serialize(
            grant_type=grant_type,
            code_verifier=code_verifier,
            code=code,
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            refresh_token=refresh_token,
            scope=scope,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangeAccessTokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def exchange_access_token_without_preload_content(
        self,
        grant_type: Annotated[Optional[StrictStr], Field(description="For generating an access token using a refresh token.")] = None,
        code_verifier: Annotated[Optional[StrictStr], Field(description="The `code_verifier` value that you generated when creating the user authorization URL.")] = None,
        code: Annotated[Optional[StrictStr], Field(description="The authorization code you received after the user authorized the integration.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="Only required if a redirect URL was supplied when you [created the user authorization URL](https://www.canva.dev/docs/connect/authentication/#create-the-authorization-url).  Must be one of those already specified by the client. If not supplied, the first redirect_uri defined for the client will be used by default. ")] = None,
        refresh_token: Annotated[Optional[StrictStr], Field(description="The refresh token to be exchanged. You can copy this value from the successful response received when generating an access token.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Optional scope value when refreshing an access token. Separate multiple [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) with a single space between each scope.  The requested scope cannot include any permissions not already granted, so this parameter allows you to limit the scope when refreshing a token. If omitted, the scope for the token remains unchanged. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """exchange_access_token

        This endpoint implements the OAuth 2.0 `token` endpoint, as part of the Authorization Code flow with Proof Key for Code Exchange (PKCE). For more information, see [Authentication](https://www.canva.dev/docs/connect/authentication/).  To generate an access token, you must provide one of the following:  - An authorization code - A refresh token  Generating a token using either an authorization code or a refresh token allows your integration to act on behalf of a user. You must first [obtain user authorization and get an authorization code](https://www.canva.dev/docs/connect/authentication/#obtain-user-authorization).  Access tokens may be up to 4 KB in size, and are only valid for a specified period of time. The expiry time (currently 4 hours) is shown in the endpoint response and is subject to change.  **Endpoint authentication**  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.  **Generate an access token using an authorization code**  To generate an access token with an authorization code, you must:  - Set `grant_type` to `authorization_code`. - Provide the `code_verifier` value that you generated when creating the user authorization URL. - Provide the authorization code you received after the user authorized the integration.  **Generate an access token using a refresh token**  Using the `refresh_token` value from a previous user token request, you can get a new access token with the same or smaller scope as the previous one, but with a refreshed expiry time. You will also receive a new refresh token that you can use to refresh the access token again.  To refresh an existing access token, you must:  - Set `grant_type` to `refresh_token`. - Provide the `refresh_token` from a previous token request.

        :param grant_type: For generating an access token using a refresh token.
        :type grant_type: str
        :param code_verifier: The `code_verifier` value that you generated when creating the user authorization URL.
        :type code_verifier: str
        :param code: The authorization code you received after the user authorized the integration.
        :type code: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :param redirect_uri: Only required if a redirect URL was supplied when you [created the user authorization URL](https://www.canva.dev/docs/connect/authentication/#create-the-authorization-url).  Must be one of those already specified by the client. If not supplied, the first redirect_uri defined for the client will be used by default. 
        :type redirect_uri: str
        :param refresh_token: The refresh token to be exchanged. You can copy this value from the successful response received when generating an access token.
        :type refresh_token: str
        :param scope: Optional scope value when refreshing an access token. Separate multiple [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) with a single space between each scope.  The requested scope cannot include any permissions not already granted, so this parameter allows you to limit the scope when refreshing a token. If omitted, the scope for the token remains unchanged. 
        :type scope: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exchange_access_token_serialize(
            grant_type=grant_type,
            code_verifier=code_verifier,
            code=code,
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            refresh_token=refresh_token,
            scope=scope,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangeAccessTokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _exchange_access_token_serialize(
        self,
        grant_type,
        code_verifier,
        code,
        client_id,
        client_secret,
        redirect_uri,
        refresh_token,
        scope,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if grant_type is not None:
            _form_params.append(('grant_type', grant_type))
        if code_verifier is not None:
            _form_params.append(('code_verifier', code_verifier))
        if code is not None:
            _form_params.append(('code', code))
        if client_id is not None:
            _form_params.append(('client_id', client_id))
        if client_secret is not None:
            _form_params.append(('client_secret', client_secret))
        if redirect_uri is not None:
            _form_params.append(('redirect_uri', redirect_uri))
        if refresh_token is not None:
            _form_params.append(('refresh_token', refresh_token))
        if scope is not None:
            _form_params.append(('scope', scope))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/oauth/token',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def introspect_token(
        self,
        token: Annotated[StrictStr, Field(description="The token to introspect.")],
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> IntrospectTokenResponse:
        """introspect_token

        Introspect an access token to see whether it is valid and active. You can also verify some token properties, such as its claims, scopes, and validity times.  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.

        :param token: The token to introspect. (required)
        :type token: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._introspect_token_serialize(
            token=token,
            client_id=client_id,
            client_secret=client_secret,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IntrospectTokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def introspect_token_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="The token to introspect.")],
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[IntrospectTokenResponse]:
        """introspect_token

        Introspect an access token to see whether it is valid and active. You can also verify some token properties, such as its claims, scopes, and validity times.  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.

        :param token: The token to introspect. (required)
        :type token: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._introspect_token_serialize(
            token=token,
            client_id=client_id,
            client_secret=client_secret,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IntrospectTokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def introspect_token_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="The token to introspect.")],
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """introspect_token

        Introspect an access token to see whether it is valid and active. You can also verify some token properties, such as its claims, scopes, and validity times.  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.

        :param token: The token to introspect. (required)
        :type token: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._introspect_token_serialize(
            token=token,
            client_id=client_id,
            client_secret=client_secret,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IntrospectTokenResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _introspect_token_serialize(
        self,
        token,
        client_id,
        client_secret,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(('token', token))
        if client_id is not None:
            _form_params.append(('client_id', client_id))
        if client_secret is not None:
            _form_params.append(('client_secret', client_secret))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/oauth/introspect',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def revoke_tokens(
        self,
        token: Annotated[StrictStr, Field(description="The token to revoke.")],
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> object:
        """revoke_tokens

        Revoke an access token or a refresh token.  If you revoke a _refresh token_, be aware that:  - The refresh token's lineage is also revoked. This means that access tokens created from that refresh token are also revoked. - The user's consent for your integration is also revoked. This means that the user must go through the OAuth process again to use your integration.  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.

        :param token: The token to revoke. (required)
        :type token: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._revoke_tokens_serialize(
            token=token,
            client_id=client_id,
            client_secret=client_secret,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def revoke_tokens_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="The token to revoke.")],
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[object]:
        """revoke_tokens

        Revoke an access token or a refresh token.  If you revoke a _refresh token_, be aware that:  - The refresh token's lineage is also revoked. This means that access tokens created from that refresh token are also revoked. - The user's consent for your integration is also revoked. This means that the user must go through the OAuth process again to use your integration.  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.

        :param token: The token to revoke. (required)
        :type token: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._revoke_tokens_serialize(
            token=token,
            client_id=client_id,
            client_secret=client_secret,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def revoke_tokens_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="The token to revoke.")],
        client_id: Annotated[Optional[StrictStr], Field(description="Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        client_secret: Annotated[Optional[StrictStr], Field(description="Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. ")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """revoke_tokens

        Revoke an access token or a refresh token.  If you revoke a _refresh token_, be aware that:  - The refresh token's lineage is also revoked. This means that access tokens created from that refresh token are also revoked. - The user's consent for your integration is also revoked. This means that the user must go through the OAuth process again to use your integration.  Requests to this endpoint require authentication with your client ID and client secret, using _one_ of the following methods:  - **Basic access authentication** (Recommended): For [basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication), the `{credentials}` string must be a Base64 encoded value of `{client id}:{client secret}`. - **Body parameters**: Provide your integration's credentials using the `client_id` and `client_secret` body parameters.  This endpoint can't be called from a user's web-browser client because it uses client authentication with client secrets. Requests must come from your integration's backend, otherwise they'll be blocked by Canva's [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policy.

        :param token: The token to revoke. (required)
        :type token: str
        :param client_id: Your integration's unique ID, for authenticating the request.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_id: str
        :param client_secret: Your integration's client secret, for authenticating the request. Begins with `cnvca`.  NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters. 
        :type client_secret: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._revoke_tokens_serialize(
            token=token,
            client_id=client_id,
            client_secret=client_secret,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _revoke_tokens_serialize(
        self,
        token,
        client_id,
        client_secret,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(('token', token))
        if client_id is not None:
            _form_params.append(('client_id', client_id))
        if client_secret is not None:
            _form_params.append(('client_secret', client_secret))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/oauth/revoke',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )


