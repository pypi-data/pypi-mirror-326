# File generated from <stdin>, with the command:
#  ./third_party/pdl/pdl-compiler/scripts/generate_python_backend.py --custom-type-location ..bluetooth --output py/src/rootcanal/packets/hci.py
# /!\ Do not edit by hand.

from ..bluetooth import Address
from dataclasses import dataclass, field, fields
from typing import Optional, List, Tuple
import enum
import inspect
import math

@dataclass
class Packet:
    payload: Optional[bytes] = field(repr=False, default_factory=bytes, compare=False)

    @classmethod
    def parse_all(cls, span: bytes) -> 'Packet':
        packet, remain = getattr(cls, 'parse')(span)
        if len(remain) > 0:
            raise Exception('Unexpected parsing remainder')
        return packet

    @property
    def size(self) -> int:
        pass

    def show(self, prefix: str = ''):
        print(f'{self.__class__.__name__}')

        def print_val(p: str, pp: str, name: str, align: int, typ, val):
            if name == 'payload':
                pass

            # Scalar fields.
            elif typ is int:
                print(f'{p}{name:{align}} = {val} (0x{val:x})')

            # Byte fields.
            elif typ is bytes:
                print(f'{p}{name:{align}} = [', end='')
                line = ''
                n_pp = ''
                for (idx, b) in enumerate(val):
                    if idx > 0 and idx % 8 == 0:
                        print(f'{n_pp}{line}')
                        line = ''
                        n_pp = pp + (' ' * (align + 4))
                    line += f' {b:02x}'
                print(f'{n_pp}{line} ]')

            # Enum fields.
            elif inspect.isclass(typ) and issubclass(typ, enum.IntEnum):
                print(f'{p}{name:{align}} = {typ.__name__}::{val.name} (0x{val:x})')

            # Struct fields.
            elif inspect.isclass(typ) and issubclass(typ, globals().get('Packet')):
                print(f'{p}{name:{align}} = ', end='')
                val.show(prefix=pp)

            # Array fields.
            elif getattr(typ, '__origin__', None) == list:
                print(f'{p}{name:{align}}')
                last = len(val) - 1
                align = 5
                for (idx, elt) in enumerate(val):
                    n_p  = pp + ('├── ' if idx != last else '└── ')
                    n_pp = pp + ('│   ' if idx != last else '    ')
                    print_val(n_p, n_pp, f'[{idx}]', align, typ.__args__[0], val[idx])

            # Custom fields.
            elif inspect.isclass(typ):
                print(f'{p}{name:{align}} = {repr(val)}')

            else:
                print(f'{p}{name:{align}} = ##{typ}##')

        last = len(fields(self)) - 1
        align = max(len(f.name) for f in fields(self) if f.name != 'payload')

        for (idx, f) in enumerate(fields(self)):
            p  = prefix + ('├── ' if idx != last else '└── ')
            pp = prefix + ('│   ' if idx != last else '    ')
            val = getattr(self, f.name)

            print_val(p, pp, f.name, align, f.type, val)

if (not callable(getattr(Address, 'parse', None)) or
    not callable(getattr(Address, 'parse_all', None))):
    raise Exception('The custom field type Address does not implement the parse method')

class Enable(enum.IntEnum):
    DISABLED = 0x0
    ENABLED = 0x1

class PacketBoundaryFlag(enum.IntEnum):
    FIRST_NON_AUTOMATICALLY_FLUSHABLE = 0x0
    CONTINUING_FRAGMENT = 0x1
    FIRST_AUTOMATICALLY_FLUSHABLE = 0x2

class BroadcastFlag(enum.IntEnum):
    POINT_TO_POINT = 0x0
    ACTIVE_PERIPHERAL_BROADCAST = 0x1

@dataclass
class Acl(Packet):
    handle: int = field(kw_only=True, default=0)
    packet_boundary_flag: PacketBoundaryFlag = field(kw_only=True, default=PacketBoundaryFlag.FIRST_NON_AUTOMATICALLY_FLUSHABLE)
    broadcast_flag: BroadcastFlag = field(kw_only=True, default=BroadcastFlag.POINT_TO_POINT)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['Acl', bytes]:
        fields = {'payload': None}
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['handle'] = (value_ >> 0) & 0xfff
        fields['packet_boundary_flag'] = PacketBoundaryFlag((value_ >> 12) & 0x3)
        fields['broadcast_flag'] = BroadcastFlag((value_ >> 14) & 0x3)
        value_ = int.from_bytes(span[2:4], byteorder='little')
        _payload__size = value_
        span = span[4:]
        if len(span) < _payload__size:
            raise Exception('Invalid packet size')
        payload = span[:_payload__size]
        span = span[_payload__size:]
        fields['payload'] = payload
        return Acl(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.handle > 4095:
            print(f"Invalid value for field Acl::handle: {self.handle} > 4095; the value will be truncated")
            self.handle &= 4095
        _value = (
            (self.handle << 0) |
            (self.packet_boundary_flag << 12) |
            (self.broadcast_flag << 14)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        _payload_size = len(payload or self.payload or [])
        if _payload_size > 65535:
            print(f"Invalid length for payload field:  {_payload_size} > 65535; the packet cannot be generated")
            raise Exception("Invalid payload length")
        _span.extend(int.to_bytes((_payload_size << 0), length=2, byteorder='little'))
        _span.extend(payload or self.payload or [])
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.payload) + 4

class PacketStatusFlag(enum.IntEnum):
    CORRECTLY_RECEIVED = 0x0
    POSSIBLY_INCOMPLETE = 0x1
    NO_DATA_RECEIVED = 0x2
    PARTIALLY_LOST = 0x3

@dataclass
class Sco(Packet):
    handle: int = field(kw_only=True, default=0)
    packet_status_flag: PacketStatusFlag = field(kw_only=True, default=PacketStatusFlag.CORRECTLY_RECEIVED)
    data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['Sco', bytes]:
        fields = {'payload': None}
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['handle'] = (value_ >> 0) & 0xfff
        fields['packet_status_flag'] = PacketStatusFlag((value_ >> 12) & 0x3)
        data_size = span[2]
        span = span[3:]
        if len(span) < data_size:
            raise Exception('Invalid packet size')
        fields['data'] = list(span[:data_size])
        span = span[data_size:]
        return Sco(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.handle > 4095:
            print(f"Invalid value for field Sco::handle: {self.handle} > 4095; the value will be truncated")
            self.handle &= 4095
        _value = (
            (self.handle << 0) |
            (self.packet_status_flag << 12)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        _span.append(((len(self.data) * 1) << 0))
        _span.extend(self.data)
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.data) * 1 + 3

class OpCode(enum.IntEnum):
    NONE = 0x0
    INQUIRY = 0x401
    INQUIRY_CANCEL = 0x402
    PERIODIC_INQUIRY_MODE = 0x403
    EXIT_PERIODIC_INQUIRY_MODE = 0x404
    CREATE_CONNECTION = 0x405
    DISCONNECT = 0x406
    ADD_SCO_CONNECTION = 0x407
    CREATE_CONNECTION_CANCEL = 0x408
    ACCEPT_CONNECTION_REQUEST = 0x409
    REJECT_CONNECTION_REQUEST = 0x40a
    LINK_KEY_REQUEST_REPLY = 0x40b
    LINK_KEY_REQUEST_NEGATIVE_REPLY = 0x40c
    PIN_CODE_REQUEST_REPLY = 0x40d
    PIN_CODE_REQUEST_NEGATIVE_REPLY = 0x40e
    CHANGE_CONNECTION_PACKET_TYPE = 0x40f
    AUTHENTICATION_REQUESTED = 0x411
    SET_CONNECTION_ENCRYPTION = 0x413
    CHANGE_CONNECTION_LINK_KEY = 0x415
    CENTRAL_LINK_KEY = 0x417
    REMOTE_NAME_REQUEST = 0x419
    REMOTE_NAME_REQUEST_CANCEL = 0x41a
    READ_REMOTE_SUPPORTED_FEATURES = 0x41b
    READ_REMOTE_EXTENDED_FEATURES = 0x41c
    READ_REMOTE_VERSION_INFORMATION = 0x41d
    READ_CLOCK_OFFSET = 0x41f
    READ_LMP_HANDLE = 0x420
    SETUP_SYNCHRONOUS_CONNECTION = 0x428
    ACCEPT_SYNCHRONOUS_CONNECTION = 0x429
    REJECT_SYNCHRONOUS_CONNECTION = 0x42a
    IO_CAPABILITY_REQUEST_REPLY = 0x42b
    USER_CONFIRMATION_REQUEST_REPLY = 0x42c
    USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY = 0x42d
    USER_PASSKEY_REQUEST_REPLY = 0x42e
    USER_PASSKEY_REQUEST_NEGATIVE_REPLY = 0x42f
    REMOTE_OOB_DATA_REQUEST_REPLY = 0x430
    REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY = 0x433
    IO_CAPABILITY_REQUEST_NEGATIVE_REPLY = 0x434
    ENHANCED_SETUP_SYNCHRONOUS_CONNECTION = 0x43d
    ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION = 0x43e
    TRUNCATED_PAGE = 0x43f
    TRUNCATED_PAGE_CANCEL = 0x440
    SET_CONNECTIONLESS_PERIPHERAL_BROADCAST = 0x441
    SET_CONNECTIONLESS_PERIPHERAL_BROADCAST_RECEIVE = 0x442
    START_SYNCHRONIZATION_TRAIN = 0x443
    RECEIVE_SYNCHRONIZATION_TRAIN = 0x444
    REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY = 0x445
    HOLD_MODE = 0x801
    SNIFF_MODE = 0x803
    EXIT_SNIFF_MODE = 0x804
    QOS_SETUP = 0x807
    ROLE_DISCOVERY = 0x809
    SWITCH_ROLE = 0x80b
    READ_LINK_POLICY_SETTINGS = 0x80c
    WRITE_LINK_POLICY_SETTINGS = 0x80d
    READ_DEFAULT_LINK_POLICY_SETTINGS = 0x80e
    WRITE_DEFAULT_LINK_POLICY_SETTINGS = 0x80f
    FLOW_SPECIFICATION = 0x810
    SNIFF_SUBRATING = 0x811
    SET_EVENT_MASK = 0xc01
    RESET = 0xc03
    SET_EVENT_FILTER = 0xc05
    FLUSH = 0xc08
    READ_PIN_TYPE = 0xc09
    WRITE_PIN_TYPE = 0xc0a
    READ_STORED_LINK_KEY = 0xc0d
    WRITE_STORED_LINK_KEY = 0xc11
    DELETE_STORED_LINK_KEY = 0xc12
    WRITE_LOCAL_NAME = 0xc13
    READ_LOCAL_NAME = 0xc14
    READ_CONNECTION_ACCEPT_TIMEOUT = 0xc15
    WRITE_CONNECTION_ACCEPT_TIMEOUT = 0xc16
    READ_PAGE_TIMEOUT = 0xc17
    WRITE_PAGE_TIMEOUT = 0xc18
    READ_SCAN_ENABLE = 0xc19
    WRITE_SCAN_ENABLE = 0xc1a
    READ_PAGE_SCAN_ACTIVITY = 0xc1b
    WRITE_PAGE_SCAN_ACTIVITY = 0xc1c
    READ_INQUIRY_SCAN_ACTIVITY = 0xc1d
    WRITE_INQUIRY_SCAN_ACTIVITY = 0xc1e
    READ_AUTHENTICATION_ENABLE = 0xc1f
    WRITE_AUTHENTICATION_ENABLE = 0xc20
    READ_CLASS_OF_DEVICE = 0xc23
    WRITE_CLASS_OF_DEVICE = 0xc24
    READ_VOICE_SETTING = 0xc25
    WRITE_VOICE_SETTING = 0xc26
    READ_AUTOMATIC_FLUSH_TIMEOUT = 0xc27
    WRITE_AUTOMATIC_FLUSH_TIMEOUT = 0xc28
    READ_NUM_BROADCAST_RETRANSMITS = 0xc29
    WRITE_NUM_BROADCAST_RETRANSMITS = 0xc2a
    READ_HOLD_MODE_ACTIVITY = 0xc2b
    WRITE_HOLD_MODE_ACTIVITY = 0xc2c
    READ_TRANSMIT_POWER_LEVEL = 0xc2d
    READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE = 0xc2e
    WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE = 0xc2f
    SET_CONTROLLER_TO_HOST_FLOW_CONTROL = 0xc31
    HOST_BUFFER_SIZE = 0xc33
    HOST_NUMBER_OF_COMPLETED_PACKETS = 0xc35
    READ_LINK_SUPERVISION_TIMEOUT = 0xc36
    WRITE_LINK_SUPERVISION_TIMEOUT = 0xc37
    READ_NUMBER_OF_SUPPORTED_IAC = 0xc38
    READ_CURRENT_IAC_LAP = 0xc39
    WRITE_CURRENT_IAC_LAP = 0xc3a
    SET_AFH_HOST_CHANNEL_CLASSIFICATION = 0xc3f
    READ_INQUIRY_SCAN_TYPE = 0xc42
    WRITE_INQUIRY_SCAN_TYPE = 0xc43
    READ_INQUIRY_MODE = 0xc44
    WRITE_INQUIRY_MODE = 0xc45
    READ_PAGE_SCAN_TYPE = 0xc46
    WRITE_PAGE_SCAN_TYPE = 0xc47
    READ_AFH_CHANNEL_ASSESSMENT_MODE = 0xc48
    WRITE_AFH_CHANNEL_ASSESSMENT_MODE = 0xc49
    READ_EXTENDED_INQUIRY_RESPONSE = 0xc51
    WRITE_EXTENDED_INQUIRY_RESPONSE = 0xc52
    REFRESH_ENCRYPTION_KEY = 0xc53
    READ_SIMPLE_PAIRING_MODE = 0xc55
    WRITE_SIMPLE_PAIRING_MODE = 0xc56
    READ_LOCAL_OOB_DATA = 0xc57
    READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL = 0xc58
    WRITE_INQUIRY_TRANSMIT_POWER_LEVEL = 0xc59
    READ_DEFAULT_ERRONEOUS_DATA_REPORTING = 0xc5a
    WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING = 0xc5b
    ENHANCED_FLUSH = 0xc5f
    SEND_KEYPRESS_NOTIFICATION = 0xc60
    SET_EVENT_MASK_PAGE_2 = 0xc63
    READ_FLOW_CONTROL_MODE = 0xc66
    WRITE_FLOW_CONTROL_MODE = 0xc67
    READ_ENHANCED_TRANSMIT_POWER_LEVEL = 0xc68
    READ_LE_HOST_SUPPORT = 0xc6c
    WRITE_LE_HOST_SUPPORT = 0xc6d
    SET_MWS_CHANNEL_PARAMETERS = 0xc6e
    SET_EXTERNAL_FRAME_CONFIGURATION = 0xc6f
    SET_MWS_SIGNALING = 0xc70
    SET_MWS_TRANSPORT_LAYER = 0xc71
    SET_MWS_SCAN_FREQUENCY_TABLE = 0xc72
    SET_MWS_PATTERN_CONFIGURATION = 0xc73
    SET_RESERVED_LT_ADDR = 0xc74
    DELETE_RESERVED_LT_ADDR = 0xc75
    SET_CONNECTIONLESS_PERIPHERAL_BROADCAST_DATA = 0xc76
    READ_SYNCHRONIZATION_TRAIN_PARAMETERS = 0xc77
    WRITE_SYNCHRONIZATION_TRAIN_PARAMETERS = 0xc78
    READ_SECURE_CONNECTIONS_HOST_SUPPORT = 0xc79
    WRITE_SECURE_CONNECTIONS_HOST_SUPPORT = 0xc7a
    READ_AUTHENTICATED_PAYLOAD_TIMEOUT = 0xc7b
    WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT = 0xc7c
    READ_LOCAL_OOB_EXTENDED_DATA = 0xc7d
    READ_EXTENDED_PAGE_TIMEOUT = 0xc7e
    WRITE_EXTENDED_PAGE_TIMEOUT = 0xc7f
    READ_EXTENDED_INQUIRY_LENGTH = 0xc80
    WRITE_EXTENDED_INQUIRY_LENGTH = 0xc81
    SET_ECOSYSTEM_BASE_INTERVAL = 0xc82
    CONFIGURE_DATA_PATH = 0xc83
    SET_MIN_ENCRYPTION_KEY_SIZE = 0xc84
    READ_LOCAL_VERSION_INFORMATION = 0x1001
    READ_LOCAL_SUPPORTED_COMMANDS = 0x1002
    READ_LOCAL_SUPPORTED_FEATURES = 0x1003
    READ_LOCAL_EXTENDED_FEATURES = 0x1004
    READ_BUFFER_SIZE = 0x1005
    READ_BD_ADDR = 0x1009
    READ_DATA_BLOCK_SIZE = 0x100a
    READ_LOCAL_SUPPORTED_CODECS_V1 = 0x100b
    READ_LOCAL_SIMPLE_PAIRING_OPTIONS = 0x100c
    READ_LOCAL_SUPPORTED_CODECS_V2 = 0x100d
    READ_LOCAL_SUPPORTED_CODEC_CAPABILITIES = 0x100e
    READ_LOCAL_SUPPORTED_CONTROLLER_DELAY = 0x100f
    READ_FAILED_CONTACT_COUNTER = 0x1401
    RESET_FAILED_CONTACT_COUNTER = 0x1402
    READ_LINK_QUALITY = 0x1403
    READ_RSSI = 0x1405
    READ_AFH_CHANNEL_MAP = 0x1406
    READ_CLOCK = 0x1407
    READ_ENCRYPTION_KEY_SIZE = 0x1408
    GET_MWS_TRANSPORT_LAYER_CONFIGURATION = 0x140c
    SET_TRIGGERED_CLOCK_CAPTURE = 0x140d
    READ_LOOPBACK_MODE = 0x1801
    WRITE_LOOPBACK_MODE = 0x1802
    ENABLE_IMPLEMENTATION_UNDER_TEST_MODE = 0x1803
    WRITE_SIMPLE_PAIRING_DEBUG_MODE = 0x1804
    WRITE_SECURE_CONNECTIONS_TEST_MODE = 0x180a
    LE_SET_EVENT_MASK = 0x2001
    LE_READ_BUFFER_SIZE_V1 = 0x2002
    LE_READ_LOCAL_SUPPORTED_FEATURES_PAGE_0 = 0x2003
    LE_SET_RANDOM_ADDRESS = 0x2005
    LE_SET_ADVERTISING_PARAMETERS = 0x2006
    LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER = 0x2007
    LE_SET_ADVERTISING_DATA = 0x2008
    LE_SET_SCAN_RESPONSE_DATA = 0x2009
    LE_SET_ADVERTISING_ENABLE = 0x200a
    LE_SET_SCAN_PARAMETERS = 0x200b
    LE_SET_SCAN_ENABLE = 0x200c
    LE_CREATE_CONNECTION = 0x200d
    LE_CREATE_CONNECTION_CANCEL = 0x200e
    LE_READ_FILTER_ACCEPT_LIST_SIZE = 0x200f
    LE_CLEAR_FILTER_ACCEPT_LIST = 0x2010
    LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST = 0x2011
    LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST = 0x2012
    LE_CONNECTION_UPDATE = 0x2013
    LE_SET_HOST_CHANNEL_CLASSIFICATION = 0x2014
    LE_READ_CHANNEL_MAP = 0x2015
    LE_READ_REMOTE_FEATURES_PAGE_0 = 0x2016
    LE_ENCRYPT = 0x2017
    LE_RAND = 0x2018
    LE_START_ENCRYPTION = 0x2019
    LE_LONG_TERM_KEY_REQUEST_REPLY = 0x201a
    LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY = 0x201b
    LE_READ_SUPPORTED_STATES = 0x201c
    LE_RECEIVER_TEST_V1 = 0x201d
    LE_TRANSMITTER_TEST_V1 = 0x201e
    LE_TEST_END = 0x201f
    LE_REMOTE_CONNECTION_PARAMETER_REQUEST_REPLY = 0x2020
    LE_REMOTE_CONNECTION_PARAMETER_REQUEST_NEGATIVE_REPLY = 0x2021
    LE_SET_DATA_LENGTH = 0x2022
    LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH = 0x2023
    LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH = 0x2024
    LE_READ_LOCAL_P_256_PUBLIC_KEY = 0x2025
    LE_GENERATE_DHKEY_V1 = 0x2026
    LE_ADD_DEVICE_TO_RESOLVING_LIST = 0x2027
    LE_REMOVE_DEVICE_FROM_RESOLVING_LIST = 0x2028
    LE_CLEAR_RESOLVING_LIST = 0x2029
    LE_READ_RESOLVING_LIST_SIZE = 0x202a
    LE_READ_PEER_RESOLVABLE_ADDRESS = 0x202b
    LE_READ_LOCAL_RESOLVABLE_ADDRESS = 0x202c
    LE_SET_ADDRESS_RESOLUTION_ENABLE = 0x202d
    LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT = 0x202e
    LE_READ_MAXIMUM_DATA_LENGTH = 0x202f
    LE_READ_PHY = 0x2030
    LE_SET_DEFAULT_PHY = 0x2031
    LE_SET_PHY = 0x2032
    LE_RECEIVER_TEST_V2 = 0x2033
    LE_TRANSMITTER_TEST_V2 = 0x2034
    LE_SET_ADVERTISING_SET_RANDOM_ADDRESS = 0x2035
    LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V1 = 0x2036
    LE_SET_EXTENDED_ADVERTISING_DATA = 0x2037
    LE_SET_EXTENDED_SCAN_RESPONSE_DATA = 0x2038
    LE_SET_EXTENDED_ADVERTISING_ENABLE = 0x2039
    LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH = 0x203a
    LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS = 0x203b
    LE_REMOVE_ADVERTISING_SET = 0x203c
    LE_CLEAR_ADVERTISING_SETS = 0x203d
    LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V1 = 0x203e
    LE_SET_PERIODIC_ADVERTISING_DATA = 0x203f
    LE_SET_PERIODIC_ADVERTISING_ENABLE = 0x2040
    LE_SET_EXTENDED_SCAN_PARAMETERS = 0x2041
    LE_SET_EXTENDED_SCAN_ENABLE = 0x2042
    LE_EXTENDED_CREATE_CONNECTION_V1 = 0x2043
    LE_PERIODIC_ADVERTISING_CREATE_SYNC = 0x2044
    LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL = 0x2045
    LE_PERIODIC_ADVERTISING_TERMINATE_SYNC = 0x2046
    LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST = 0x2047
    LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST = 0x2048
    LE_CLEAR_PERIODIC_ADVERTISER_LIST = 0x2049
    LE_READ_PERIODIC_ADVERTISER_LIST_SIZE = 0x204a
    LE_READ_TRANSMIT_POWER = 0x204b
    LE_READ_RF_PATH_COMPENSATION_POWER = 0x204c
    LE_WRITE_RF_PATH_COMPENSATION_POWER = 0x204d
    LE_SET_PRIVACY_MODE = 0x204e
    LE_RECEIVER_TEST_V3 = 0x204f
    LE_TRANSMITTER_TEST_V3 = 0x2050
    LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS = 0x2051
    LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE = 0x2052
    LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE = 0x2053
    LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS = 0x2054
    LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS = 0x2055
    LE_CONNECTION_CTE_REQUEST_ENABLE = 0x2056
    LE_CONNECTION_CTE_RESPONSE_ENABLE = 0x2057
    LE_READ_ANTENNA_INFORMATION = 0x2058
    LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE = 0x2059
    LE_PERIODIC_ADVERTISING_SYNC_TRANSFER = 0x205a
    LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER = 0x205b
    LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS = 0x205c
    LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS = 0x205d
    LE_GENERATE_DHKEY_V2 = 0x205e
    LE_MODIFY_SLEEP_CLOCK_ACCURACY = 0x205f
    LE_READ_BUFFER_SIZE_V2 = 0x2060
    LE_READ_ISO_TX_SYNC = 0x2061
    LE_SET_CIG_PARAMETERS = 0x2062
    LE_SET_CIG_PARAMETERS_TEST = 0x2063
    LE_CREATE_CIS = 0x2064
    LE_REMOVE_CIG = 0x2065
    LE_ACCEPT_CIS_REQUEST = 0x2066
    LE_REJECT_CIS_REQUEST = 0x2067
    LE_CREATE_BIG = 0x2068
    LE_CREATE_BIG_TEST = 0x2069
    LE_TERMINATE_BIG = 0x206a
    LE_BIG_CREATE_SYNC = 0x206b
    LE_BIG_TERMINATE_SYNC = 0x206c
    LE_REQUEST_PEER_SCA = 0x206d
    LE_SETUP_ISO_DATA_PATH = 0x206e
    LE_REMOVE_ISO_DATA_PATH = 0x206f
    LE_ISO_TRANSMIT_TEST = 0x2070
    LE_ISO_RECEIVE_TEST = 0x2071
    LE_ISO_READ_TEST_COUNTERS = 0x2072
    LE_ISO_TEST_END = 0x2073
    LE_SET_HOST_FEATURE_V1 = 0x2074
    LE_READ_ISO_LINK_QUALITY = 0x2075
    LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL = 0x2076
    LE_READ_REMOTE_TRANSMIT_POWER_LEVEL = 0x2077
    LE_SET_PATH_LOSS_REPORTING_PARAMETERS = 0x2078
    LE_SET_PATH_LOSS_REPORTING_ENABLE = 0x2079
    LE_SET_TRANSMIT_POWER_REPORTING_ENABLE = 0x207a
    LE_TRANSMITTER_TEST_V4 = 0x207b
    LE_SET_DATA_RELATED_ADDRESS_CHANGES = 0x207c
    LE_SET_DEFAULT_SUBRATE = 0x207d
    LE_SUBRATE_REQUEST = 0x207e
    LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2 = 0x207f
    LE_SET_DECISION_DATA = 0x2080
    LE_SET_DECISION_INSTRUCTIONS = 0x2081
    LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA = 0x2082
    LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA = 0x2083
    LE_SET_PERIODIC_SYNC_SUBEVENT = 0x2084
    LE_EXTENDED_CREATE_CONNECTION_V2 = 0x2085
    LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2 = 0x2086
    LE_READ_ALL_LOCAL_SUPPORTED_FEATURES = 0x2087
    LE_READ_ALL_REMOTE_FEATURES = 0x2088
    LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES = 0x2089
    LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES = 0x208a
    LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES = 0x208b
    LE_CS_SECURITY_ENABLE = 0x208c
    LE_CS_SET_DEFAULT_SETTINGS = 0x208d
    LE_CS_READ_REMOTE_FAE_TABLE = 0x208e
    LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE = 0x208f
    LE_CS_CREATE_CONFIG = 0x2090
    LE_CS_REMOVE_CONFIG = 0x291
    LE_CS_SET_CHANNEL_CLASSIFICATION = 0x2092
    LE_CS_SET_PROCEDURE_PARAMETERS = 0x2093
    LE_CS_PROCEDURE_ENABLE = 0x2094
    LE_CS_TEST = 0x2095
    LE_CS_TEST_END = 0x2096
    LE_ADD_DEVICE_TO_MONITORED_ADVERTISERS_LIST = 0x2098
    LE_REMOVE_DEVICE_FROM_MONITORED_ADVERTISERS_LIST = 0x2099
    LE_CLEAR_MONITORED_ADVERTISERS_LIST = 0x209a
    LE_READ_MONITORED_ADVERTISERS_LIST_SIZE = 0x209b
    LE_ENABLE_MONITORING_ADVERTISERS = 0x209c
    LE_FRAME_SPACE_UPDATE = 0x209d
    MSFT_OPCODE_INTEL = 0xfc1e
    INTEL_DDC_CONFIG_WRITE = 0xfc8b
    LE_GET_VENDOR_CAPABILITIES = 0xfd53
    LE_BATCH_SCAN = 0xfd56
    LE_APCF = 0xfd57
    LE_GET_CONTROLLER_ACTIVITY_ENERGY_INFO = 0xfd59
    LE_EX_SET_SCAN_PARAMETERS = 0xfd5a
    GET_CONTROLLER_DEBUG_INFO = 0xfd5b
    MSFT_OPCODE_MEDIATEK = 0xfd30
    MSFT_OPCODE_QUALCOMM = 0xfd70

class OpCodeIndex(enum.IntEnum):
    INQUIRY = 0x0
    INQUIRY_CANCEL = 0x1
    PERIODIC_INQUIRY_MODE = 0x2
    EXIT_PERIODIC_INQUIRY_MODE = 0x3
    CREATE_CONNECTION = 0x4
    DISCONNECT = 0x5
    ADD_SCO_CONNECTION = 0x6
    CREATE_CONNECTION_CANCEL = 0x7
    ACCEPT_CONNECTION_REQUEST = 0xa
    REJECT_CONNECTION_REQUEST = 0xb
    LINK_KEY_REQUEST_REPLY = 0xc
    LINK_KEY_REQUEST_NEGATIVE_REPLY = 0xd
    PIN_CODE_REQUEST_REPLY = 0xe
    PIN_CODE_REQUEST_NEGATIVE_REPLY = 0xf
    CHANGE_CONNECTION_PACKET_TYPE = 0x10
    AUTHENTICATION_REQUESTED = 0x11
    SET_CONNECTION_ENCRYPTION = 0x14
    CHANGE_CONNECTION_LINK_KEY = 0x15
    CENTRAL_LINK_KEY = 0x16
    REMOTE_NAME_REQUEST = 0x17
    REMOTE_NAME_REQUEST_CANCEL = 0x18
    READ_REMOTE_SUPPORTED_FEATURES = 0x19
    READ_REMOTE_EXTENDED_FEATURES = 0x1a
    READ_REMOTE_VERSION_INFORMATION = 0x1b
    READ_CLOCK_OFFSET = 0x1e
    READ_LMP_HANDLE = 0x1f
    HOLD_MODE = 0x29
    SNIFF_MODE = 0x2a
    EXIT_SNIFF_MODE = 0x2b
    QOS_SETUP = 0x2e
    ROLE_DISCOVERY = 0x2f
    SWITCH_ROLE = 0x32
    READ_LINK_POLICY_SETTINGS = 0x33
    WRITE_LINK_POLICY_SETTINGS = 0x34
    READ_DEFAULT_LINK_POLICY_SETTINGS = 0x35
    WRITE_DEFAULT_LINK_POLICY_SETTINGS = 0x36
    FLOW_SPECIFICATION = 0x37
    SET_EVENT_MASK = 0x38
    RESET = 0x39
    SET_EVENT_FILTER = 0x3c
    FLUSH = 0x3d
    READ_PIN_TYPE = 0x3e
    WRITE_PIN_TYPE = 0x3f
    READ_STORED_LINK_KEY = 0x41
    WRITE_STORED_LINK_KEY = 0x42
    DELETE_STORED_LINK_KEY = 0x43
    WRITE_LOCAL_NAME = 0x46
    READ_LOCAL_NAME = 0x47
    READ_CONNECTION_ACCEPT_TIMEOUT = 0x48
    WRITE_CONNECTION_ACCEPT_TIMEOUT = 0x49
    READ_PAGE_TIMEOUT = 0x4a
    WRITE_PAGE_TIMEOUT = 0x4b
    READ_SCAN_ENABLE = 0x4c
    WRITE_SCAN_ENABLE = 0x4d
    READ_PAGE_SCAN_ACTIVITY = 0x50
    WRITE_PAGE_SCAN_ACTIVITY = 0x51
    READ_INQUIRY_SCAN_ACTIVITY = 0x52
    WRITE_INQUIRY_SCAN_ACTIVITY = 0x53
    READ_AUTHENTICATION_ENABLE = 0x54
    WRITE_AUTHENTICATION_ENABLE = 0x55
    READ_CLASS_OF_DEVICE = 0x5a
    WRITE_CLASS_OF_DEVICE = 0x5b
    READ_VOICE_SETTING = 0x5c
    WRITE_VOICE_SETTING = 0x5d
    READ_AUTOMATIC_FLUSH_TIMEOUT = 0x5e
    WRITE_AUTOMATIC_FLUSH_TIMEOUT = 0x5f
    READ_NUM_BROADCAST_RETRANSMITS = 0x60
    WRITE_NUM_BROADCAST_RETRANSMITS = 0x61
    READ_HOLD_MODE_ACTIVITY = 0x64
    WRITE_HOLD_MODE_ACTIVITY = 0x65
    READ_TRANSMIT_POWER_LEVEL = 0x66
    READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE = 0x67
    WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE = 0x68
    SET_CONTROLLER_TO_HOST_FLOW_CONTROL = 0x69
    HOST_BUFFER_SIZE = 0x6a
    HOST_NUMBER_OF_COMPLETED_PACKETS = 0x6b
    READ_LINK_SUPERVISION_TIMEOUT = 0x6e
    WRITE_LINK_SUPERVISION_TIMEOUT = 0x6f
    READ_NUMBER_OF_SUPPORTED_IAC = 0x70
    READ_CURRENT_IAC_LAP = 0x71
    WRITE_CURRENT_IAC_LAP = 0x72
    SET_AFH_HOST_CHANNEL_CLASSIFICATION = 0x79
    LE_CS_READ_REMOTE_FAE_TABLE = 0x7a
    LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE = 0x7b
    READ_INQUIRY_SCAN_TYPE = 0x7c
    WRITE_INQUIRY_SCAN_TYPE = 0x7d
    READ_INQUIRY_MODE = 0x7e
    WRITE_INQUIRY_MODE = 0x7f
    READ_PAGE_SCAN_TYPE = 0x82
    WRITE_PAGE_SCAN_TYPE = 0x83
    READ_AFH_CHANNEL_ASSESSMENT_MODE = 0x84
    WRITE_AFH_CHANNEL_ASSESSMENT_MODE = 0x85
    READ_LOCAL_VERSION_INFORMATION = 0x8f
    READ_LOCAL_SUPPORTED_FEATURES = 0x91
    READ_LOCAL_EXTENDED_FEATURES = 0x92
    READ_BUFFER_SIZE = 0x93
    READ_BD_ADDR = 0x97
    READ_FAILED_CONTACT_COUNTER = 0x98
    RESET_FAILED_CONTACT_COUNTER = 0x99
    READ_LINK_QUALITY = 0x9a
    READ_RSSI = 0x9b
    READ_AFH_CHANNEL_MAP = 0x9c
    READ_CLOCK = 0x9d
    READ_LOOPBACK_MODE = 0xa0
    WRITE_LOOPBACK_MODE = 0xa1
    ENABLE_IMPLEMENTATION_UNDER_TEST_MODE = 0xa2
    SETUP_SYNCHRONOUS_CONNECTION = 0xa3
    ACCEPT_SYNCHRONOUS_CONNECTION = 0xa4
    REJECT_SYNCHRONOUS_CONNECTION = 0xa5
    LE_CS_CREATE_CONFIG = 0xa6
    LE_CS_REMOVE_CONFIG = 0xa7
    READ_EXTENDED_INQUIRY_RESPONSE = 0xaa
    WRITE_EXTENDED_INQUIRY_RESPONSE = 0xab
    REFRESH_ENCRYPTION_KEY = 0xac
    SNIFF_SUBRATING = 0xae
    READ_SIMPLE_PAIRING_MODE = 0xaf
    WRITE_SIMPLE_PAIRING_MODE = 0xb0
    READ_LOCAL_OOB_DATA = 0xb1
    READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL = 0xb4
    WRITE_INQUIRY_TRANSMIT_POWER_LEVEL = 0xb5
    READ_DEFAULT_ERRONEOUS_DATA_REPORTING = 0xb6
    WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING = 0xb7
    IO_CAPABILITY_REQUEST_REPLY = 0xbb
    USER_CONFIRMATION_REQUEST_REPLY = 0xbe
    USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY = 0xbf
    USER_PASSKEY_REQUEST_REPLY = 0xc0
    USER_PASSKEY_REQUEST_NEGATIVE_REPLY = 0xc1
    REMOTE_OOB_DATA_REQUEST_REPLY = 0xc2
    WRITE_SIMPLE_PAIRING_DEBUG_MODE = 0xc3
    ENHANCED_FLUSH = 0xc4
    REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY = 0xc5
    SEND_KEYPRESS_NOTIFICATION = 0xca
    IO_CAPABILITY_REQUEST_NEGATIVE_REPLY = 0xcb
    READ_ENCRYPTION_KEY_SIZE = 0xcc
    LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES = 0xcd
    LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES = 0xce
    LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES = 0xcf
    SET_EVENT_MASK_PAGE_2 = 0xde
    READ_FLOW_CONTROL_MODE = 0xe6
    WRITE_FLOW_CONTROL_MODE = 0xe7
    READ_DATA_BLOCK_SIZE = 0xe8
    LE_CS_TEST = 0xe9
    LE_CS_TEST_END = 0xea
    READ_ENHANCED_TRANSMIT_POWER_LEVEL = 0xf0
    LE_CS_SECURITY_ENABLE = 0xf1
    READ_LE_HOST_SUPPORT = 0xf5
    WRITE_LE_HOST_SUPPORT = 0xf6
    LE_CS_SET_DEFAULT_SETTINGS = 0xf7
    LE_SET_EVENT_MASK = 0xfa
    LE_READ_BUFFER_SIZE_V1 = 0xfb
    LE_READ_LOCAL_SUPPORTED_FEATURES_PAGE_0 = 0xfc
    LE_SET_RANDOM_ADDRESS = 0xfe
    LE_SET_ADVERTISING_PARAMETERS = 0xff
    LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER = 0x100
    LE_SET_ADVERTISING_DATA = 0x101
    LE_SET_SCAN_RESPONSE_DATA = 0x104
    LE_SET_ADVERTISING_ENABLE = 0x105
    LE_SET_SCAN_PARAMETERS = 0x106
    LE_SET_SCAN_ENABLE = 0x107
    LE_CREATE_CONNECTION = 0x108
    LE_CREATE_CONNECTION_CANCEL = 0x109
    LE_READ_FILTER_ACCEPT_LIST_SIZE = 0x10a
    LE_CLEAR_FILTER_ACCEPT_LIST = 0x10b
    LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST = 0x10e
    LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST = 0x10f
    LE_CONNECTION_UPDATE = 0x110
    LE_SET_HOST_CHANNEL_CLASSIFICATION = 0x111
    LE_READ_CHANNEL_MAP = 0x112
    LE_READ_REMOTE_FEATURES_PAGE_0 = 0x113
    LE_ENCRYPT = 0x114
    LE_RAND = 0x115
    LE_START_ENCRYPTION = 0x118
    LE_LONG_TERM_KEY_REQUEST_REPLY = 0x119
    LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY = 0x11a
    LE_READ_SUPPORTED_STATES = 0x11b
    LE_RECEIVER_TEST_V1 = 0x11c
    LE_TRANSMITTER_TEST_V1 = 0x11d
    LE_TEST_END = 0x11e
    LE_ENABLE_MONITORING_ADVERTISERS = 0x11f
    LE_CS_SET_CHANNEL_CLASSIFICATION = 0x122
    LE_CS_SET_PROCEDURE_PARAMETERS = 0x123
    LE_CS_PROCEDURE_ENABLE = 0x124
    ENHANCED_SETUP_SYNCHRONOUS_CONNECTION = 0x125
    ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION = 0x126
    READ_LOCAL_SUPPORTED_CODECS_V1 = 0x127
    SET_MWS_CHANNEL_PARAMETERS = 0x128
    SET_EXTERNAL_FRAME_CONFIGURATION = 0x129
    SET_MWS_SIGNALING = 0x12c
    SET_MWS_TRANSPORT_LAYER = 0x12d
    SET_MWS_SCAN_FREQUENCY_TABLE = 0x12e
    GET_MWS_TRANSPORT_LAYER_CONFIGURATION = 0x12f
    SET_MWS_PATTERN_CONFIGURATION = 0x130
    SET_TRIGGERED_CLOCK_CAPTURE = 0x131
    TRUNCATED_PAGE = 0x132
    TRUNCATED_PAGE_CANCEL = 0x133
    SET_CONNECTIONLESS_PERIPHERAL_BROADCAST = 0x136
    SET_CONNECTIONLESS_PERIPHERAL_BROADCAST_RECEIVE = 0x137
    START_SYNCHRONIZATION_TRAIN = 0x138
    RECEIVE_SYNCHRONIZATION_TRAIN = 0x139
    SET_RESERVED_LT_ADDR = 0x13a
    DELETE_RESERVED_LT_ADDR = 0x13b
    SET_CONNECTIONLESS_PERIPHERAL_BROADCAST_DATA = 0x13c
    READ_SYNCHRONIZATION_TRAIN_PARAMETERS = 0x13d
    WRITE_SYNCHRONIZATION_TRAIN_PARAMETERS = 0x140
    REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY = 0x141
    READ_SECURE_CONNECTIONS_HOST_SUPPORT = 0x142
    WRITE_SECURE_CONNECTIONS_HOST_SUPPORT = 0x143
    READ_AUTHENTICATED_PAYLOAD_TIMEOUT = 0x144
    WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT = 0x145
    READ_LOCAL_OOB_EXTENDED_DATA = 0x146
    WRITE_SECURE_CONNECTIONS_TEST_MODE = 0x147
    READ_EXTENDED_PAGE_TIMEOUT = 0x14a
    WRITE_EXTENDED_PAGE_TIMEOUT = 0x14b
    READ_EXTENDED_INQUIRY_LENGTH = 0x14c
    WRITE_EXTENDED_INQUIRY_LENGTH = 0x14d
    LE_REMOTE_CONNECTION_PARAMETER_REQUEST_REPLY = 0x14e
    LE_REMOTE_CONNECTION_PARAMETER_REQUEST_NEGATIVE_REPLY = 0x14f
    LE_SET_DATA_LENGTH = 0x150
    LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH = 0x151
    LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH = 0x154
    LE_READ_LOCAL_P_256_PUBLIC_KEY = 0x155
    LE_GENERATE_DHKEY_V1 = 0x156
    LE_ADD_DEVICE_TO_RESOLVING_LIST = 0x157
    LE_REMOVE_DEVICE_FROM_RESOLVING_LIST = 0x158
    LE_CLEAR_RESOLVING_LIST = 0x159
    LE_READ_RESOLVING_LIST_SIZE = 0x15a
    LE_READ_PEER_RESOLVABLE_ADDRESS = 0x15b
    LE_READ_LOCAL_RESOLVABLE_ADDRESS = 0x15e
    LE_SET_ADDRESS_RESOLUTION_ENABLE = 0x15f
    LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT = 0x160
    LE_READ_MAXIMUM_DATA_LENGTH = 0x161
    LE_READ_PHY = 0x162
    LE_SET_DEFAULT_PHY = 0x163
    LE_SET_PHY = 0x164
    LE_RECEIVER_TEST_V2 = 0x165
    LE_TRANSMITTER_TEST_V2 = 0x168
    LE_SET_ADVERTISING_SET_RANDOM_ADDRESS = 0x169
    LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V1 = 0x16a
    LE_SET_EXTENDED_ADVERTISING_DATA = 0x16b
    LE_SET_EXTENDED_SCAN_RESPONSE_DATA = 0x16c
    LE_SET_EXTENDED_ADVERTISING_ENABLE = 0x16d
    LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH = 0x16e
    LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS = 0x16f
    LE_REMOVE_ADVERTISING_SET = 0x172
    LE_CLEAR_ADVERTISING_SETS = 0x173
    LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V1 = 0x174
    LE_SET_PERIODIC_ADVERTISING_DATA = 0x175
    LE_SET_PERIODIC_ADVERTISING_ENABLE = 0x176
    LE_SET_EXTENDED_SCAN_PARAMETERS = 0x177
    LE_SET_EXTENDED_SCAN_ENABLE = 0x178
    LE_EXTENDED_CREATE_CONNECTION_V1 = 0x179
    LE_PERIODIC_ADVERTISING_CREATE_SYNC = 0x17c
    LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL = 0x17d
    LE_PERIODIC_ADVERTISING_TERMINATE_SYNC = 0x17e
    LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST = 0x17f
    LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST = 0x180
    LE_CLEAR_PERIODIC_ADVERTISER_LIST = 0x181
    LE_READ_PERIODIC_ADVERTISER_LIST_SIZE = 0x182
    LE_READ_TRANSMIT_POWER = 0x183
    LE_READ_RF_PATH_COMPENSATION_POWER = 0x186
    LE_WRITE_RF_PATH_COMPENSATION_POWER = 0x187
    LE_SET_PRIVACY_MODE = 0x188
    LE_RECEIVER_TEST_V3 = 0x189
    LE_TRANSMITTER_TEST_V3 = 0x18a
    LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS = 0x18b
    LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE = 0x18c
    LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE = 0x18d
    LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS = 0x190
    LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS = 0x191
    LE_CONNECTION_CTE_REQUEST_ENABLE = 0x192
    LE_CONNECTION_CTE_RESPONSE_ENABLE = 0x193
    LE_READ_ANTENNA_INFORMATION = 0x194
    LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE = 0x195
    LE_PERIODIC_ADVERTISING_SYNC_TRANSFER = 0x196
    LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER = 0x197
    LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS = 0x19a
    LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS = 0x19b
    LE_GENERATE_DHKEY_V2 = 0x19c
    READ_LOCAL_SIMPLE_PAIRING_OPTIONS = 0x19d
    LE_MODIFY_SLEEP_CLOCK_ACCURACY = 0x19e
    LE_READ_BUFFER_SIZE_V2 = 0x19f
    LE_READ_ISO_TX_SYNC = 0x1a0
    LE_SET_CIG_PARAMETERS = 0x1a1
    LE_SET_CIG_PARAMETERS_TEST = 0x1a4
    LE_CREATE_CIS = 0x1a5
    LE_REMOVE_CIG = 0x1a6
    LE_ACCEPT_CIS_REQUEST = 0x1a7
    LE_REJECT_CIS_REQUEST = 0x1a8
    LE_CREATE_BIG = 0x1a9
    LE_CREATE_BIG_TEST = 0x1aa
    LE_TERMINATE_BIG = 0x1ab
    LE_BIG_CREATE_SYNC = 0x1ae
    LE_BIG_TERMINATE_SYNC = 0x1af
    LE_REQUEST_PEER_SCA = 0x1b0
    LE_SETUP_ISO_DATA_PATH = 0x1b1
    LE_REMOVE_ISO_DATA_PATH = 0x1b2
    LE_ISO_TRANSMIT_TEST = 0x1b3
    LE_ISO_RECEIVE_TEST = 0x1b4
    LE_ISO_READ_TEST_COUNTERS = 0x1b5
    LE_ISO_TEST_END = 0x1b8
    LE_SET_HOST_FEATURE_V1 = 0x1b9
    LE_READ_ISO_LINK_QUALITY = 0x1ba
    LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL = 0x1bb
    LE_READ_REMOTE_TRANSMIT_POWER_LEVEL = 0x1bc
    LE_SET_PATH_LOSS_REPORTING_PARAMETERS = 0x1bd
    LE_SET_PATH_LOSS_REPORTING_ENABLE = 0x1be
    LE_SET_TRANSMIT_POWER_REPORTING_ENABLE = 0x1bf
    LE_TRANSMITTER_TEST_V4 = 0x1c2
    SET_ECOSYSTEM_BASE_INTERVAL = 0x1c3
    READ_LOCAL_SUPPORTED_CODECS_V2 = 0x1c4
    READ_LOCAL_SUPPORTED_CODEC_CAPABILITIES = 0x1c5
    READ_LOCAL_SUPPORTED_CONTROLLER_DELAY = 0x1c6
    CONFIGURE_DATA_PATH = 0x1c7
    LE_SET_DATA_RELATED_ADDRESS_CHANGES = 0x1c8
    SET_MIN_ENCRYPTION_KEY_SIZE = 0x1c9
    LE_SET_DEFAULT_SUBRATE = 0x1cc
    LE_SUBRATE_REQUEST = 0x1cd
    LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2 = 0x1ce
    LE_SET_DECISION_DATA = 0x1cf
    LE_SET_DECISION_INSTRUCTIONS = 0x1d0
    LE_SET_PERIODIC_ADVERTISING_SUBEVENT_DATA = 0x1d1
    LE_SET_PERIODIC_ADVERTISING_RESPONSE_DATA = 0x1d2
    LE_SET_PERIODIC_SYNC_SUBEVENT = 0x1d3
    LE_EXTENDED_CREATE_CONNECTION_V2 = 0x1d6
    LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2 = 0x1d7
    LE_READ_ALL_LOCAL_SUPPORTED_FEATURES = 0x1d8
    LE_READ_ALL_REMOTE_FEATURES = 0x1d9
    LE_SET_HOST_FEATURE_V2 = 0x1da
    LE_ADD_DEVICE_TO_MONITORED_ADVERTISERS_LIST = 0x1db
    LE_REMOVE_DEVICE_FROM_MONITORED_ADVERTISERS_LIST = 0x1dc
    LE_CLEAR_MONITORED_ADVERTISERS_LIST = 0x1dd
    LE_READ_MONITORED_ADVERTISERS_LIST_SIZE = 0x1e0
    LE_FRAME_SPACE_UPDATE = 0x1e1

@dataclass
class Command(Packet):
    op_code: OpCode = field(kw_only=True, default=OpCode.NONE)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['Command', bytes]:
        fields = {'payload': None}
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['op_code'] = OpCode(value_)
        _payload__size = span[2]
        span = span[3:]
        if len(span) < _payload__size:
            raise Exception('Invalid packet size')
        payload = span[:_payload__size]
        span = span[_payload__size:]
        fields['payload'] = payload
        try:
            return Inquiry.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return InquiryCancel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PeriodicInquiryMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ExitPeriodicInquiryMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CreateConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return Disconnect.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AddScoConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CreateConnectionCancel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AcceptConnectionRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RejectConnectionRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LinkKeyRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LinkKeyRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PinCodeRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PinCodeRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ChangeConnectionPacketType.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AuthenticationRequested.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetConnectionEncryption.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ChangeConnectionLinkKey.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CentralLinkKey.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteNameRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteNameRequestCancel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteSupportedFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteExtendedFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteVersionInformation.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadClockOffset.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLmpHandle.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetupSynchronousConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AcceptSynchronousConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RejectSynchronousConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return IoCapabilityRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserConfirmationRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserConfirmationRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserPasskeyRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserPasskeyRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteOobDataRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteOobDataRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return IoCapabilityRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnhancedSetupSynchronousConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnhancedAcceptSynchronousConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteOobExtendedDataRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return HoldMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SniffMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ExitSniffMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return QosSetup.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RoleDiscovery.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SwitchRole.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLinkPolicySettings.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLinkPolicySettings.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadDefaultLinkPolicySettings.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteDefaultLinkPolicySettings.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return FlowSpecification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SniffSubrating.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventMask.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return Reset.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilter.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return Flush.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPinType.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePinType.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadStoredLinkKey.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteStoredLinkKey.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return DeleteStoredLinkKey.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLocalName.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalName.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadConnectionAcceptTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteConnectionAcceptTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPageTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePageTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadScanEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteScanEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPageScanActivity.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePageScanActivity.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryScanActivity.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryScanActivity.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAuthenticationEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteAuthenticationEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadClassOfDevice.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteClassOfDevice.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadVoiceSetting.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteVoiceSetting.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAutomaticFlushTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteAutomaticFlushTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadNumBroadcastRetransmits.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteNumBroadcastRetransmits.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadHoldModeActivity.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteHoldModeActivity.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadTransmitPowerLevel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadSynchronousFlowControlEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSynchronousFlowControlEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetControllerToHostFlowControl.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return HostBufferSize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return HostNumCompletedPackets.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLinkSupervisionTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLinkSupervisionTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadNumberOfSupportedIac.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadCurrentIacLap.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteCurrentIacLap.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetAfhHostChannelClassification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryScanType.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryScanType.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPageScanType.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePageScanType.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAfhChannelAssessmentMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteAfhChannelAssessmentMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadExtendedInquiryResponse.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteExtendedInquiryResponse.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RefreshEncryptionKey.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadSimplePairingMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSimplePairingMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalOobData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryResponseTransmitPowerLevel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryTransmitPowerLevel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SendKeypressNotification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventMaskPage2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadEnhancedTransmitPowerLevel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLeHostSupport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLeHostSupport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadSecureConnectionsHostSupport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSecureConnectionsHostSupport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalOobExtendedData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEcosystemBaseInterval.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ConfigureDataPath.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetMinEncryptionKeySize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalVersionInformation.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCommands.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalExtendedFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadBufferSize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadBdAddr.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadDataBlockSize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCodecsV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCodecsV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCodecCapabilities.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedControllerDelay.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadFailedContactCounter.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ResetFailedContactCounter.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLinkQuality.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRssi.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAfhChannelMap.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadClock.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadEncryptionKeySize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLoopbackMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLoopbackMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnableImplementationUnderTestMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSimplePairingDebugMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSecureConnectionsTestMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetEventMask.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadBufferSizeV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadLocalSupportedFeaturesPage0.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadAllLocalSupportedFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetRandomAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadAdvertisingPhysicalChannelTxPower.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetScanResponseData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetScanParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetScanEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateConnection.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateConnectionCancel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadFilterAcceptListSize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearFilterAcceptList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAddDeviceToFilterAcceptList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveDeviceFromFilterAcceptList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeConnectionUpdate.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetHostChannelClassification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadChannelMap.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadRemoteFeaturesPage0.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadAllRemoteFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEncrypt.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRand.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeStartEncryption.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeLongTermKeyRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeLongTermKeyRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadSupportedStates.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReceiverTest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTransmitterTest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTestEnd.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoteConnectionParameterRequestReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoteConnectionParameterRequestNegativeReply.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDataLength.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadSuggestedDefaultDataLength.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeWriteSuggestedDefaultDataLength.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadLocalP256PublicKey.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGenerateDhkeyV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAddDeviceToResolvingList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveDeviceFromResolvingList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearResolvingList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadResolvingListSize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadPeerResolvableAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadLocalResolvableAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAddressResolutionEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetResolvablePrivateAddressTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadMaximumDataLength.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadPhy.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDefaultPhy.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPhy.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedReceiverTest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedTransmitterTest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingSetRandomAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingParametersV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingParametersV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedScanResponseData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingEnableDisableAll.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingDisable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadMaximumAdvertisingDataLength.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadNumberOfSupportedAdvertisingSets.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveAdvertisingSet.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearAdvertisingSets.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingParametersV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingParametersV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedScanParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedScanEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeExtendedCreateConnectionV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeExtendedCreateConnectionV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingCreateSync.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingCreateSyncCancel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingTerminateSync.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAddDeviceToPeriodicAdvertiserList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveDeviceFromPeriodicAdvertiserList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearPeriodicAdvertiserList.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadPeriodicAdvertiserListSize.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadTransmitPower.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadRfPathCompensationPower.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeWriteRfPathCompensationPower.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPrivacyMode.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingReceiveEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSyncTransfer.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSetInfoTransfer.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingSyncTransferParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDefaultPeriodicAdvertisingSyncTransferParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGenerateDhkeyCommand.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeModifySleepClockAccuracy.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadBufferSizeV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadIsoTxSync.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetCigParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetCigParametersTest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateCis.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveCig.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAcceptCisRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRejectCisRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateBig.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTerminateBig.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBigCreateSync.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBigTerminateSync.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRequestPeerSca.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetupIsoDataPath.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveIsoDataPath.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetHostFeatureV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadIsoLinkQuality.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedReadTransmitPowerLevel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadRemoteTransmitPowerLevel.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPathLossReportingParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPathLossReportingEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetTransmitPowerReportingEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDataRelatedAddressChanges.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDefaultSubrate.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSubrateRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadLocalSupportedCapabilities.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadRemoteSupportedCapabilities.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsWriteCachedRemoteSupportedCapabilities.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSecurityEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSetDefaultSettings.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadRemoteFaeTable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsWriteCachedRemoteFaeTable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsCreateConfig.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsRemoveConfig.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSetChannelClassification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSetProcedureParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsProcedureEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsTest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsTestEnd.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnhancedFlush.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGetVendorCapabilities.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScan.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcf.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGetControllerActivityEnergyInfo.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeExSetScanParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return GetControllerDebugInfo.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftCommand.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return Command(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(int.to_bytes((self.op_code << 0), length=2, byteorder='little'))
        _payload_size = len(payload or self.payload or [])
        if _payload_size > 255:
            print(f"Invalid length for payload field:  {_payload_size} > 255; the packet cannot be generated")
            raise Exception("Invalid payload length")
        _span.append((_payload_size << 0))
        _span.extend(payload or self.payload or [])
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.payload) + 3

class EventCode(enum.IntEnum):
    INQUIRY_COMPLETE = 0x1
    INQUIRY_RESULT = 0x2
    CONNECTION_COMPLETE = 0x3
    CONNECTION_REQUEST = 0x4
    DISCONNECTION_COMPLETE = 0x5
    AUTHENTICATION_COMPLETE = 0x6
    REMOTE_NAME_REQUEST_COMPLETE = 0x7
    ENCRYPTION_CHANGE = 0x8
    CHANGE_CONNECTION_LINK_KEY_COMPLETE = 0x9
    CENTRAL_LINK_KEY_COMPLETE = 0xa
    READ_REMOTE_SUPPORTED_FEATURES_COMPLETE = 0xb
    READ_REMOTE_VERSION_INFORMATION_COMPLETE = 0xc
    QOS_SETUP_COMPLETE = 0xd
    COMMAND_COMPLETE = 0xe
    COMMAND_STATUS = 0xf
    HARDWARE_ERROR = 0x10
    FLUSH_OCCURRED = 0x11
    ROLE_CHANGE = 0x12
    NUMBER_OF_COMPLETED_PACKETS = 0x13
    MODE_CHANGE = 0x14
    RETURN_LINK_KEYS = 0x15
    PIN_CODE_REQUEST = 0x16
    LINK_KEY_REQUEST = 0x17
    LINK_KEY_NOTIFICATION = 0x18
    LOOPBACK_COMMAND = 0x19
    DATA_BUFFER_OVERFLOW = 0x1a
    MAX_SLOTS_CHANGE = 0x1b
    READ_CLOCK_OFFSET_COMPLETE = 0x1c
    CONNECTION_PACKET_TYPE_CHANGED = 0x1d
    QOS_VIOLATION = 0x1e
    PAGE_SCAN_REPETITION_MODE_CHANGE = 0x20
    FLOW_SPECIFICATION_COMPLETE = 0x21
    INQUIRY_RESULT_WITH_RSSI = 0x22
    READ_REMOTE_EXTENDED_FEATURES_COMPLETE = 0x23
    SYNCHRONOUS_CONNECTION_COMPLETE = 0x2c
    SYNCHRONOUS_CONNECTION_CHANGED = 0x2d
    SNIFF_SUBRATING = 0x2e
    EXTENDED_INQUIRY_RESULT = 0x2f
    ENCRYPTION_KEY_REFRESH_COMPLETE = 0x30
    IO_CAPABILITY_REQUEST = 0x31
    IO_CAPABILITY_RESPONSE = 0x32
    USER_CONFIRMATION_REQUEST = 0x33
    USER_PASSKEY_REQUEST = 0x34
    REMOTE_OOB_DATA_REQUEST = 0x35
    SIMPLE_PAIRING_COMPLETE = 0x36
    LINK_SUPERVISION_TIMEOUT_CHANGED = 0x38
    ENHANCED_FLUSH_COMPLETE = 0x39
    USER_PASSKEY_NOTIFICATION = 0x3b
    KEYPRESS_NOTIFICATION = 0x3c
    REMOTE_HOST_SUPPORTED_FEATURES_NOTIFICATION = 0x3d
    LE_META_EVENT = 0x3e
    NUMBER_OF_COMPLETED_DATA_BLOCKS = 0x48
    AUTHENTICATED_PAYLOAD_TIMEOUT_EXPIRED = 0x57
    ENCRYPTION_CHANGE_V2 = 0x59
    VENDOR_SPECIFIC = 0xff

class SubeventCode(enum.IntEnum):
    LE_CONNECTION_COMPLETE = 0x1
    LE_ADVERTISING_REPORT = 0x2
    LE_CONNECTION_UPDATE_COMPLETE = 0x3
    LE_READ_REMOTE_FEATURES_PAGE_0_COMPLETE = 0x4
    LE_LONG_TERM_KEY_REQUEST = 0x5
    LE_REMOTE_CONNECTION_PARAMETER_REQUEST = 0x6
    LE_DATA_LENGTH_CHANGE = 0x7
    LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE = 0x8
    LE_GENERATE_DHKEY_COMPLETE = 0x9
    LE_ENHANCED_CONNECTION_COMPLETE_V1 = 0xa
    LE_DIRECTED_ADVERTISING_REPORT = 0xb
    LE_PHY_UPDATE_COMPLETE = 0xc
    LE_EXTENDED_ADVERTISING_REPORT = 0xd
    LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_V1 = 0xe
    LE_PERIODIC_ADVERTISING_REPORT_V1 = 0xf
    LE_PERIODIC_ADVERTISING_SYNC_LOST = 0x10
    LE_SCAN_TIMEOUT = 0x11
    LE_ADVERTISING_SET_TERMINATED = 0x12
    LE_SCAN_REQUEST_RECEIVED = 0x13
    LE_CHANNEL_SELECTION_ALGORITHM = 0x14
    LE_CONNECTIONLESS_IQ_REPORT = 0x15
    LE_CONNECTION_IQ_REPORT = 0x16
    LE_CTE_REQUEST_FAILED = 0x17
    LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_V1 = 0x18
    LE_CIS_ESTABLISHED_V1 = 0x19
    LE_CIS_REQUEST = 0x1a
    LE_CREATE_BIG_COMPLETE = 0x1b
    LE_TERMINATE_BIG_COMPLETE = 0x1c
    LE_BIG_SYNC_ESTABLISHED = 0x1d
    LE_BIG_SYNC_LOST = 0x1e
    LE_REQUEST_PEER_SCA_COMPLETE = 0x1f
    LE_PATH_LOSS_THRESHOLD = 0x20
    LE_TRANSMIT_POWER_REPORTING = 0x21
    LE_BIG_INFO_ADVERTISING_REPORT = 0x22
    LE_SUBRATE_CHANGE = 0x23
    LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_V2 = 0x24
    LE_PERIODIC_ADVERTISING_REPORT_V2 = 0x25
    LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_V2 = 0x26
    LE_PERIODIC_ADVERTISING_SUBEVENT_DATA_REQUEST = 0x27
    LE_PERIODIC_ADVERTISING_RESPONSE_REPORT = 0x28
    LE_ENHANCED_CONNECTION_COMPLETE_V2 = 0x29
    LE_CIS_ESTABLISHED_V2 = 0x2a
    LE_READ_ALL_REMOTE_FEATURES_COMPLETE = 0x2b
    LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMPLETE = 0x2c
    LE_CS_READ_REMOTE_FAE_TABLE_COMPLETE = 0x2d
    LE_CS_SECURITY_ENABLE_COMPLETE = 0x2e
    LE_CS_CONFIG_COMPLETE = 0x2f
    LE_CS_PROCEDURE_ENABLE_COMPLETE = 0x30
    LE_CS_SUBEVENT_RESULT = 0x31
    LE_CS_SUBEVENT_RESULT_CONTINUE = 0x32
    LE_CS_TEST_END_COMPLETE = 0x33
    LE_MONITORED_ADVERTISERS_REPORT = 0x34
    LE_FRAME_SPACE_UPDATE_COMPLETE = 0x35

class VseSubeventCode(enum.IntEnum):
    STORAGE_THRESHOLD_BREACH = 0x54
    LE_MULTI_ADVERTISING_STATE_CHANGE = 0x55
    LE_ADVERTISEMENT_TRACKING = 0x56
    CONTROLLER_DEBUG_INFO = 0x57
    BLUETOOTH_QUALITY_REPORT = 0x58

@dataclass
class Event(Packet):
    event_code: EventCode = field(kw_only=True, default=EventCode.INQUIRY_COMPLETE)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['Event', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['event_code'] = EventCode(span[0])
        _payload__size = span[1]
        span = span[2:]
        if len(span) < _payload__size:
            raise Exception('Invalid packet size')
        payload = span[:_payload__size]
        span = span[_payload__size:]
        fields['payload'] = payload
        try:
            return LeMetaEvent.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CommandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CommandStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return VendorSpecificEvent.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return InquiryComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return InquiryResult.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ConnectionComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ConnectionRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return DisconnectionComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AuthenticationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteNameRequestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EncryptionChange.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EncryptionChangeV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ChangeConnectionLinkKeyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CentralLinkKeyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteSupportedFeaturesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteVersionInformationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return QosSetupComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return HardwareError.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return FlushOccurred.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RoleChange.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return NumberOfCompletedPackets.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ModeChange.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReturnLinkKeys.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PinCodeRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LinkKeyRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LinkKeyNotification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return DataBufferOverflow.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MaxSlotsChange.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadClockOffsetComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ConnectionPacketTypeChanged.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return QosViolation.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PageScanRepetitionModeChange.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return FlowSpecificationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return InquiryResultWithRssi.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteExtendedFeaturesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SynchronousConnectionComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SynchronousConnectionChanged.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SniffSubratingEvent.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ExtendedInquiryResult.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EncryptionKeyRefreshComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return IoCapabilityRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return IoCapabilityResponse.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserConfirmationRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserPasskeyRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteOobDataRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SimplePairingComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LinkSupervisionTimeoutChanged.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnhancedFlushComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserPasskeyNotification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return KeypressNotification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteHostSupportedFeaturesNotification.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return NumberOfCompletedDataBlocks.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AuthenticatedPayloadTimeoutExpired.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return Event(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.event_code << 0))
        _payload_size = len(payload or self.payload or [])
        if _payload_size > 255:
            print(f"Invalid length for payload field:  {_payload_size} > 255; the packet cannot be generated")
            raise Exception("Invalid payload length")
        _span.append((_payload_size << 0))
        _span.extend(payload or self.payload or [])
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.payload) + 2

@dataclass
class LeMetaEvent(Event):
    subevent_code: SubeventCode = field(kw_only=True, default=SubeventCode.LE_CONNECTION_COMPLETE)

    def __post_init__(self):
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeMetaEvent', bytes]:
        if fields['event_code'] != EventCode.LE_META_EVENT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['subevent_code'] = SubeventCode(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeReadRemoteFeaturesPage0Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadAllRemoteFeaturesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadRemoteSupportedCapabilitiesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSecurityEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadRemoteFaeTableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsConfigComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsProcedureEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsTestEndComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeConnectionComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAdvertisingReport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeConnectionUpdateComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeLongTermKeyRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoteConnectionParameterRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeDataLengthChange.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadLocalP256PublicKeyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGenerateDhKeyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedConnectionCompleteV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedConnectionCompleteV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeDirectedAdvertisingReport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePhyUpdateComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeExtendedAdvertisingReport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSyncEstablishedV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSyncEstablishedV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingReportV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingReportV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSyncLost.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeScanTimeout.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAdvertisingSetTerminated.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeScanRequestReceived.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeChannelSelectionAlgorithm.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSyncTransferReceivedV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSyncTransferReceivedV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCisEstablishedV1.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCisEstablishedV2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCisRequest.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateBigComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTerminateBigComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBigSyncEstablished.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBigSyncLost.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRequestPeerScaComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePathLossThreshold.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTransmitPowerReporting.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBigInfoAdvertisingReport.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSubrateChange.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeMetaEvent(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.subevent_code << 0))
        _span.extend(payload or self.payload or [])
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

class FeatureFlag(enum.IntEnum):
    UNSUPPORTED = 0x0
    SUPPORTED = 0x1

class ErrorCode(enum.IntEnum):
    STATUS_UNKNOWN = 0xff
    SUCCESS = 0x0
    UNKNOWN_HCI_COMMAND = 0x1
    UNKNOWN_CONNECTION = 0x2
    HARDWARE_FAILURE = 0x3
    PAGE_TIMEOUT = 0x4
    AUTHENTICATION_FAILURE = 0x5
    PIN_OR_KEY_MISSING = 0x6
    MEMORY_CAPACITY_EXCEEDED = 0x7
    CONNECTION_TIMEOUT = 0x8
    CONNECTION_LIMIT_EXCEEDED = 0x9
    SYNCHRONOUS_CONNECTION_LIMIT_EXCEEDED = 0xa
    CONNECTION_ALREADY_EXISTS = 0xb
    COMMAND_DISALLOWED = 0xc
    CONNECTION_REJECTED_LIMITED_RESOURCES = 0xd
    CONNECTION_REJECTED_SECURITY_REASONS = 0xe
    CONNECTION_REJECTED_UNACCEPTABLE_BD_ADDR = 0xf
    CONNECTION_ACCEPT_TIMEOUT = 0x10
    UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE = 0x11
    INVALID_HCI_COMMAND_PARAMETERS = 0x12
    REMOTE_USER_TERMINATED_CONNECTION = 0x13
    REMOTE_DEVICE_TERMINATED_CONNECTION_LOW_RESOURCES = 0x14
    REMOTE_DEVICE_TERMINATED_CONNECTION_POWER_OFF = 0x15
    CONNECTION_TERMINATED_BY_LOCAL_HOST = 0x16
    REPEATED_ATTEMPTS = 0x17
    PAIRING_NOT_ALLOWED = 0x18
    UNKNOWN_LMP_PDU = 0x19
    UNSUPPORTED_REMOTE_OR_LMP_FEATURE = 0x1a
    SCO_OFFSET_REJECTED = 0x1b
    SCO_INTERVAL_REJECTED = 0x1c
    SCO_AIR_MODE_REJECTED = 0x1d
    INVALID_LMP_OR_LL_PARAMETERS = 0x1e
    UNSPECIFIED_ERROR = 0x1f
    UNSUPPORTED_LMP_OR_LL_PARAMETER = 0x20
    ROLE_CHANGE_NOT_ALLOWED = 0x21
    TRANSACTION_RESPONSE_TIMEOUT = 0x22
    LINK_LAYER_COLLISION = 0x23
    ENCRYPTION_MODE_NOT_ACCEPTABLE = 0x25
    ROLE_SWITCH_FAILED = 0x35
    HOST_BUSY = 0x38
    CONTROLLER_BUSY = 0x3a
    ADVERTISING_TIMEOUT = 0x3c
    CONNECTION_FAILED_ESTABLISHMENT = 0x3e
    UNKNOWN_ADVERTISING_IDENTIFIER = 0x42
    LIMIT_REACHED = 0x43
    OPERATION_CANCELLED_BY_HOST = 0x44
    PACKET_TOO_LONG = 0x45

@dataclass
class CommandComplete(Event):
    num_hci_command_packets: int = field(kw_only=True, default=0)
    command_op_code: OpCode = field(kw_only=True, default=OpCode.NONE)

    def __post_init__(self):
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CommandComplete', bytes]:
        if fields['event_code'] != EventCode.COMMAND_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['num_hci_command_packets'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['command_op_code'] = OpCode(value_)
        span = span[3:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return NoCommandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return InquiryCancelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PeriodicInquiryModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ExitPeriodicInquiryModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CreateConnectionCancelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LinkKeyRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LinkKeyRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PinCodeRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return PinCodeRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteNameRequestCancelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLmpHandleComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return IoCapabilityRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserConfirmationRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserConfirmationRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserPasskeyRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return UserPasskeyRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteOobDataRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteOobDataRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return IoCapabilityRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteOobExtendedDataRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RoleDiscoveryComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLinkPolicySettingsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLinkPolicySettingsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadDefaultLinkPolicySettingsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteDefaultLinkPolicySettingsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SniffSubratingComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventMaskComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ResetComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilterComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return FlushComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPinTypeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePinTypeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadStoredLinkKeyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteStoredLinkKeyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return DeleteStoredLinkKeyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLocalNameComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalNameComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadConnectionAcceptTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteConnectionAcceptTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPageTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePageTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadScanEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteScanEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPageScanActivityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePageScanActivityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryScanActivityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryScanActivityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAuthenticationEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteAuthenticationEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadClassOfDeviceComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteClassOfDeviceComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadVoiceSettingComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteVoiceSettingComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAutomaticFlushTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteAutomaticFlushTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadNumBroadcastRetransmitsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteNumBroadcastRetransmitsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadHoldModeActivityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteHoldModeActivityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadTransmitPowerLevelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadSynchronousFlowControlEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSynchronousFlowControlEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetControllerToHostFlowControlComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return HostBufferSizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return HostNumCompletedPacketsError.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLinkSupervisionTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLinkSupervisionTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadNumberOfSupportedIacComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadCurrentIacLapComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteCurrentIacLapComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetAfhHostChannelClassificationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryScanTypeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryScanTypeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadPageScanTypeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WritePageScanTypeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAfhChannelAssessmentModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteAfhChannelAssessmentModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadExtendedInquiryResponseComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteExtendedInquiryResponseComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadSimplePairingModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSimplePairingModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalOobDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadInquiryResponseTransmitPowerLevelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteInquiryResponseTransmitPowerLevelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SendKeypressNotificationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventMaskPage2Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadEnhancedTransmitPowerLevelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLeHostSupportComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLeHostSupportComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadSecureConnectionsHostSupportComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSecureConnectionsHostSupportComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalOobExtendedDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEcosystemBaseIntervalComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ConfigureDataPathComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetMinEncryptionKeySizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalVersionInformationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCommandsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedFeaturesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalExtendedFeaturesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadBufferSizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadBdAddrComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadDataBlockSizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCodecsV1Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCodecsV2Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedCodecCapabilitiesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLocalSupportedControllerDelayComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadFailedContactCounterComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ResetFailedContactCounterComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLinkQualityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRssiComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadAfhChannelMapComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadClockComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadEncryptionKeySizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadLoopbackModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteLoopbackModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnableImplementationUnderTestModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSimplePairingDebugModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return WriteSecureConnectionsTestModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetEventMaskComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadBufferSizeV1Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadLocalSupportedFeaturesPage0Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadAllLocalSupportedFeaturesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetRandomAddressComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadAdvertisingPhysicalChannelTxPowerComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetScanResponseDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetScanParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetScanEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateConnectionCancelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadFilterAcceptListSizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearFilterAcceptListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAddDeviceToFilterAcceptListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveDeviceFromFilterAcceptListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetHostChannelClassificationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadChannelMapComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEncryptComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeLongTermKeyRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeLongTermKeyRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadSupportedStatesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReceiverTestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTransmitterTestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTestEndComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoteConnectionParameterRequestReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoteConnectionParameterRequestNegativeReplyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDataLengthComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadSuggestedDefaultDataLengthComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeWriteSuggestedDefaultDataLengthComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAddDeviceToResolvingListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveDeviceFromResolvingListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearResolvingListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadResolvingListSizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadPeerResolvableAddressComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadLocalResolvableAddressComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAddressResolutionEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetResolvablePrivateAddressTimeoutComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadMaximumDataLengthComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadPhyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDefaultPhyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedReceiverTestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedTransmitterTestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetAdvertisingSetRandomAddressComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingParametersV1Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingParametersV2Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedScanResponseDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedAdvertisingEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadMaximumAdvertisingDataLengthComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadNumberOfSupportedAdvertisingSetsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveAdvertisingSetComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearAdvertisingSetsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingParametersV1Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingParametersV2Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedScanParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetExtendedScanEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingCreateSyncCancelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingTerminateSyncComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAddDeviceToPeriodicAdvertiserListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveDeviceFromPeriodicAdvertiserListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeClearPeriodicAdvertiserListComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadPeriodicAdvertiserListSizeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadTransmitPowerComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadRfPathCompensationPowerComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeWriteRfPathCompensationPowerComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPrivacyModeComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingReceiveEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSyncTransferComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingSetInfoTransferComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPeriodicAdvertisingSyncTransferParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeModifySleepClockAccuracyComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadBufferSizeV2Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadIsoTxSyncComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetCigParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetCigParametersTestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveCigComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRejectCisRequestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBigTerminateSyncComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetupIsoDataPathComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRemoveIsoDataPathComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetHostFeatureV1Complete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadIsoLinkQualityComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeEnhancedReadTransmitPowerLevelComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPathLossReportingParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPathLossReportingEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetTransmitPowerReportingEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDataRelatedAddressChangesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetDefaultSubrateComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadLocalSupportedCapabilitiesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsWriteCachedRemoteSupportedCapabilitiesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSetDefaultSettingsComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsWriteCachedRemoteFaeTableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSetChannelClassificationComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSetProcedureParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsTestComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGetVendorCapabilitiesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGetControllerActivityEnergyInfoComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeExSetScanParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return GetControllerDebugInfoComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftCommandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return CommandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.num_hci_command_packets > 255:
            print(f"Invalid value for field CommandComplete::num_hci_command_packets: {self.num_hci_command_packets} > 255; the value will be truncated")
            self.num_hci_command_packets &= 255
        _span.append((self.num_hci_command_packets << 0))
        _span.extend(int.to_bytes((self.command_op_code << 0), length=2, byteorder='little'))
        _span.extend(payload or self.payload or [])
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 3

@dataclass
class CommandStatus(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    num_hci_command_packets: int = field(kw_only=True, default=0)
    command_op_code: OpCode = field(kw_only=True, default=OpCode.NONE)

    def __post_init__(self):
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CommandStatus', bytes]:
        if fields['event_code'] != EventCode.COMMAND_STATUS:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['num_hci_command_packets'] = span[1]
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['command_op_code'] = OpCode(value_)
        span = span[4:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return InquiryStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CreateConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return DisconnectStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AddScoConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AcceptConnectionRequestStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RejectConnectionRequestStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ChangeConnectionPacketTypeStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AuthenticationRequestedStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetConnectionEncryptionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ChangeConnectionLinkKeyStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return CentralLinkKeyStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RemoteNameRequestStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteSupportedFeaturesStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteExtendedFeaturesStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadRemoteVersionInformationStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ReadClockOffsetStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetupSynchronousConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return AcceptSynchronousConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RejectSynchronousConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnhancedSetupSynchronousConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnhancedAcceptSynchronousConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return HoldModeStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SniffModeStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ExitSniffModeStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return QosSetupStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SwitchRoleStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return FlowSpecificationStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return RefreshEncryptionKeyStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateConnectionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeConnectionUpdateStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadRemoteFeaturesPage0Status.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadAllRemoteFeaturesStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeStartEncryptionStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadLocalP256PublicKeyStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGenerateDhkeyV1Status.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSetPhyStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeExtendedCreateConnectionV1Status.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeExtendedCreateConnectionV2Status.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LePeriodicAdvertisingCreateSyncStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeGenerateDhkeyCommandStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateCisStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAcceptCisRequestStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCreateBigStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeTerminateBigStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBigCreateSyncStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeRequestPeerScaStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeReadRemoteTransmitPowerLevelStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeSubrateRequestStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadRemoteSupportedCapabilitiesStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsSecurityEnableStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsReadRemoteFaeTableStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsCreateConfigStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsRemoveConfigStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsProcedureEnableStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeCsTestEndStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return EnhancedFlushStatus.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return CommandStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.num_hci_command_packets > 255:
            print(f"Invalid value for field CommandStatus::num_hci_command_packets: {self.num_hci_command_packets} > 255; the value will be truncated")
            self.num_hci_command_packets &= 255
        _span.append((self.num_hci_command_packets << 0))
        _span.extend(int.to_bytes((self.command_op_code << 0), length=2, byteorder='little'))
        _span.extend(payload or self.payload or [])
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 4

@dataclass
class VendorSpecificEvent(Event):
    subevent_code: VseSubeventCode = field(kw_only=True, default=VseSubeventCode.STORAGE_THRESHOLD_BREACH)

    def __post_init__(self):
        self.event_code = EventCode.VENDOR_SPECIFIC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['VendorSpecificEvent', bytes]:
        if fields['event_code'] != EventCode.VENDOR_SPECIFIC:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['subevent_code'] = VseSubeventCode(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return StorageThresholdBreachEvent.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeAdvertisementTrackingEvent.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return ControllerDebugInfoEvent.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return VendorSpecificEvent(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.subevent_code << 0))
        _span.extend(payload or self.payload or [])
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class NoCommandComplete(CommandComplete):
    

    def __post_init__(self):
        self.command_op_code = OpCode.NONE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['NoCommandComplete', bytes]:
        if fields['command_op_code'] != OpCode.NONE:
            raise Exception("Invalid constraint field values")
        return NoCommandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class Lap(Packet):
    lap: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['Lap', bytes]:
        fields = {'payload': None}
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['lap'] = (span[0] >> 0) & 0x3f
        value_ = int.from_bytes(span[1:3], byteorder='little')
        if value_ != 0x9e8b:
            raise Exception('Unexpected fixed field value')
        span = span[3:]
        return Lap(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.lap > 63:
            print(f"Invalid value for field Lap::lap: {self.lap} > 63; the value will be truncated")
            self.lap &= 63
        _span.append((self.lap << 0))
        _span.extend(int.to_bytes((40587 << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 3

@dataclass
class Inquiry(Command):
    lap: Lap = field(kw_only=True, default_factory=Lap)
    inquiry_length: int = field(kw_only=True, default=0)
    num_responses: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.INQUIRY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['Inquiry', bytes]:
        if fields['op_code'] != OpCode.INQUIRY:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['lap'] = Lap.parse_all(span[0:3])
        fields['inquiry_length'] = span[3]
        fields['num_responses'] = span[4]
        span = span[5:]
        return Inquiry(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.lap.serialize())
        if self.inquiry_length > 255:
            print(f"Invalid value for field Inquiry::inquiry_length: {self.inquiry_length} > 255; the value will be truncated")
            self.inquiry_length &= 255
        _span.append((self.inquiry_length << 0))
        if self.num_responses > 255:
            print(f"Invalid value for field Inquiry::num_responses: {self.num_responses} > 255; the value will be truncated")
            self.num_responses &= 255
        _span.append((self.num_responses << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class InquiryStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.INQUIRY
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['InquiryStatus', bytes]:
        if fields['command_op_code'] != OpCode.INQUIRY:
            raise Exception("Invalid constraint field values")
        return InquiryStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class InquiryCancel(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.INQUIRY_CANCEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['InquiryCancel', bytes]:
        if fields['op_code'] != OpCode.INQUIRY_CANCEL:
            raise Exception("Invalid constraint field values")
        return InquiryCancel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class InquiryCancelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.INQUIRY_CANCEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['InquiryCancelComplete', bytes]:
        if fields['command_op_code'] != OpCode.INQUIRY_CANCEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return InquiryCancelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class PeriodicInquiryMode(Command):
    max_period_length: int = field(kw_only=True, default=0)
    min_period_length: int = field(kw_only=True, default=0)
    lap: Lap = field(kw_only=True, default_factory=Lap)
    inquiry_length: int = field(kw_only=True, default=0)
    num_responses: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.PERIODIC_INQUIRY_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PeriodicInquiryMode', bytes]:
        if fields['op_code'] != OpCode.PERIODIC_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['max_period_length'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['min_period_length'] = value_
        fields['lap'] = Lap.parse_all(span[4:7])
        fields['inquiry_length'] = span[7]
        fields['num_responses'] = span[8]
        span = span[9:]
        return PeriodicInquiryMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.max_period_length > 65535:
            print(f"Invalid value for field PeriodicInquiryMode::max_period_length: {self.max_period_length} > 65535; the value will be truncated")
            self.max_period_length &= 65535
        _span.extend(int.to_bytes((self.max_period_length << 0), length=2, byteorder='little'))
        if self.min_period_length > 65535:
            print(f"Invalid value for field PeriodicInquiryMode::min_period_length: {self.min_period_length} > 65535; the value will be truncated")
            self.min_period_length &= 65535
        _span.extend(int.to_bytes((self.min_period_length << 0), length=2, byteorder='little'))
        _span.extend(self.lap.serialize())
        if self.inquiry_length > 255:
            print(f"Invalid value for field PeriodicInquiryMode::inquiry_length: {self.inquiry_length} > 255; the value will be truncated")
            self.inquiry_length &= 255
        _span.append((self.inquiry_length << 0))
        if self.num_responses > 255:
            print(f"Invalid value for field PeriodicInquiryMode::num_responses: {self.num_responses} > 255; the value will be truncated")
            self.num_responses &= 255
        _span.append((self.num_responses << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class PeriodicInquiryModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.PERIODIC_INQUIRY_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PeriodicInquiryModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.PERIODIC_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return PeriodicInquiryModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ExitPeriodicInquiryMode(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.EXIT_PERIODIC_INQUIRY_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ExitPeriodicInquiryMode', bytes]:
        if fields['op_code'] != OpCode.EXIT_PERIODIC_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        return ExitPeriodicInquiryMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ExitPeriodicInquiryModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.EXIT_PERIODIC_INQUIRY_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ExitPeriodicInquiryModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.EXIT_PERIODIC_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return ExitPeriodicInquiryModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class PageScanRepetitionMode(enum.IntEnum):
    R0 = 0x0
    R1 = 0x1
    R2 = 0x2

class ClockOffsetValid(enum.IntEnum):
    INVALID = 0x0
    VALID = 0x1

class CreateConnectionRoleSwitch(enum.IntEnum):
    REMAIN_CENTRAL = 0x0
    ALLOW_ROLE_SWITCH = 0x1

@dataclass
class CreateConnection(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    packet_type: int = field(kw_only=True, default=0)
    page_scan_repetition_mode: PageScanRepetitionMode = field(kw_only=True, default=PageScanRepetitionMode.R0)
    clock_offset: int = field(kw_only=True, default=0)
    clock_offset_valid: ClockOffsetValid = field(kw_only=True, default=ClockOffsetValid.INVALID)
    allow_role_switch: CreateConnectionRoleSwitch = field(kw_only=True, default=CreateConnectionRoleSwitch.REMAIN_CENTRAL)

    def __post_init__(self):
        self.op_code = OpCode.CREATE_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CreateConnection', bytes]:
        if fields['op_code'] != OpCode.CREATE_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 13:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['packet_type'] = value_
        fields['page_scan_repetition_mode'] = PageScanRepetitionMode(span[8])
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['clock_offset'] = (value_ >> 0) & 0x7fff
        fields['clock_offset_valid'] = ClockOffsetValid((value_ >> 15) & 0x1)
        fields['allow_role_switch'] = CreateConnectionRoleSwitch(span[12])
        span = span[13:]
        return CreateConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.packet_type > 65535:
            print(f"Invalid value for field CreateConnection::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        _span.append((self.page_scan_repetition_mode << 0))
        _span.extend([0] * 1)
        if self.clock_offset > 32767:
            print(f"Invalid value for field CreateConnection::clock_offset: {self.clock_offset} > 32767; the value will be truncated")
            self.clock_offset &= 32767
        _value = (
            (self.clock_offset << 0) |
            (self.clock_offset_valid << 15)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        _span.append((self.allow_role_switch << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 13

@dataclass
class CreateConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.CREATE_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CreateConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.CREATE_CONNECTION:
            raise Exception("Invalid constraint field values")
        return CreateConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class DisconnectReason(enum.IntEnum):
    AUTHENTICATION_FAILURE = 0x5
    REMOTE_USER_TERMINATED_CONNECTION = 0x13
    REMOTE_DEVICE_TERMINATED_CONNECTION_LOW_RESOURCES = 0x14
    REMOTE_DEVICE_TERMINATED_CONNECTION_POWER_OFF = 0x15
    UNSUPPORTED_REMOTE_FEATURE = 0x1a
    PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED = 0x29
    UNACCEPTABLE_CONNECTION_PARAMETERS = 0x3b

@dataclass
class Disconnect(Command):
    connection_handle: int = field(kw_only=True, default=0)
    reason: DisconnectReason = field(kw_only=True, default=DisconnectReason.AUTHENTICATION_FAILURE)

    def __post_init__(self):
        self.op_code = OpCode.DISCONNECT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['Disconnect', bytes]:
        if fields['op_code'] != OpCode.DISCONNECT:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['reason'] = DisconnectReason(span[2])
        span = span[3:]
        return Disconnect(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field Disconnect::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.reason << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class DisconnectStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.DISCONNECT
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['DisconnectStatus', bytes]:
        if fields['command_op_code'] != OpCode.DISCONNECT:
            raise Exception("Invalid constraint field values")
        return DisconnectStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class AddScoConnection(Command):
    connection_handle: int = field(kw_only=True, default=0)
    packet_type: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.ADD_SCO_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AddScoConnection', bytes]:
        if fields['op_code'] != OpCode.ADD_SCO_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['packet_type'] = value_
        span = span[4:]
        return AddScoConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field AddScoConnection::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.packet_type > 65535:
            print(f"Invalid value for field AddScoConnection::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class AddScoConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.ADD_SCO_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AddScoConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.ADD_SCO_CONNECTION:
            raise Exception("Invalid constraint field values")
        return AddScoConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class CreateConnectionCancel(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.CREATE_CONNECTION_CANCEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CreateConnectionCancel', bytes]:
        if fields['op_code'] != OpCode.CREATE_CONNECTION_CANCEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return CreateConnectionCancel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class CreateConnectionCancelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.CREATE_CONNECTION_CANCEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CreateConnectionCancelComplete', bytes]:
        if fields['command_op_code'] != OpCode.CREATE_CONNECTION_CANCEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return CreateConnectionCancelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

class AcceptConnectionRequestRole(enum.IntEnum):
    BECOME_CENTRAL = 0x0
    REMAIN_PERIPHERAL = 0x1

@dataclass
class AcceptConnectionRequest(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    role: AcceptConnectionRequestRole = field(kw_only=True, default=AcceptConnectionRequestRole.BECOME_CENTRAL)

    def __post_init__(self):
        self.op_code = OpCode.ACCEPT_CONNECTION_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AcceptConnectionRequest', bytes]:
        if fields['op_code'] != OpCode.ACCEPT_CONNECTION_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['role'] = AcceptConnectionRequestRole(span[6])
        span = span[7:]
        return AcceptConnectionRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.role << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class AcceptConnectionRequestStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.ACCEPT_CONNECTION_REQUEST
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AcceptConnectionRequestStatus', bytes]:
        if fields['command_op_code'] != OpCode.ACCEPT_CONNECTION_REQUEST:
            raise Exception("Invalid constraint field values")
        return AcceptConnectionRequestStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class RejectConnectionReason(enum.IntEnum):
    LIMITED_RESOURCES = 0xd
    SECURITY_REASONS = 0xe
    UNACCEPTABLE_BD_ADDR = 0xf

@dataclass
class RejectConnectionRequest(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    reason: RejectConnectionReason = field(kw_only=True, default=RejectConnectionReason.LIMITED_RESOURCES)

    def __post_init__(self):
        self.op_code = OpCode.REJECT_CONNECTION_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RejectConnectionRequest', bytes]:
        if fields['op_code'] != OpCode.REJECT_CONNECTION_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['reason'] = RejectConnectionReason(span[6])
        span = span[7:]
        return RejectConnectionRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.reason << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class RejectConnectionRequestStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.REJECT_CONNECTION_REQUEST
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RejectConnectionRequestStatus', bytes]:
        if fields['command_op_code'] != OpCode.REJECT_CONNECTION_REQUEST:
            raise Exception("Invalid constraint field values")
        return RejectConnectionRequestStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LinkKeyRequestReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    link_key: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LINK_KEY_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LinkKeyRequestReply', bytes]:
        if fields['op_code'] != OpCode.LINK_KEY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['link_key'] = list(span[:16])
        span = span[16:]
        return LinkKeyRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.extend(self.link_key)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 22

@dataclass
class LinkKeyRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.LINK_KEY_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LinkKeyRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LINK_KEY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LinkKeyRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LinkKeyRequestNegativeReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LINK_KEY_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LinkKeyRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.LINK_KEY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return LinkKeyRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LinkKeyRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.LINK_KEY_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LinkKeyRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LINK_KEY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LinkKeyRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class PinCodeRequestReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    pin_code_length: int = field(kw_only=True, default=0)
    pin_code: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.PIN_CODE_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PinCodeRequestReply', bytes]:
        if fields['op_code'] != OpCode.PIN_CODE_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['pin_code_length'] = (span[6] >> 0) & 0x1f
        span = span[7:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['pin_code'] = list(span[:16])
        span = span[16:]
        return PinCodeRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.pin_code_length > 31:
            print(f"Invalid value for field PinCodeRequestReply::pin_code_length: {self.pin_code_length} > 31; the value will be truncated")
            self.pin_code_length &= 31
        _span.append((self.pin_code_length << 0))
        _span.extend(self.pin_code)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 23

@dataclass
class PinCodeRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.PIN_CODE_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PinCodeRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.PIN_CODE_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return PinCodeRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class PinCodeRequestNegativeReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.PIN_CODE_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PinCodeRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.PIN_CODE_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return PinCodeRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class PinCodeRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.PIN_CODE_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PinCodeRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.PIN_CODE_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return PinCodeRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class ChangeConnectionPacketType(Command):
    connection_handle: int = field(kw_only=True, default=0)
    packet_type: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.CHANGE_CONNECTION_PACKET_TYPE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ChangeConnectionPacketType', bytes]:
        if fields['op_code'] != OpCode.CHANGE_CONNECTION_PACKET_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['packet_type'] = value_
        span = span[4:]
        return ChangeConnectionPacketType(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ChangeConnectionPacketType::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.packet_type > 65535:
            print(f"Invalid value for field ChangeConnectionPacketType::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class ChangeConnectionPacketTypeStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.CHANGE_CONNECTION_PACKET_TYPE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ChangeConnectionPacketTypeStatus', bytes]:
        if fields['command_op_code'] != OpCode.CHANGE_CONNECTION_PACKET_TYPE:
            raise Exception("Invalid constraint field values")
        return ChangeConnectionPacketTypeStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class AuthenticationRequested(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.AUTHENTICATION_REQUESTED

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AuthenticationRequested', bytes]:
        if fields['op_code'] != OpCode.AUTHENTICATION_REQUESTED:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return AuthenticationRequested(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field AuthenticationRequested::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class AuthenticationRequestedStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.AUTHENTICATION_REQUESTED
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AuthenticationRequestedStatus', bytes]:
        if fields['command_op_code'] != OpCode.AUTHENTICATION_REQUESTED:
            raise Exception("Invalid constraint field values")
        return AuthenticationRequestedStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class SetConnectionEncryption(Command):
    connection_handle: int = field(kw_only=True, default=0)
    encryption_enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.SET_CONNECTION_ENCRYPTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetConnectionEncryption', bytes]:
        if fields['op_code'] != OpCode.SET_CONNECTION_ENCRYPTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['encryption_enable'] = Enable(span[2])
        span = span[3:]
        return SetConnectionEncryption(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field SetConnectionEncryption::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.encryption_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class SetConnectionEncryptionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.SET_CONNECTION_ENCRYPTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetConnectionEncryptionStatus', bytes]:
        if fields['command_op_code'] != OpCode.SET_CONNECTION_ENCRYPTION:
            raise Exception("Invalid constraint field values")
        return SetConnectionEncryptionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ChangeConnectionLinkKey(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.CHANGE_CONNECTION_LINK_KEY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ChangeConnectionLinkKey', bytes]:
        if fields['op_code'] != OpCode.CHANGE_CONNECTION_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ChangeConnectionLinkKey(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ChangeConnectionLinkKey::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ChangeConnectionLinkKeyStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.CHANGE_CONNECTION_LINK_KEY
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ChangeConnectionLinkKeyStatus', bytes]:
        if fields['command_op_code'] != OpCode.CHANGE_CONNECTION_LINK_KEY:
            raise Exception("Invalid constraint field values")
        return ChangeConnectionLinkKeyStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class KeyFlag(enum.IntEnum):
    SEMI_PERMANENT = 0x0
    TEMPORARY = 0x1

@dataclass
class CentralLinkKey(Command):
    key_flag: KeyFlag = field(kw_only=True, default=KeyFlag.SEMI_PERMANENT)

    def __post_init__(self):
        self.op_code = OpCode.CENTRAL_LINK_KEY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CentralLinkKey', bytes]:
        if fields['op_code'] != OpCode.CENTRAL_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['key_flag'] = KeyFlag(span[0])
        span = span[1:]
        return CentralLinkKey(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.key_flag << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class CentralLinkKeyStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.CENTRAL_LINK_KEY
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CentralLinkKeyStatus', bytes]:
        if fields['command_op_code'] != OpCode.CENTRAL_LINK_KEY:
            raise Exception("Invalid constraint field values")
        return CentralLinkKeyStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class RemoteNameRequest(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    page_scan_repetition_mode: PageScanRepetitionMode = field(kw_only=True, default=PageScanRepetitionMode.R0)
    clock_offset: int = field(kw_only=True, default=0)
    clock_offset_valid: ClockOffsetValid = field(kw_only=True, default=ClockOffsetValid.INVALID)

    def __post_init__(self):
        self.op_code = OpCode.REMOTE_NAME_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteNameRequest', bytes]:
        if fields['op_code'] != OpCode.REMOTE_NAME_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['page_scan_repetition_mode'] = PageScanRepetitionMode(span[6])
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['clock_offset'] = (value_ >> 0) & 0x7fff
        fields['clock_offset_valid'] = ClockOffsetValid((value_ >> 15) & 0x1)
        span = span[10:]
        return RemoteNameRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.page_scan_repetition_mode << 0))
        _span.extend([0] * 1)
        if self.clock_offset > 32767:
            print(f"Invalid value for field RemoteNameRequest::clock_offset: {self.clock_offset} > 32767; the value will be truncated")
            self.clock_offset &= 32767
        _value = (
            (self.clock_offset << 0) |
            (self.clock_offset_valid << 15)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class RemoteNameRequestStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.REMOTE_NAME_REQUEST
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteNameRequestStatus', bytes]:
        if fields['command_op_code'] != OpCode.REMOTE_NAME_REQUEST:
            raise Exception("Invalid constraint field values")
        return RemoteNameRequestStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class RemoteNameRequestCancel(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.REMOTE_NAME_REQUEST_CANCEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteNameRequestCancel', bytes]:
        if fields['op_code'] != OpCode.REMOTE_NAME_REQUEST_CANCEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return RemoteNameRequestCancel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class RemoteNameRequestCancelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.REMOTE_NAME_REQUEST_CANCEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteNameRequestCancelComplete', bytes]:
        if fields['command_op_code'] != OpCode.REMOTE_NAME_REQUEST_CANCEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return RemoteNameRequestCancelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class ReadRemoteSupportedFeatures(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_REMOTE_SUPPORTED_FEATURES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteSupportedFeatures', bytes]:
        if fields['op_code'] != OpCode.READ_REMOTE_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadRemoteSupportedFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRemoteSupportedFeatures::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadRemoteSupportedFeaturesStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.READ_REMOTE_SUPPORTED_FEATURES
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteSupportedFeaturesStatus', bytes]:
        if fields['command_op_code'] != OpCode.READ_REMOTE_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        return ReadRemoteSupportedFeaturesStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadRemoteExtendedFeatures(Command):
    connection_handle: int = field(kw_only=True, default=0)
    page_number: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_REMOTE_EXTENDED_FEATURES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteExtendedFeatures', bytes]:
        if fields['op_code'] != OpCode.READ_REMOTE_EXTENDED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['page_number'] = span[2]
        span = span[3:]
        return ReadRemoteExtendedFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRemoteExtendedFeatures::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.page_number > 255:
            print(f"Invalid value for field ReadRemoteExtendedFeatures::page_number: {self.page_number} > 255; the value will be truncated")
            self.page_number &= 255
        _span.append((self.page_number << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadRemoteExtendedFeaturesStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.READ_REMOTE_EXTENDED_FEATURES
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteExtendedFeaturesStatus', bytes]:
        if fields['command_op_code'] != OpCode.READ_REMOTE_EXTENDED_FEATURES:
            raise Exception("Invalid constraint field values")
        return ReadRemoteExtendedFeaturesStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadRemoteVersionInformation(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_REMOTE_VERSION_INFORMATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteVersionInformation', bytes]:
        if fields['op_code'] != OpCode.READ_REMOTE_VERSION_INFORMATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadRemoteVersionInformation(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRemoteVersionInformation::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadRemoteVersionInformationStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.READ_REMOTE_VERSION_INFORMATION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteVersionInformationStatus', bytes]:
        if fields['command_op_code'] != OpCode.READ_REMOTE_VERSION_INFORMATION:
            raise Exception("Invalid constraint field values")
        return ReadRemoteVersionInformationStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadClockOffset(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_CLOCK_OFFSET

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadClockOffset', bytes]:
        if fields['op_code'] != OpCode.READ_CLOCK_OFFSET:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadClockOffset(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadClockOffset::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadClockOffsetStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.READ_CLOCK_OFFSET
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadClockOffsetStatus', bytes]:
        if fields['command_op_code'] != OpCode.READ_CLOCK_OFFSET:
            raise Exception("Invalid constraint field values")
        return ReadClockOffsetStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLmpHandle(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_LMP_HANDLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLmpHandle', bytes]:
        if fields['op_code'] != OpCode.READ_LMP_HANDLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadLmpHandle(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLmpHandle::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadLmpHandleComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    lmp_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LMP_HANDLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLmpHandleComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LMP_HANDLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['lmp_handle'] = span[3]
        value_ = int.from_bytes(span[4:8], byteorder='little')
        span = span[8:]
        return ReadLmpHandleComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLmpHandleComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.lmp_handle > 255:
            print(f"Invalid value for field ReadLmpHandleComplete::lmp_handle: {self.lmp_handle} > 255; the value will be truncated")
            self.lmp_handle &= 255
        _span.append((self.lmp_handle << 0))
        _span.extend([0] * 4)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

class SynchronousPacketTypeBits(enum.IntEnum):
    HV1_ALLOWED = 0x1
    HV2_ALLOWED = 0x2
    HV3_ALLOWED = 0x4
    EV3_ALLOWED = 0x8
    EV4_ALLOWED = 0x10
    EV5_ALLOWED = 0x20
    NO_2_EV3_ALLOWED = 0x40
    NO_3_EV3_ALLOWED = 0x80
    NO_2_EV5_ALLOWED = 0x100
    NO_3_EV5_ALLOWED = 0x200

class RetransmissionEffort(enum.IntEnum):
    NO_RETRANSMISSION = 0x0
    OPTIMIZED_FOR_POWER = 0x1
    OPTIMIZED_FOR_LINK_QUALITY = 0x2
    DO_NOT_CARE = 0xff

@dataclass
class SetupSynchronousConnection(Command):
    connection_handle: int = field(kw_only=True, default=0)
    transmit_bandwidth: int = field(kw_only=True, default=0)
    receive_bandwidth: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    voice_setting: int = field(kw_only=True, default=0)
    retransmission_effort: RetransmissionEffort = field(kw_only=True, default=RetransmissionEffort.NO_RETRANSMISSION)
    packet_type: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SETUP_SYNCHRONOUS_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetupSynchronousConnection', bytes]:
        if fields['op_code'] != OpCode.SETUP_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 17:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:6], byteorder='little')
        fields['transmit_bandwidth'] = value_
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['receive_bandwidth'] = value_
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['max_latency'] = value_
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['voice_setting'] = (value_ >> 0) & 0x3ff
        fields['retransmission_effort'] = RetransmissionEffort(span[14])
        value_ = int.from_bytes(span[15:17], byteorder='little')
        fields['packet_type'] = value_
        span = span[17:]
        return SetupSynchronousConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field SetupSynchronousConnection::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.transmit_bandwidth > 4294967295:
            print(f"Invalid value for field SetupSynchronousConnection::transmit_bandwidth: {self.transmit_bandwidth} > 4294967295; the value will be truncated")
            self.transmit_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.transmit_bandwidth << 0), length=4, byteorder='little'))
        if self.receive_bandwidth > 4294967295:
            print(f"Invalid value for field SetupSynchronousConnection::receive_bandwidth: {self.receive_bandwidth} > 4294967295; the value will be truncated")
            self.receive_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.receive_bandwidth << 0), length=4, byteorder='little'))
        if self.max_latency > 65535:
            print(f"Invalid value for field SetupSynchronousConnection::max_latency: {self.max_latency} > 65535; the value will be truncated")
            self.max_latency &= 65535
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.voice_setting > 1023:
            print(f"Invalid value for field SetupSynchronousConnection::voice_setting: {self.voice_setting} > 1023; the value will be truncated")
            self.voice_setting &= 1023
        _span.extend(int.to_bytes((self.voice_setting << 0), length=2, byteorder='little'))
        _span.append((self.retransmission_effort << 0))
        if self.packet_type > 65535:
            print(f"Invalid value for field SetupSynchronousConnection::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 17

@dataclass
class SetupSynchronousConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.SETUP_SYNCHRONOUS_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetupSynchronousConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.SETUP_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        return SetupSynchronousConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class AcceptSynchronousConnection(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    transmit_bandwidth: int = field(kw_only=True, default=0)
    receive_bandwidth: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    voice_setting: int = field(kw_only=True, default=0)
    retransmission_effort: RetransmissionEffort = field(kw_only=True, default=RetransmissionEffort.NO_RETRANSMISSION)
    packet_type: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.ACCEPT_SYNCHRONOUS_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AcceptSynchronousConnection', bytes]:
        if fields['op_code'] != OpCode.ACCEPT_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 21:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['transmit_bandwidth'] = value_
        value_ = int.from_bytes(span[10:14], byteorder='little')
        fields['receive_bandwidth'] = value_
        value_ = int.from_bytes(span[14:16], byteorder='little')
        fields['max_latency'] = value_
        value_ = int.from_bytes(span[16:18], byteorder='little')
        fields['voice_setting'] = (value_ >> 0) & 0x3ff
        fields['retransmission_effort'] = RetransmissionEffort(span[18])
        value_ = int.from_bytes(span[19:21], byteorder='little')
        fields['packet_type'] = value_
        span = span[21:]
        return AcceptSynchronousConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.transmit_bandwidth > 4294967295:
            print(f"Invalid value for field AcceptSynchronousConnection::transmit_bandwidth: {self.transmit_bandwidth} > 4294967295; the value will be truncated")
            self.transmit_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.transmit_bandwidth << 0), length=4, byteorder='little'))
        if self.receive_bandwidth > 4294967295:
            print(f"Invalid value for field AcceptSynchronousConnection::receive_bandwidth: {self.receive_bandwidth} > 4294967295; the value will be truncated")
            self.receive_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.receive_bandwidth << 0), length=4, byteorder='little'))
        if self.max_latency > 65535:
            print(f"Invalid value for field AcceptSynchronousConnection::max_latency: {self.max_latency} > 65535; the value will be truncated")
            self.max_latency &= 65535
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.voice_setting > 1023:
            print(f"Invalid value for field AcceptSynchronousConnection::voice_setting: {self.voice_setting} > 1023; the value will be truncated")
            self.voice_setting &= 1023
        _span.extend(int.to_bytes((self.voice_setting << 0), length=2, byteorder='little'))
        _span.append((self.retransmission_effort << 0))
        if self.packet_type > 65535:
            print(f"Invalid value for field AcceptSynchronousConnection::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 21

@dataclass
class AcceptSynchronousConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.ACCEPT_SYNCHRONOUS_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AcceptSynchronousConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.ACCEPT_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        return AcceptSynchronousConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class RejectSynchronousConnection(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    reason: RejectConnectionReason = field(kw_only=True, default=RejectConnectionReason.LIMITED_RESOURCES)

    def __post_init__(self):
        self.op_code = OpCode.REJECT_SYNCHRONOUS_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RejectSynchronousConnection', bytes]:
        if fields['op_code'] != OpCode.REJECT_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['reason'] = RejectConnectionReason(span[6])
        span = span[7:]
        return RejectSynchronousConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.reason << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class RejectSynchronousConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.REJECT_SYNCHRONOUS_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RejectSynchronousConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.REJECT_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        return RejectSynchronousConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class IoCapability(enum.IntEnum):
    DISPLAY_ONLY = 0x0
    DISPLAY_YES_NO = 0x1
    KEYBOARD_ONLY = 0x2
    NO_INPUT_NO_OUTPUT = 0x3

class OobDataPresent(enum.IntEnum):
    NOT_PRESENT = 0x0
    P_192_PRESENT = 0x1
    P_256_PRESENT = 0x2
    P_192_AND_256_PRESENT = 0x3

class AuthenticationRequirements(enum.IntEnum):
    NO_BONDING = 0x0
    NO_BONDING_MITM_PROTECTION = 0x1
    DEDICATED_BONDING = 0x2
    DEDICATED_BONDING_MITM_PROTECTION = 0x3
    GENERAL_BONDING = 0x4
    GENERAL_BONDING_MITM_PROTECTION = 0x5

@dataclass
class IoCapabilityRequestReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    io_capability: IoCapability = field(kw_only=True, default=IoCapability.DISPLAY_ONLY)
    oob_present: OobDataPresent = field(kw_only=True, default=OobDataPresent.NOT_PRESENT)
    authentication_requirements: AuthenticationRequirements = field(kw_only=True, default=AuthenticationRequirements.NO_BONDING)

    def __post_init__(self):
        self.op_code = OpCode.IO_CAPABILITY_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IoCapabilityRequestReply', bytes]:
        if fields['op_code'] != OpCode.IO_CAPABILITY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['io_capability'] = IoCapability(span[6])
        fields['oob_present'] = OobDataPresent(span[7])
        fields['authentication_requirements'] = AuthenticationRequirements(span[8])
        span = span[9:]
        return IoCapabilityRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.io_capability << 0))
        _span.append((self.oob_present << 0))
        _span.append((self.authentication_requirements << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class IoCapabilityRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.IO_CAPABILITY_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IoCapabilityRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.IO_CAPABILITY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return IoCapabilityRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class UserConfirmationRequestReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.USER_CONFIRMATION_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserConfirmationRequestReply', bytes]:
        if fields['op_code'] != OpCode.USER_CONFIRMATION_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return UserConfirmationRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class UserConfirmationRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.USER_CONFIRMATION_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserConfirmationRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.USER_CONFIRMATION_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return UserConfirmationRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class UserConfirmationRequestNegativeReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserConfirmationRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return UserConfirmationRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class UserConfirmationRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserConfirmationRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return UserConfirmationRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class UserPasskeyRequestReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    numeric_value: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.USER_PASSKEY_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserPasskeyRequestReply', bytes]:
        if fields['op_code'] != OpCode.USER_PASSKEY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['numeric_value'] = value_
        span = span[10:]
        return UserPasskeyRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.numeric_value > 4294967295:
            print(f"Invalid value for field UserPasskeyRequestReply::numeric_value: {self.numeric_value} > 4294967295; the value will be truncated")
            self.numeric_value &= 4294967295
        _span.extend(int.to_bytes((self.numeric_value << 0), length=4, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class UserPasskeyRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.USER_PASSKEY_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserPasskeyRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.USER_PASSKEY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return UserPasskeyRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class UserPasskeyRequestNegativeReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.USER_PASSKEY_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserPasskeyRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.USER_PASSKEY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return UserPasskeyRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class UserPasskeyRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.USER_PASSKEY_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserPasskeyRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.USER_PASSKEY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return UserPasskeyRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class RemoteOobDataRequestReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    c: bytearray = field(kw_only=True, default_factory=bytearray)
    r: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.REMOTE_OOB_DATA_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteOobDataRequestReply', bytes]:
        if fields['op_code'] != OpCode.REMOTE_OOB_DATA_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['c'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['r'] = list(span[:16])
        span = span[16:]
        return RemoteOobDataRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.extend(self.c)
        _span.extend(self.r)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 38

@dataclass
class RemoteOobDataRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.REMOTE_OOB_DATA_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteOobDataRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.REMOTE_OOB_DATA_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return RemoteOobDataRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class RemoteOobDataRequestNegativeReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteOobDataRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return RemoteOobDataRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class RemoteOobDataRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteOobDataRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return RemoteOobDataRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class IoCapabilityRequestNegativeReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    reason: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.op_code = OpCode.IO_CAPABILITY_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IoCapabilityRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.IO_CAPABILITY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['reason'] = ErrorCode(span[6])
        span = span[7:]
        return IoCapabilityRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.reason << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class IoCapabilityRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.IO_CAPABILITY_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IoCapabilityRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.IO_CAPABILITY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return IoCapabilityRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

class ScoCodingFormatValues(enum.IntEnum):
    ULAW_LONG = 0x0
    ALAW_LONG = 0x1
    CVSD = 0x2
    TRANSPARENT = 0x3
    LINEAR_PCM = 0x4
    MSBC = 0x5
    LC3 = 0x6
    VENDOR_SPECIFIC = 0xff

@dataclass
class ScoCodingFormat(Packet):
    coding_format: ScoCodingFormatValues = field(kw_only=True, default=ScoCodingFormatValues.ULAW_LONG)
    company_id: int = field(kw_only=True, default=0)
    vendor_specific_codec_id: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['ScoCodingFormat', bytes]:
        fields = {'payload': None}
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['coding_format'] = ScoCodingFormatValues(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['company_id'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['vendor_specific_codec_id'] = value_
        span = span[5:]
        return ScoCodingFormat(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.coding_format << 0))
        if self.company_id > 65535:
            print(f"Invalid value for field ScoCodingFormat::company_id: {self.company_id} > 65535; the value will be truncated")
            self.company_id &= 65535
        _span.extend(int.to_bytes((self.company_id << 0), length=2, byteorder='little'))
        if self.vendor_specific_codec_id > 65535:
            print(f"Invalid value for field ScoCodingFormat::vendor_specific_codec_id: {self.vendor_specific_codec_id} > 65535; the value will be truncated")
            self.vendor_specific_codec_id &= 65535
        _span.extend(int.to_bytes((self.vendor_specific_codec_id << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 5

class ScoPcmDataFormat(enum.IntEnum):
    NOT_USED = 0x0
    ONES_COMPLEMENT = 0x1
    TWOS_COMPLEMENT = 0x2
    SIGN_MAGNITUDE = 0x3
    UNSIGNED = 0x4

class ScoDataPath(enum.IntEnum):
    HCI = 0x0
    GD_PCM = 0x1
    AUDIO_TEST_MODE = 0xff

@dataclass
class EnhancedSetupSynchronousConnection(Command):
    connection_handle: int = field(kw_only=True, default=0)
    transmit_bandwidth: int = field(kw_only=True, default=0)
    receive_bandwidth: int = field(kw_only=True, default=0)
    transmit_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    receive_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    transmit_codec_frame_size: int = field(kw_only=True, default=0)
    receive_codec_frame_size: int = field(kw_only=True, default=0)
    input_bandwidth: int = field(kw_only=True, default=0)
    output_bandwidth: int = field(kw_only=True, default=0)
    input_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    output_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    input_coded_data_bits: int = field(kw_only=True, default=0)
    output_coded_data_bits: int = field(kw_only=True, default=0)
    input_pcm_data_format: ScoPcmDataFormat = field(kw_only=True, default=ScoPcmDataFormat.NOT_USED)
    output_pcm_data_format: ScoPcmDataFormat = field(kw_only=True, default=ScoPcmDataFormat.NOT_USED)
    input_pcm_sample_payload_msb_position: int = field(kw_only=True, default=0)
    output_pcm_sample_payload_msb_position: int = field(kw_only=True, default=0)
    input_data_path: ScoDataPath = field(kw_only=True, default=ScoDataPath.HCI)
    output_data_path: ScoDataPath = field(kw_only=True, default=ScoDataPath.HCI)
    input_transport_unit_bits: int = field(kw_only=True, default=0)
    output_transport_unit_bits: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    packet_type: int = field(kw_only=True, default=0)
    retransmission_effort: RetransmissionEffort = field(kw_only=True, default=RetransmissionEffort.NO_RETRANSMISSION)

    def __post_init__(self):
        self.op_code = OpCode.ENHANCED_SETUP_SYNCHRONOUS_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnhancedSetupSynchronousConnection', bytes]:
        if fields['op_code'] != OpCode.ENHANCED_SETUP_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 59:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:6], byteorder='little')
        fields['transmit_bandwidth'] = value_
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['receive_bandwidth'] = value_
        fields['transmit_coding_format'] = ScoCodingFormat.parse_all(span[10:15])
        fields['receive_coding_format'] = ScoCodingFormat.parse_all(span[15:20])
        value_ = int.from_bytes(span[20:22], byteorder='little')
        fields['transmit_codec_frame_size'] = value_
        value_ = int.from_bytes(span[22:24], byteorder='little')
        fields['receive_codec_frame_size'] = value_
        value_ = int.from_bytes(span[24:28], byteorder='little')
        fields['input_bandwidth'] = value_
        value_ = int.from_bytes(span[28:32], byteorder='little')
        fields['output_bandwidth'] = value_
        fields['input_coding_format'] = ScoCodingFormat.parse_all(span[32:37])
        fields['output_coding_format'] = ScoCodingFormat.parse_all(span[37:42])
        value_ = int.from_bytes(span[42:44], byteorder='little')
        fields['input_coded_data_bits'] = value_
        value_ = int.from_bytes(span[44:46], byteorder='little')
        fields['output_coded_data_bits'] = value_
        fields['input_pcm_data_format'] = ScoPcmDataFormat(span[46])
        fields['output_pcm_data_format'] = ScoPcmDataFormat(span[47])
        fields['input_pcm_sample_payload_msb_position'] = span[48]
        fields['output_pcm_sample_payload_msb_position'] = span[49]
        fields['input_data_path'] = ScoDataPath(span[50])
        fields['output_data_path'] = ScoDataPath(span[51])
        fields['input_transport_unit_bits'] = span[52]
        fields['output_transport_unit_bits'] = span[53]
        value_ = int.from_bytes(span[54:56], byteorder='little')
        fields['max_latency'] = value_
        value_ = int.from_bytes(span[56:58], byteorder='little')
        fields['packet_type'] = value_
        fields['retransmission_effort'] = RetransmissionEffort(span[58])
        span = span[59:]
        return EnhancedSetupSynchronousConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.transmit_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::transmit_bandwidth: {self.transmit_bandwidth} > 4294967295; the value will be truncated")
            self.transmit_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.transmit_bandwidth << 0), length=4, byteorder='little'))
        if self.receive_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::receive_bandwidth: {self.receive_bandwidth} > 4294967295; the value will be truncated")
            self.receive_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.receive_bandwidth << 0), length=4, byteorder='little'))
        _span.extend(self.transmit_coding_format.serialize())
        _span.extend(self.receive_coding_format.serialize())
        if self.transmit_codec_frame_size > 65535:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::transmit_codec_frame_size: {self.transmit_codec_frame_size} > 65535; the value will be truncated")
            self.transmit_codec_frame_size &= 65535
        _span.extend(int.to_bytes((self.transmit_codec_frame_size << 0), length=2, byteorder='little'))
        if self.receive_codec_frame_size > 65535:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::receive_codec_frame_size: {self.receive_codec_frame_size} > 65535; the value will be truncated")
            self.receive_codec_frame_size &= 65535
        _span.extend(int.to_bytes((self.receive_codec_frame_size << 0), length=2, byteorder='little'))
        if self.input_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::input_bandwidth: {self.input_bandwidth} > 4294967295; the value will be truncated")
            self.input_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.input_bandwidth << 0), length=4, byteorder='little'))
        if self.output_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::output_bandwidth: {self.output_bandwidth} > 4294967295; the value will be truncated")
            self.output_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.output_bandwidth << 0), length=4, byteorder='little'))
        _span.extend(self.input_coding_format.serialize())
        _span.extend(self.output_coding_format.serialize())
        if self.input_coded_data_bits > 65535:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::input_coded_data_bits: {self.input_coded_data_bits} > 65535; the value will be truncated")
            self.input_coded_data_bits &= 65535
        _span.extend(int.to_bytes((self.input_coded_data_bits << 0), length=2, byteorder='little'))
        if self.output_coded_data_bits > 65535:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::output_coded_data_bits: {self.output_coded_data_bits} > 65535; the value will be truncated")
            self.output_coded_data_bits &= 65535
        _span.extend(int.to_bytes((self.output_coded_data_bits << 0), length=2, byteorder='little'))
        _span.append((self.input_pcm_data_format << 0))
        _span.append((self.output_pcm_data_format << 0))
        if self.input_pcm_sample_payload_msb_position > 255:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::input_pcm_sample_payload_msb_position: {self.input_pcm_sample_payload_msb_position} > 255; the value will be truncated")
            self.input_pcm_sample_payload_msb_position &= 255
        _span.append((self.input_pcm_sample_payload_msb_position << 0))
        if self.output_pcm_sample_payload_msb_position > 255:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::output_pcm_sample_payload_msb_position: {self.output_pcm_sample_payload_msb_position} > 255; the value will be truncated")
            self.output_pcm_sample_payload_msb_position &= 255
        _span.append((self.output_pcm_sample_payload_msb_position << 0))
        _span.append((self.input_data_path << 0))
        _span.append((self.output_data_path << 0))
        if self.input_transport_unit_bits > 255:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::input_transport_unit_bits: {self.input_transport_unit_bits} > 255; the value will be truncated")
            self.input_transport_unit_bits &= 255
        _span.append((self.input_transport_unit_bits << 0))
        if self.output_transport_unit_bits > 255:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::output_transport_unit_bits: {self.output_transport_unit_bits} > 255; the value will be truncated")
            self.output_transport_unit_bits &= 255
        _span.append((self.output_transport_unit_bits << 0))
        if self.max_latency > 65535:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::max_latency: {self.max_latency} > 65535; the value will be truncated")
            self.max_latency &= 65535
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.packet_type > 65535:
            print(f"Invalid value for field EnhancedSetupSynchronousConnection::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        _span.append((self.retransmission_effort << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 59

@dataclass
class EnhancedSetupSynchronousConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.ENHANCED_SETUP_SYNCHRONOUS_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnhancedSetupSynchronousConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.ENHANCED_SETUP_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        return EnhancedSetupSynchronousConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class EnhancedAcceptSynchronousConnection(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    transmit_bandwidth: int = field(kw_only=True, default=0)
    receive_bandwidth: int = field(kw_only=True, default=0)
    transmit_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    receive_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    transmit_codec_frame_size: int = field(kw_only=True, default=0)
    receive_codec_frame_size: int = field(kw_only=True, default=0)
    input_bandwidth: int = field(kw_only=True, default=0)
    output_bandwidth: int = field(kw_only=True, default=0)
    input_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    output_coding_format: ScoCodingFormat = field(kw_only=True, default_factory=ScoCodingFormat)
    input_coded_data_bits: int = field(kw_only=True, default=0)
    output_coded_data_bits: int = field(kw_only=True, default=0)
    input_pcm_data_format: ScoPcmDataFormat = field(kw_only=True, default=ScoPcmDataFormat.NOT_USED)
    output_pcm_data_format: ScoPcmDataFormat = field(kw_only=True, default=ScoPcmDataFormat.NOT_USED)
    input_pcm_sample_payload_msb_position: int = field(kw_only=True, default=0)
    output_pcm_sample_payload_msb_position: int = field(kw_only=True, default=0)
    input_data_path: ScoDataPath = field(kw_only=True, default=ScoDataPath.HCI)
    output_data_path: ScoDataPath = field(kw_only=True, default=ScoDataPath.HCI)
    input_transport_unit_bits: int = field(kw_only=True, default=0)
    output_transport_unit_bits: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    packet_type: int = field(kw_only=True, default=0)
    retransmission_effort: RetransmissionEffort = field(kw_only=True, default=RetransmissionEffort.NO_RETRANSMISSION)

    def __post_init__(self):
        self.op_code = OpCode.ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnhancedAcceptSynchronousConnection', bytes]:
        if fields['op_code'] != OpCode.ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 63:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['transmit_bandwidth'] = value_
        value_ = int.from_bytes(span[10:14], byteorder='little')
        fields['receive_bandwidth'] = value_
        fields['transmit_coding_format'] = ScoCodingFormat.parse_all(span[14:19])
        fields['receive_coding_format'] = ScoCodingFormat.parse_all(span[19:24])
        value_ = int.from_bytes(span[24:26], byteorder='little')
        fields['transmit_codec_frame_size'] = value_
        value_ = int.from_bytes(span[26:28], byteorder='little')
        fields['receive_codec_frame_size'] = value_
        value_ = int.from_bytes(span[28:32], byteorder='little')
        fields['input_bandwidth'] = value_
        value_ = int.from_bytes(span[32:36], byteorder='little')
        fields['output_bandwidth'] = value_
        fields['input_coding_format'] = ScoCodingFormat.parse_all(span[36:41])
        fields['output_coding_format'] = ScoCodingFormat.parse_all(span[41:46])
        value_ = int.from_bytes(span[46:48], byteorder='little')
        fields['input_coded_data_bits'] = value_
        value_ = int.from_bytes(span[48:50], byteorder='little')
        fields['output_coded_data_bits'] = value_
        fields['input_pcm_data_format'] = ScoPcmDataFormat(span[50])
        fields['output_pcm_data_format'] = ScoPcmDataFormat(span[51])
        fields['input_pcm_sample_payload_msb_position'] = span[52]
        fields['output_pcm_sample_payload_msb_position'] = span[53]
        fields['input_data_path'] = ScoDataPath(span[54])
        fields['output_data_path'] = ScoDataPath(span[55])
        fields['input_transport_unit_bits'] = span[56]
        fields['output_transport_unit_bits'] = span[57]
        value_ = int.from_bytes(span[58:60], byteorder='little')
        fields['max_latency'] = value_
        value_ = int.from_bytes(span[60:62], byteorder='little')
        fields['packet_type'] = value_
        fields['retransmission_effort'] = RetransmissionEffort(span[62])
        span = span[63:]
        return EnhancedAcceptSynchronousConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.transmit_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::transmit_bandwidth: {self.transmit_bandwidth} > 4294967295; the value will be truncated")
            self.transmit_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.transmit_bandwidth << 0), length=4, byteorder='little'))
        if self.receive_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::receive_bandwidth: {self.receive_bandwidth} > 4294967295; the value will be truncated")
            self.receive_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.receive_bandwidth << 0), length=4, byteorder='little'))
        _span.extend(self.transmit_coding_format.serialize())
        _span.extend(self.receive_coding_format.serialize())
        if self.transmit_codec_frame_size > 65535:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::transmit_codec_frame_size: {self.transmit_codec_frame_size} > 65535; the value will be truncated")
            self.transmit_codec_frame_size &= 65535
        _span.extend(int.to_bytes((self.transmit_codec_frame_size << 0), length=2, byteorder='little'))
        if self.receive_codec_frame_size > 65535:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::receive_codec_frame_size: {self.receive_codec_frame_size} > 65535; the value will be truncated")
            self.receive_codec_frame_size &= 65535
        _span.extend(int.to_bytes((self.receive_codec_frame_size << 0), length=2, byteorder='little'))
        if self.input_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::input_bandwidth: {self.input_bandwidth} > 4294967295; the value will be truncated")
            self.input_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.input_bandwidth << 0), length=4, byteorder='little'))
        if self.output_bandwidth > 4294967295:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::output_bandwidth: {self.output_bandwidth} > 4294967295; the value will be truncated")
            self.output_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.output_bandwidth << 0), length=4, byteorder='little'))
        _span.extend(self.input_coding_format.serialize())
        _span.extend(self.output_coding_format.serialize())
        if self.input_coded_data_bits > 65535:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::input_coded_data_bits: {self.input_coded_data_bits} > 65535; the value will be truncated")
            self.input_coded_data_bits &= 65535
        _span.extend(int.to_bytes((self.input_coded_data_bits << 0), length=2, byteorder='little'))
        if self.output_coded_data_bits > 65535:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::output_coded_data_bits: {self.output_coded_data_bits} > 65535; the value will be truncated")
            self.output_coded_data_bits &= 65535
        _span.extend(int.to_bytes((self.output_coded_data_bits << 0), length=2, byteorder='little'))
        _span.append((self.input_pcm_data_format << 0))
        _span.append((self.output_pcm_data_format << 0))
        if self.input_pcm_sample_payload_msb_position > 255:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::input_pcm_sample_payload_msb_position: {self.input_pcm_sample_payload_msb_position} > 255; the value will be truncated")
            self.input_pcm_sample_payload_msb_position &= 255
        _span.append((self.input_pcm_sample_payload_msb_position << 0))
        if self.output_pcm_sample_payload_msb_position > 255:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::output_pcm_sample_payload_msb_position: {self.output_pcm_sample_payload_msb_position} > 255; the value will be truncated")
            self.output_pcm_sample_payload_msb_position &= 255
        _span.append((self.output_pcm_sample_payload_msb_position << 0))
        _span.append((self.input_data_path << 0))
        _span.append((self.output_data_path << 0))
        if self.input_transport_unit_bits > 255:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::input_transport_unit_bits: {self.input_transport_unit_bits} > 255; the value will be truncated")
            self.input_transport_unit_bits &= 255
        _span.append((self.input_transport_unit_bits << 0))
        if self.output_transport_unit_bits > 255:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::output_transport_unit_bits: {self.output_transport_unit_bits} > 255; the value will be truncated")
            self.output_transport_unit_bits &= 255
        _span.append((self.output_transport_unit_bits << 0))
        if self.max_latency > 65535:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::max_latency: {self.max_latency} > 65535; the value will be truncated")
            self.max_latency &= 65535
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.packet_type > 65535:
            print(f"Invalid value for field EnhancedAcceptSynchronousConnection::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        _span.append((self.retransmission_effort << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 63

@dataclass
class EnhancedAcceptSynchronousConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnhancedAcceptSynchronousConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION:
            raise Exception("Invalid constraint field values")
        return EnhancedAcceptSynchronousConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class RemoteOobExtendedDataRequestReply(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    c_192: bytearray = field(kw_only=True, default_factory=bytearray)
    r_192: bytearray = field(kw_only=True, default_factory=bytearray)
    c_256: bytearray = field(kw_only=True, default_factory=bytearray)
    r_256: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteOobExtendedDataRequestReply', bytes]:
        if fields['op_code'] != OpCode.REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['c_192'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['r_192'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['c_256'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['r_256'] = list(span[:16])
        span = span[16:]
        return RemoteOobExtendedDataRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.extend(self.c_192)
        _span.extend(self.r_192)
        _span.extend(self.c_256)
        _span.extend(self.r_256)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 70

@dataclass
class RemoteOobExtendedDataRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteOobExtendedDataRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return RemoteOobExtendedDataRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class HoldMode(Command):
    connection_handle: int = field(kw_only=True, default=0)
    hold_mode_max_interval: int = field(kw_only=True, default=0)
    hold_mode_min_interval: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.HOLD_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['HoldMode', bytes]:
        if fields['op_code'] != OpCode.HOLD_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['hold_mode_max_interval'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['hold_mode_min_interval'] = value_
        span = span[6:]
        return HoldMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field HoldMode::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.hold_mode_max_interval > 65535:
            print(f"Invalid value for field HoldMode::hold_mode_max_interval: {self.hold_mode_max_interval} > 65535; the value will be truncated")
            self.hold_mode_max_interval &= 65535
        _span.extend(int.to_bytes((self.hold_mode_max_interval << 0), length=2, byteorder='little'))
        if self.hold_mode_min_interval > 65535:
            print(f"Invalid value for field HoldMode::hold_mode_min_interval: {self.hold_mode_min_interval} > 65535; the value will be truncated")
            self.hold_mode_min_interval &= 65535
        _span.extend(int.to_bytes((self.hold_mode_min_interval << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class HoldModeStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.HOLD_MODE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['HoldModeStatus', bytes]:
        if fields['command_op_code'] != OpCode.HOLD_MODE:
            raise Exception("Invalid constraint field values")
        return HoldModeStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class SniffMode(Command):
    connection_handle: int = field(kw_only=True, default=0)
    sniff_max_interval: int = field(kw_only=True, default=0)
    sniff_min_interval: int = field(kw_only=True, default=0)
    sniff_attempt: int = field(kw_only=True, default=0)
    sniff_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SNIFF_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SniffMode', bytes]:
        if fields['op_code'] != OpCode.SNIFF_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['sniff_max_interval'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['sniff_min_interval'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['sniff_attempt'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['sniff_timeout'] = value_
        span = span[10:]
        return SniffMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field SniffMode::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.sniff_max_interval > 65535:
            print(f"Invalid value for field SniffMode::sniff_max_interval: {self.sniff_max_interval} > 65535; the value will be truncated")
            self.sniff_max_interval &= 65535
        _span.extend(int.to_bytes((self.sniff_max_interval << 0), length=2, byteorder='little'))
        if self.sniff_min_interval > 65535:
            print(f"Invalid value for field SniffMode::sniff_min_interval: {self.sniff_min_interval} > 65535; the value will be truncated")
            self.sniff_min_interval &= 65535
        _span.extend(int.to_bytes((self.sniff_min_interval << 0), length=2, byteorder='little'))
        if self.sniff_attempt > 65535:
            print(f"Invalid value for field SniffMode::sniff_attempt: {self.sniff_attempt} > 65535; the value will be truncated")
            self.sniff_attempt &= 65535
        _span.extend(int.to_bytes((self.sniff_attempt << 0), length=2, byteorder='little'))
        if self.sniff_timeout > 65535:
            print(f"Invalid value for field SniffMode::sniff_timeout: {self.sniff_timeout} > 65535; the value will be truncated")
            self.sniff_timeout &= 65535
        _span.extend(int.to_bytes((self.sniff_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class SniffModeStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.SNIFF_MODE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SniffModeStatus', bytes]:
        if fields['command_op_code'] != OpCode.SNIFF_MODE:
            raise Exception("Invalid constraint field values")
        return SniffModeStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ExitSniffMode(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.EXIT_SNIFF_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ExitSniffMode', bytes]:
        if fields['op_code'] != OpCode.EXIT_SNIFF_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ExitSniffMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ExitSniffMode::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ExitSniffModeStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.EXIT_SNIFF_MODE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ExitSniffModeStatus', bytes]:
        if fields['command_op_code'] != OpCode.EXIT_SNIFF_MODE:
            raise Exception("Invalid constraint field values")
        return ExitSniffModeStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class ServiceType(enum.IntEnum):
    NO_TRAFFIC = 0x0
    BEST_EFFORT = 0x1
    GUARANTEED = 0x2

@dataclass
class QosSetup(Command):
    connection_handle: int = field(kw_only=True, default=0)
    service_type: ServiceType = field(kw_only=True, default=ServiceType.NO_TRAFFIC)
    token_rate: int = field(kw_only=True, default=0)
    peak_bandwidth: int = field(kw_only=True, default=0)
    latency: int = field(kw_only=True, default=0)
    delay_variation: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.QOS_SETUP

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['QosSetup', bytes]:
        if fields['op_code'] != OpCode.QOS_SETUP:
            raise Exception("Invalid constraint field values")
        if len(span) < 20:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['service_type'] = ServiceType(span[3])
        value_ = int.from_bytes(span[4:8], byteorder='little')
        fields['token_rate'] = value_
        value_ = int.from_bytes(span[8:12], byteorder='little')
        fields['peak_bandwidth'] = value_
        value_ = int.from_bytes(span[12:16], byteorder='little')
        fields['latency'] = value_
        value_ = int.from_bytes(span[16:20], byteorder='little')
        fields['delay_variation'] = value_
        span = span[20:]
        return QosSetup(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field QosSetup::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend([0] * 1)
        _span.append((self.service_type << 0))
        if self.token_rate > 4294967295:
            print(f"Invalid value for field QosSetup::token_rate: {self.token_rate} > 4294967295; the value will be truncated")
            self.token_rate &= 4294967295
        _span.extend(int.to_bytes((self.token_rate << 0), length=4, byteorder='little'))
        if self.peak_bandwidth > 4294967295:
            print(f"Invalid value for field QosSetup::peak_bandwidth: {self.peak_bandwidth} > 4294967295; the value will be truncated")
            self.peak_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.peak_bandwidth << 0), length=4, byteorder='little'))
        if self.latency > 4294967295:
            print(f"Invalid value for field QosSetup::latency: {self.latency} > 4294967295; the value will be truncated")
            self.latency &= 4294967295
        _span.extend(int.to_bytes((self.latency << 0), length=4, byteorder='little'))
        if self.delay_variation > 4294967295:
            print(f"Invalid value for field QosSetup::delay_variation: {self.delay_variation} > 4294967295; the value will be truncated")
            self.delay_variation &= 4294967295
        _span.extend(int.to_bytes((self.delay_variation << 0), length=4, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 20

@dataclass
class QosSetupStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.QOS_SETUP
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['QosSetupStatus', bytes]:
        if fields['command_op_code'] != OpCode.QOS_SETUP:
            raise Exception("Invalid constraint field values")
        return QosSetupStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class RoleDiscovery(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.ROLE_DISCOVERY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RoleDiscovery', bytes]:
        if fields['op_code'] != OpCode.ROLE_DISCOVERY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return RoleDiscovery(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field RoleDiscovery::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class Role(enum.IntEnum):
    CENTRAL = 0x0
    PERIPHERAL = 0x1

@dataclass
class RoleDiscoveryComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    current_role: Role = field(kw_only=True, default=Role.CENTRAL)

    def __post_init__(self):
        self.command_op_code = OpCode.ROLE_DISCOVERY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RoleDiscoveryComplete', bytes]:
        if fields['command_op_code'] != OpCode.ROLE_DISCOVERY:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['current_role'] = Role(span[3])
        span = span[4:]
        return RoleDiscoveryComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field RoleDiscoveryComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.current_role << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class SwitchRole(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    role: Role = field(kw_only=True, default=Role.CENTRAL)

    def __post_init__(self):
        self.op_code = OpCode.SWITCH_ROLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SwitchRole', bytes]:
        if fields['op_code'] != OpCode.SWITCH_ROLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['role'] = Role(span[6])
        span = span[7:]
        return SwitchRole(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.role << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class SwitchRoleStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.SWITCH_ROLE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SwitchRoleStatus', bytes]:
        if fields['command_op_code'] != OpCode.SWITCH_ROLE:
            raise Exception("Invalid constraint field values")
        return SwitchRoleStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLinkPolicySettings(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_LINK_POLICY_SETTINGS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLinkPolicySettings', bytes]:
        if fields['op_code'] != OpCode.READ_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadLinkPolicySettings(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLinkPolicySettings::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class LinkPolicy(enum.IntEnum):
    ENABLE_ROLE_SWITCH = 0x1
    ENABLE_HOLD_MODE = 0x2
    ENABLE_SNIFF_MODE = 0x4
    ENABLE_PARK_MODE = 0x8

@dataclass
class ReadLinkPolicySettingsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    link_policy_settings: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LINK_POLICY_SETTINGS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLinkPolicySettingsComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['link_policy_settings'] = value_
        span = span[5:]
        return ReadLinkPolicySettingsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLinkPolicySettingsComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.link_policy_settings > 65535:
            print(f"Invalid value for field ReadLinkPolicySettingsComplete::link_policy_settings: {self.link_policy_settings} > 65535; the value will be truncated")
            self.link_policy_settings &= 65535
        _span.extend(int.to_bytes((self.link_policy_settings << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class WriteLinkPolicySettings(Command):
    connection_handle: int = field(kw_only=True, default=0)
    link_policy_settings: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_LINK_POLICY_SETTINGS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLinkPolicySettings', bytes]:
        if fields['op_code'] != OpCode.WRITE_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['link_policy_settings'] = value_
        span = span[4:]
        return WriteLinkPolicySettings(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field WriteLinkPolicySettings::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.link_policy_settings > 65535:
            print(f"Invalid value for field WriteLinkPolicySettings::link_policy_settings: {self.link_policy_settings} > 65535; the value will be truncated")
            self.link_policy_settings &= 65535
        _span.extend(int.to_bytes((self.link_policy_settings << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class WriteLinkPolicySettingsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_LINK_POLICY_SETTINGS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLinkPolicySettingsComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return WriteLinkPolicySettingsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field WriteLinkPolicySettingsComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadDefaultLinkPolicySettings(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_DEFAULT_LINK_POLICY_SETTINGS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadDefaultLinkPolicySettings', bytes]:
        if fields['op_code'] != OpCode.READ_DEFAULT_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        return ReadDefaultLinkPolicySettings(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadDefaultLinkPolicySettingsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    default_link_policy_settings: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_DEFAULT_LINK_POLICY_SETTINGS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadDefaultLinkPolicySettingsComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_DEFAULT_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['default_link_policy_settings'] = value_
        span = span[3:]
        return ReadDefaultLinkPolicySettingsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.default_link_policy_settings > 65535:
            print(f"Invalid value for field ReadDefaultLinkPolicySettingsComplete::default_link_policy_settings: {self.default_link_policy_settings} > 65535; the value will be truncated")
            self.default_link_policy_settings &= 65535
        _span.extend(int.to_bytes((self.default_link_policy_settings << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class WriteDefaultLinkPolicySettings(Command):
    default_link_policy_settings: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_DEFAULT_LINK_POLICY_SETTINGS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteDefaultLinkPolicySettings', bytes]:
        if fields['op_code'] != OpCode.WRITE_DEFAULT_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['default_link_policy_settings'] = value_
        span = span[2:]
        return WriteDefaultLinkPolicySettings(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.default_link_policy_settings > 65535:
            print(f"Invalid value for field WriteDefaultLinkPolicySettings::default_link_policy_settings: {self.default_link_policy_settings} > 65535; the value will be truncated")
            self.default_link_policy_settings &= 65535
        _span.extend(int.to_bytes((self.default_link_policy_settings << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteDefaultLinkPolicySettingsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_DEFAULT_LINK_POLICY_SETTINGS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteDefaultLinkPolicySettingsComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_DEFAULT_LINK_POLICY_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteDefaultLinkPolicySettingsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class FlowDirection(enum.IntEnum):
    OUTGOING_FLOW = 0x0
    INCOMING_FLOW = 0x1

@dataclass
class FlowSpecification(Command):
    connection_handle: int = field(kw_only=True, default=0)
    flow_direction: FlowDirection = field(kw_only=True, default=FlowDirection.OUTGOING_FLOW)
    service_type: ServiceType = field(kw_only=True, default=ServiceType.NO_TRAFFIC)
    token_rate: int = field(kw_only=True, default=0)
    token_bucket_size: int = field(kw_only=True, default=0)
    peak_bandwidth: int = field(kw_only=True, default=0)
    access_latency: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.FLOW_SPECIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['FlowSpecification', bytes]:
        if fields['op_code'] != OpCode.FLOW_SPECIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 21:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['flow_direction'] = FlowDirection(span[3])
        fields['service_type'] = ServiceType(span[4])
        value_ = int.from_bytes(span[5:9], byteorder='little')
        fields['token_rate'] = value_
        value_ = int.from_bytes(span[9:13], byteorder='little')
        fields['token_bucket_size'] = value_
        value_ = int.from_bytes(span[13:17], byteorder='little')
        fields['peak_bandwidth'] = value_
        value_ = int.from_bytes(span[17:21], byteorder='little')
        fields['access_latency'] = value_
        span = span[21:]
        return FlowSpecification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field FlowSpecification::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend([0] * 1)
        _span.append((self.flow_direction << 0))
        _span.append((self.service_type << 0))
        if self.token_rate > 4294967295:
            print(f"Invalid value for field FlowSpecification::token_rate: {self.token_rate} > 4294967295; the value will be truncated")
            self.token_rate &= 4294967295
        _span.extend(int.to_bytes((self.token_rate << 0), length=4, byteorder='little'))
        if self.token_bucket_size > 4294967295:
            print(f"Invalid value for field FlowSpecification::token_bucket_size: {self.token_bucket_size} > 4294967295; the value will be truncated")
            self.token_bucket_size &= 4294967295
        _span.extend(int.to_bytes((self.token_bucket_size << 0), length=4, byteorder='little'))
        if self.peak_bandwidth > 4294967295:
            print(f"Invalid value for field FlowSpecification::peak_bandwidth: {self.peak_bandwidth} > 4294967295; the value will be truncated")
            self.peak_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.peak_bandwidth << 0), length=4, byteorder='little'))
        if self.access_latency > 4294967295:
            print(f"Invalid value for field FlowSpecification::access_latency: {self.access_latency} > 4294967295; the value will be truncated")
            self.access_latency &= 4294967295
        _span.extend(int.to_bytes((self.access_latency << 0), length=4, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 21

@dataclass
class FlowSpecificationStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.FLOW_SPECIFICATION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['FlowSpecificationStatus', bytes]:
        if fields['command_op_code'] != OpCode.FLOW_SPECIFICATION:
            raise Exception("Invalid constraint field values")
        return FlowSpecificationStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class SniffSubrating(Command):
    connection_handle: int = field(kw_only=True, default=0)
    maximum_latency: int = field(kw_only=True, default=0)
    minimum_remote_timeout: int = field(kw_only=True, default=0)
    minimum_local_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SNIFF_SUBRATING

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SniffSubrating', bytes]:
        if fields['op_code'] != OpCode.SNIFF_SUBRATING:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['maximum_latency'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['minimum_remote_timeout'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['minimum_local_timeout'] = value_
        span = span[8:]
        return SniffSubrating(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field SniffSubrating::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.maximum_latency > 65535:
            print(f"Invalid value for field SniffSubrating::maximum_latency: {self.maximum_latency} > 65535; the value will be truncated")
            self.maximum_latency &= 65535
        _span.extend(int.to_bytes((self.maximum_latency << 0), length=2, byteorder='little'))
        if self.minimum_remote_timeout > 65535:
            print(f"Invalid value for field SniffSubrating::minimum_remote_timeout: {self.minimum_remote_timeout} > 65535; the value will be truncated")
            self.minimum_remote_timeout &= 65535
        _span.extend(int.to_bytes((self.minimum_remote_timeout << 0), length=2, byteorder='little'))
        if self.minimum_local_timeout > 65535:
            print(f"Invalid value for field SniffSubrating::minimum_local_timeout: {self.minimum_local_timeout} > 65535; the value will be truncated")
            self.minimum_local_timeout &= 65535
        _span.extend(int.to_bytes((self.minimum_local_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class SniffSubratingComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.SNIFF_SUBRATING
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SniffSubratingComplete', bytes]:
        if fields['command_op_code'] != OpCode.SNIFF_SUBRATING:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return SniffSubratingComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field SniffSubratingComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class SetEventMask(Command):
    event_mask: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SET_EVENT_MASK

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventMask', bytes]:
        if fields['op_code'] != OpCode.SET_EVENT_MASK:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:8], byteorder='little')
        fields['event_mask'] = value_
        span = span[8:]
        return SetEventMask(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.event_mask > 18446744073709551615:
            print(f"Invalid value for field SetEventMask::event_mask: {self.event_mask} > 18446744073709551615; the value will be truncated")
            self.event_mask &= 18446744073709551615
        _span.extend(int.to_bytes((self.event_mask << 0), length=8, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class SetEventMaskComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.SET_EVENT_MASK
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventMaskComplete', bytes]:
        if fields['command_op_code'] != OpCode.SET_EVENT_MASK:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return SetEventMaskComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class Reset(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.RESET

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['Reset', bytes]:
        if fields['op_code'] != OpCode.RESET:
            raise Exception("Invalid constraint field values")
        return Reset(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ResetComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.RESET
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ResetComplete', bytes]:
        if fields['command_op_code'] != OpCode.RESET:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return ResetComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class FilterType(enum.IntEnum):
    CLEAR_ALL_FILTERS = 0x0
    INQUIRY_RESULT = 0x1
    CONNECTION_SETUP = 0x2

@dataclass
class SetEventFilter(Command):
    filter_type: FilterType = field(kw_only=True, default=FilterType.CLEAR_ALL_FILTERS)

    def __post_init__(self):
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilter', bytes]:
        if fields['op_code'] != OpCode.SET_EVENT_FILTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['filter_type'] = FilterType(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return SetEventFilterClearAll.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilterInquiryResult.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilterConnectionSetup.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return SetEventFilter(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.filter_type << 0))
        _span.extend(payload or self.payload or [])
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class SetEventFilterComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.SET_EVENT_FILTER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterComplete', bytes]:
        if fields['command_op_code'] != OpCode.SET_EVENT_FILTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return SetEventFilterComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class SetEventFilterClearAll(SetEventFilter):
    

    def __post_init__(self):
        self.filter_type = FilterType.CLEAR_ALL_FILTERS
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterClearAll', bytes]:
        if fields['filter_type'] != FilterType.CLEAR_ALL_FILTERS:
            raise Exception("Invalid constraint field values")
        return SetEventFilterClearAll(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return SetEventFilter.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class FilterConditionType(enum.IntEnum):
    ALL_DEVICES = 0x0
    CLASS_OF_DEVICE = 0x1
    ADDRESS = 0x2

@dataclass
class SetEventFilterInquiryResult(SetEventFilter):
    filter_condition_type: FilterConditionType = field(kw_only=True, default=FilterConditionType.ALL_DEVICES)

    def __post_init__(self):
        self.filter_type = FilterType.INQUIRY_RESULT
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterInquiryResult', bytes]:
        if fields['filter_type'] != FilterType.INQUIRY_RESULT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['filter_condition_type'] = FilterConditionType(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return SetEventFilterInquiryResultAllDevices.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilterInquiryResultClassOfDevice.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilterInquiryResultAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return SetEventFilterInquiryResult(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.filter_condition_type << 0))
        _span.extend(payload or self.payload or [])
        return SetEventFilter.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class SetEventFilterInquiryResultAllDevices(SetEventFilterInquiryResult):
    

    def __post_init__(self):
        self.filter_condition_type = FilterConditionType.ALL_DEVICES
        self.filter_type = FilterType.INQUIRY_RESULT
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterInquiryResultAllDevices', bytes]:
        if fields['filter_condition_type'] != FilterConditionType.ALL_DEVICES:
            raise Exception("Invalid constraint field values")
        return SetEventFilterInquiryResultAllDevices(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return SetEventFilterInquiryResult.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class SetEventFilterInquiryResultClassOfDevice(SetEventFilterInquiryResult):
    class_of_device: int = field(kw_only=True, default=0)
    class_of_device_mask: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.filter_condition_type = FilterConditionType.CLASS_OF_DEVICE
        self.filter_type = FilterType.INQUIRY_RESULT
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterInquiryResultClassOfDevice', bytes]:
        if fields['filter_condition_type'] != FilterConditionType.CLASS_OF_DEVICE:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:3], byteorder='little')
        fields['class_of_device'] = value_
        value_ = int.from_bytes(span[3:6], byteorder='little')
        fields['class_of_device_mask'] = value_
        span = span[6:]
        return SetEventFilterInquiryResultClassOfDevice(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.class_of_device > 16777215:
            print(f"Invalid value for field SetEventFilterInquiryResultClassOfDevice::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        if self.class_of_device_mask > 16777215:
            print(f"Invalid value for field SetEventFilterInquiryResultClassOfDevice::class_of_device_mask: {self.class_of_device_mask} > 16777215; the value will be truncated")
            self.class_of_device_mask &= 16777215
        _span.extend(int.to_bytes((self.class_of_device_mask << 0), length=3, byteorder='little'))
        return SetEventFilterInquiryResult.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class SetEventFilterInquiryResultAddress(SetEventFilterInquiryResult):
    address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.filter_condition_type = FilterConditionType.ADDRESS
        self.filter_type = FilterType.INQUIRY_RESULT
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterInquiryResultAddress', bytes]:
        if fields['filter_condition_type'] != FilterConditionType.ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['address'] = Address.parse_all(span[0:6])
        span = span[6:]
        return SetEventFilterInquiryResultAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.address.serialize())
        return SetEventFilterInquiryResult.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class SetEventFilterConnectionSetup(SetEventFilter):
    filter_condition_type: FilterConditionType = field(kw_only=True, default=FilterConditionType.ALL_DEVICES)

    def __post_init__(self):
        self.filter_type = FilterType.CONNECTION_SETUP
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterConnectionSetup', bytes]:
        if fields['filter_type'] != FilterType.CONNECTION_SETUP:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['filter_condition_type'] = FilterConditionType(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return SetEventFilterConnectionSetupAllDevices.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilterConnectionSetupClassOfDevice.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return SetEventFilterConnectionSetupAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return SetEventFilterConnectionSetup(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.filter_condition_type << 0))
        _span.extend(payload or self.payload or [])
        return SetEventFilter.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

class AutoAcceptFlag(enum.IntEnum):
    AUTO_ACCEPT_OFF = 0x1
    AUTO_ACCEPT_ON_ROLE_SWITCH_DISABLED = 0x2
    AUTO_ACCEPT_ON_ROLE_SWITCH_ENABLED = 0x3

@dataclass
class SetEventFilterConnectionSetupAllDevices(SetEventFilterConnectionSetup):
    auto_accept_flag: AutoAcceptFlag = field(kw_only=True, default=AutoAcceptFlag.AUTO_ACCEPT_OFF)

    def __post_init__(self):
        self.filter_condition_type = FilterConditionType.ALL_DEVICES
        self.filter_type = FilterType.CONNECTION_SETUP
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterConnectionSetupAllDevices', bytes]:
        if fields['filter_condition_type'] != FilterConditionType.ALL_DEVICES:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['auto_accept_flag'] = AutoAcceptFlag(span[0])
        span = span[1:]
        return SetEventFilterConnectionSetupAllDevices(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.auto_accept_flag << 0))
        return SetEventFilterConnectionSetup.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class SetEventFilterConnectionSetupClassOfDevice(SetEventFilterConnectionSetup):
    class_of_device: int = field(kw_only=True, default=0)
    class_of_device_mask: int = field(kw_only=True, default=0)
    auto_accept_flag: AutoAcceptFlag = field(kw_only=True, default=AutoAcceptFlag.AUTO_ACCEPT_OFF)

    def __post_init__(self):
        self.filter_condition_type = FilterConditionType.CLASS_OF_DEVICE
        self.filter_type = FilterType.CONNECTION_SETUP
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterConnectionSetupClassOfDevice', bytes]:
        if fields['filter_condition_type'] != FilterConditionType.CLASS_OF_DEVICE:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:3], byteorder='little')
        fields['class_of_device'] = value_
        value_ = int.from_bytes(span[3:6], byteorder='little')
        fields['class_of_device_mask'] = value_
        fields['auto_accept_flag'] = AutoAcceptFlag(span[6])
        span = span[7:]
        return SetEventFilterConnectionSetupClassOfDevice(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.class_of_device > 16777215:
            print(f"Invalid value for field SetEventFilterConnectionSetupClassOfDevice::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        if self.class_of_device_mask > 16777215:
            print(f"Invalid value for field SetEventFilterConnectionSetupClassOfDevice::class_of_device_mask: {self.class_of_device_mask} > 16777215; the value will be truncated")
            self.class_of_device_mask &= 16777215
        _span.extend(int.to_bytes((self.class_of_device_mask << 0), length=3, byteorder='little'))
        _span.append((self.auto_accept_flag << 0))
        return SetEventFilterConnectionSetup.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class SetEventFilterConnectionSetupAddress(SetEventFilterConnectionSetup):
    address: Address = field(kw_only=True, default_factory=Address)
    auto_accept_flag: AutoAcceptFlag = field(kw_only=True, default=AutoAcceptFlag.AUTO_ACCEPT_OFF)

    def __post_init__(self):
        self.filter_condition_type = FilterConditionType.ADDRESS
        self.filter_type = FilterType.CONNECTION_SETUP
        self.op_code = OpCode.SET_EVENT_FILTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventFilterConnectionSetupAddress', bytes]:
        if fields['filter_condition_type'] != FilterConditionType.ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['address'] = Address.parse_all(span[0:6])
        fields['auto_accept_flag'] = AutoAcceptFlag(span[6])
        span = span[7:]
        return SetEventFilterConnectionSetupAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.address.serialize())
        _span.append((self.auto_accept_flag << 0))
        return SetEventFilterConnectionSetup.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class Flush(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.FLUSH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['Flush', bytes]:
        if fields['op_code'] != OpCode.FLUSH:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return Flush(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field Flush::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class FlushComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.FLUSH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['FlushComplete', bytes]:
        if fields['command_op_code'] != OpCode.FLUSH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return FlushComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field FlushComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

class PinType(enum.IntEnum):
    VARIABLE = 0x0
    FIXED = 0x1

@dataclass
class ReadPinType(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_PIN_TYPE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPinType', bytes]:
        if fields['op_code'] != OpCode.READ_PIN_TYPE:
            raise Exception("Invalid constraint field values")
        return ReadPinType(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadPinTypeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    pin_type: PinType = field(kw_only=True, default=PinType.VARIABLE)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_PIN_TYPE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPinTypeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_PIN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['pin_type'] = PinType(span[1])
        span = span[2:]
        return ReadPinTypeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.pin_type << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WritePinType(Command):
    pin_type: PinType = field(kw_only=True, default=PinType.VARIABLE)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_PIN_TYPE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePinType', bytes]:
        if fields['op_code'] != OpCode.WRITE_PIN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['pin_type'] = PinType(span[0])
        span = span[1:]
        return WritePinType(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.pin_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WritePinTypeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_PIN_TYPE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePinTypeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_PIN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WritePinTypeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class ReadStoredLinkKeyReadAllFlag(enum.IntEnum):
    SPECIFIED_BD_ADDR = 0x0
    ALL = 0x1

@dataclass
class ReadStoredLinkKey(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    read_all_flag: ReadStoredLinkKeyReadAllFlag = field(kw_only=True, default=ReadStoredLinkKeyReadAllFlag.SPECIFIED_BD_ADDR)

    def __post_init__(self):
        self.op_code = OpCode.READ_STORED_LINK_KEY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadStoredLinkKey', bytes]:
        if fields['op_code'] != OpCode.READ_STORED_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['read_all_flag'] = ReadStoredLinkKeyReadAllFlag(span[6])
        span = span[7:]
        return ReadStoredLinkKey(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.read_all_flag << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class ReadStoredLinkKeyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    max_num_keys: int = field(kw_only=True, default=0)
    num_keys_read: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_STORED_LINK_KEY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadStoredLinkKeyComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_STORED_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['max_num_keys'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['num_keys_read'] = value_
        span = span[5:]
        return ReadStoredLinkKeyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.max_num_keys > 65535:
            print(f"Invalid value for field ReadStoredLinkKeyComplete::max_num_keys: {self.max_num_keys} > 65535; the value will be truncated")
            self.max_num_keys &= 65535
        _span.extend(int.to_bytes((self.max_num_keys << 0), length=2, byteorder='little'))
        if self.num_keys_read > 65535:
            print(f"Invalid value for field ReadStoredLinkKeyComplete::num_keys_read: {self.num_keys_read} > 65535; the value will be truncated")
            self.num_keys_read &= 65535
        _span.extend(int.to_bytes((self.num_keys_read << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class KeyAndAddress(Packet):
    address: Address = field(kw_only=True, default_factory=Address)
    link_key: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['KeyAndAddress', bytes]:
        fields = {'payload': None}
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['address'] = Address.parse_all(span[0:6])
        span = span[6:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['link_key'] = list(span[:16])
        span = span[16:]
        return KeyAndAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.address.serialize())
        _span.extend(self.link_key)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 22

@dataclass
class WriteStoredLinkKey(Command):
    keys_to_write: List[KeyAndAddress] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_STORED_LINK_KEY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteStoredLinkKey', bytes]:
        if fields['op_code'] != OpCode.WRITE_STORED_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        keys_to_write_count = span[0]
        span = span[1:]
        if len(span) < keys_to_write_count * 22:
            raise Exception('Invalid packet size')
        keys_to_write = []
        for n in range(keys_to_write_count):
            keys_to_write.append(KeyAndAddress.parse_all(span[n * 22:(n + 1) * 22]))
        fields['keys_to_write'] = keys_to_write
        span = span[keys_to_write_count * 22:]
        return WriteStoredLinkKey(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.keys_to_write) > 255:
            print(f"Invalid length for field WriteStoredLinkKey::keys_to_write:  {len(self.keys_to_write)} > 255; the array will be truncated")
            del self.keys_to_write[255:]
        _span.append((len(self.keys_to_write) << 0))
        for _elt in self.keys_to_write:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.keys_to_write]) + 1

@dataclass
class WriteStoredLinkKeyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    num_keys_written: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_STORED_LINK_KEY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteStoredLinkKeyComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_STORED_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['num_keys_written'] = span[1]
        span = span[2:]
        return WriteStoredLinkKeyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.num_keys_written > 255:
            print(f"Invalid value for field WriteStoredLinkKeyComplete::num_keys_written: {self.num_keys_written} > 255; the value will be truncated")
            self.num_keys_written &= 255
        _span.append((self.num_keys_written << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class DeleteStoredLinkKeyDeleteAllFlag(enum.IntEnum):
    SPECIFIED_BD_ADDR = 0x0
    ALL = 0x1

@dataclass
class DeleteStoredLinkKey(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    delete_all_flag: DeleteStoredLinkKeyDeleteAllFlag = field(kw_only=True, default=DeleteStoredLinkKeyDeleteAllFlag.SPECIFIED_BD_ADDR)

    def __post_init__(self):
        self.op_code = OpCode.DELETE_STORED_LINK_KEY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['DeleteStoredLinkKey', bytes]:
        if fields['op_code'] != OpCode.DELETE_STORED_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['delete_all_flag'] = DeleteStoredLinkKeyDeleteAllFlag(span[6])
        span = span[7:]
        return DeleteStoredLinkKey(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.delete_all_flag << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class DeleteStoredLinkKeyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    num_keys_deleted: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.DELETE_STORED_LINK_KEY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['DeleteStoredLinkKeyComplete', bytes]:
        if fields['command_op_code'] != OpCode.DELETE_STORED_LINK_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['num_keys_deleted'] = value_
        span = span[3:]
        return DeleteStoredLinkKeyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.num_keys_deleted > 65535:
            print(f"Invalid value for field DeleteStoredLinkKeyComplete::num_keys_deleted: {self.num_keys_deleted} > 65535; the value will be truncated")
            self.num_keys_deleted &= 65535
        _span.extend(int.to_bytes((self.num_keys_deleted << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class WriteLocalName(Command):
    local_name: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_LOCAL_NAME

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLocalName', bytes]:
        if fields['op_code'] != OpCode.WRITE_LOCAL_NAME:
            raise Exception("Invalid constraint field values")
        if len(span) < 248:
            raise Exception('Invalid packet size')
        fields['local_name'] = list(span[:248])
        span = span[248:]
        return WriteLocalName(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.local_name)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 248

@dataclass
class WriteLocalNameComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_LOCAL_NAME
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLocalNameComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_LOCAL_NAME:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteLocalNameComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadLocalName(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_NAME

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalName', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_NAME:
            raise Exception("Invalid constraint field values")
        return ReadLocalName(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLocalNameComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    local_name: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_NAME
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalNameComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_NAME:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        if len(span) < 248:
            raise Exception('Invalid packet size')
        fields['local_name'] = list(span[:248])
        span = span[248:]
        return ReadLocalNameComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.local_name)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 249

@dataclass
class ReadConnectionAcceptTimeout(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_CONNECTION_ACCEPT_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadConnectionAcceptTimeout', bytes]:
        if fields['op_code'] != OpCode.READ_CONNECTION_ACCEPT_TIMEOUT:
            raise Exception("Invalid constraint field values")
        return ReadConnectionAcceptTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadConnectionAcceptTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    conn_accept_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_CONNECTION_ACCEPT_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadConnectionAcceptTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_CONNECTION_ACCEPT_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['conn_accept_timeout'] = value_
        span = span[3:]
        return ReadConnectionAcceptTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.conn_accept_timeout > 65535:
            print(f"Invalid value for field ReadConnectionAcceptTimeoutComplete::conn_accept_timeout: {self.conn_accept_timeout} > 65535; the value will be truncated")
            self.conn_accept_timeout &= 65535
        _span.extend(int.to_bytes((self.conn_accept_timeout << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class WriteConnectionAcceptTimeout(Command):
    conn_accept_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_CONNECTION_ACCEPT_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteConnectionAcceptTimeout', bytes]:
        if fields['op_code'] != OpCode.WRITE_CONNECTION_ACCEPT_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['conn_accept_timeout'] = value_
        span = span[2:]
        return WriteConnectionAcceptTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.conn_accept_timeout > 65535:
            print(f"Invalid value for field WriteConnectionAcceptTimeout::conn_accept_timeout: {self.conn_accept_timeout} > 65535; the value will be truncated")
            self.conn_accept_timeout &= 65535
        _span.extend(int.to_bytes((self.conn_accept_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteConnectionAcceptTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_CONNECTION_ACCEPT_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteConnectionAcceptTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_CONNECTION_ACCEPT_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteConnectionAcceptTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadPageTimeout(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_PAGE_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPageTimeout', bytes]:
        if fields['op_code'] != OpCode.READ_PAGE_TIMEOUT:
            raise Exception("Invalid constraint field values")
        return ReadPageTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadPageTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    page_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_PAGE_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPageTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_PAGE_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['page_timeout'] = value_
        span = span[3:]
        return ReadPageTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.page_timeout > 65535:
            print(f"Invalid value for field ReadPageTimeoutComplete::page_timeout: {self.page_timeout} > 65535; the value will be truncated")
            self.page_timeout &= 65535
        _span.extend(int.to_bytes((self.page_timeout << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class WritePageTimeout(Command):
    page_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_PAGE_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePageTimeout', bytes]:
        if fields['op_code'] != OpCode.WRITE_PAGE_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['page_timeout'] = value_
        span = span[2:]
        return WritePageTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.page_timeout > 65535:
            print(f"Invalid value for field WritePageTimeout::page_timeout: {self.page_timeout} > 65535; the value will be truncated")
            self.page_timeout &= 65535
        _span.extend(int.to_bytes((self.page_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WritePageTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_PAGE_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePageTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_PAGE_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WritePageTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class ScanEnable(enum.IntEnum):
    NO_SCANS = 0x0
    INQUIRY_SCAN_ONLY = 0x1
    PAGE_SCAN_ONLY = 0x2
    INQUIRY_AND_PAGE_SCAN = 0x3

@dataclass
class ReadScanEnable(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_SCAN_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadScanEnable', bytes]:
        if fields['op_code'] != OpCode.READ_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        return ReadScanEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadScanEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    scan_enable: ScanEnable = field(kw_only=True, default=ScanEnable.NO_SCANS)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_SCAN_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadScanEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['scan_enable'] = ScanEnable(span[1])
        span = span[2:]
        return ReadScanEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.scan_enable << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteScanEnable(Command):
    scan_enable: ScanEnable = field(kw_only=True, default=ScanEnable.NO_SCANS)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_SCAN_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteScanEnable', bytes]:
        if fields['op_code'] != OpCode.WRITE_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['scan_enable'] = ScanEnable(span[0])
        span = span[1:]
        return WriteScanEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.scan_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteScanEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_SCAN_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteScanEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteScanEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadPageScanActivity(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_PAGE_SCAN_ACTIVITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPageScanActivity', bytes]:
        if fields['op_code'] != OpCode.READ_PAGE_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        return ReadPageScanActivity(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadPageScanActivityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    page_scan_interval: int = field(kw_only=True, default=0)
    page_scan_window: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_PAGE_SCAN_ACTIVITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPageScanActivityComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_PAGE_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['page_scan_interval'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['page_scan_window'] = value_
        span = span[5:]
        return ReadPageScanActivityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.page_scan_interval > 65535:
            print(f"Invalid value for field ReadPageScanActivityComplete::page_scan_interval: {self.page_scan_interval} > 65535; the value will be truncated")
            self.page_scan_interval &= 65535
        _span.extend(int.to_bytes((self.page_scan_interval << 0), length=2, byteorder='little'))
        if self.page_scan_window > 65535:
            print(f"Invalid value for field ReadPageScanActivityComplete::page_scan_window: {self.page_scan_window} > 65535; the value will be truncated")
            self.page_scan_window &= 65535
        _span.extend(int.to_bytes((self.page_scan_window << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class WritePageScanActivity(Command):
    page_scan_interval: int = field(kw_only=True, default=0)
    page_scan_window: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_PAGE_SCAN_ACTIVITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePageScanActivity', bytes]:
        if fields['op_code'] != OpCode.WRITE_PAGE_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['page_scan_interval'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['page_scan_window'] = value_
        span = span[4:]
        return WritePageScanActivity(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.page_scan_interval > 65535:
            print(f"Invalid value for field WritePageScanActivity::page_scan_interval: {self.page_scan_interval} > 65535; the value will be truncated")
            self.page_scan_interval &= 65535
        _span.extend(int.to_bytes((self.page_scan_interval << 0), length=2, byteorder='little'))
        if self.page_scan_window > 65535:
            print(f"Invalid value for field WritePageScanActivity::page_scan_window: {self.page_scan_window} > 65535; the value will be truncated")
            self.page_scan_window &= 65535
        _span.extend(int.to_bytes((self.page_scan_window << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class WritePageScanActivityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_PAGE_SCAN_ACTIVITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePageScanActivityComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_PAGE_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WritePageScanActivityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadInquiryScanActivity(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_INQUIRY_SCAN_ACTIVITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryScanActivity', bytes]:
        if fields['op_code'] != OpCode.READ_INQUIRY_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        return ReadInquiryScanActivity(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadInquiryScanActivityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    inquiry_scan_interval: int = field(kw_only=True, default=0)
    inquiry_scan_window: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_INQUIRY_SCAN_ACTIVITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryScanActivityComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_INQUIRY_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['inquiry_scan_interval'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['inquiry_scan_window'] = value_
        span = span[5:]
        return ReadInquiryScanActivityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.inquiry_scan_interval > 65535:
            print(f"Invalid value for field ReadInquiryScanActivityComplete::inquiry_scan_interval: {self.inquiry_scan_interval} > 65535; the value will be truncated")
            self.inquiry_scan_interval &= 65535
        _span.extend(int.to_bytes((self.inquiry_scan_interval << 0), length=2, byteorder='little'))
        if self.inquiry_scan_window > 65535:
            print(f"Invalid value for field ReadInquiryScanActivityComplete::inquiry_scan_window: {self.inquiry_scan_window} > 65535; the value will be truncated")
            self.inquiry_scan_window &= 65535
        _span.extend(int.to_bytes((self.inquiry_scan_window << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class WriteInquiryScanActivity(Command):
    inquiry_scan_interval: int = field(kw_only=True, default=0)
    inquiry_scan_window: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_INQUIRY_SCAN_ACTIVITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryScanActivity', bytes]:
        if fields['op_code'] != OpCode.WRITE_INQUIRY_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['inquiry_scan_interval'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['inquiry_scan_window'] = value_
        span = span[4:]
        return WriteInquiryScanActivity(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.inquiry_scan_interval > 65535:
            print(f"Invalid value for field WriteInquiryScanActivity::inquiry_scan_interval: {self.inquiry_scan_interval} > 65535; the value will be truncated")
            self.inquiry_scan_interval &= 65535
        _span.extend(int.to_bytes((self.inquiry_scan_interval << 0), length=2, byteorder='little'))
        if self.inquiry_scan_window > 65535:
            print(f"Invalid value for field WriteInquiryScanActivity::inquiry_scan_window: {self.inquiry_scan_window} > 65535; the value will be truncated")
            self.inquiry_scan_window &= 65535
        _span.extend(int.to_bytes((self.inquiry_scan_window << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class WriteInquiryScanActivityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_INQUIRY_SCAN_ACTIVITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryScanActivityComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_INQUIRY_SCAN_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteInquiryScanActivityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class AuthenticationEnable(enum.IntEnum):
    NOT_REQUIRED = 0x0
    REQUIRED = 0x1

@dataclass
class ReadAuthenticationEnable(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_AUTHENTICATION_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAuthenticationEnable', bytes]:
        if fields['op_code'] != OpCode.READ_AUTHENTICATION_ENABLE:
            raise Exception("Invalid constraint field values")
        return ReadAuthenticationEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadAuthenticationEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    authentication_enable: AuthenticationEnable = field(kw_only=True, default=AuthenticationEnable.NOT_REQUIRED)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_AUTHENTICATION_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAuthenticationEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_AUTHENTICATION_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['authentication_enable'] = AuthenticationEnable(span[1])
        span = span[2:]
        return ReadAuthenticationEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.authentication_enable << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteAuthenticationEnable(Command):
    authentication_enable: AuthenticationEnable = field(kw_only=True, default=AuthenticationEnable.NOT_REQUIRED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_AUTHENTICATION_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteAuthenticationEnable', bytes]:
        if fields['op_code'] != OpCode.WRITE_AUTHENTICATION_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['authentication_enable'] = AuthenticationEnable(span[0])
        span = span[1:]
        return WriteAuthenticationEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.authentication_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteAuthenticationEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_AUTHENTICATION_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteAuthenticationEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_AUTHENTICATION_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteAuthenticationEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadClassOfDevice(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_CLASS_OF_DEVICE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadClassOfDevice', bytes]:
        if fields['op_code'] != OpCode.READ_CLASS_OF_DEVICE:
            raise Exception("Invalid constraint field values")
        return ReadClassOfDevice(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadClassOfDeviceComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    class_of_device: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_CLASS_OF_DEVICE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadClassOfDeviceComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_CLASS_OF_DEVICE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:4], byteorder='little')
        fields['class_of_device'] = value_
        span = span[4:]
        return ReadClassOfDeviceComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.class_of_device > 16777215:
            print(f"Invalid value for field ReadClassOfDeviceComplete::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class WriteClassOfDevice(Command):
    class_of_device: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_CLASS_OF_DEVICE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteClassOfDevice', bytes]:
        if fields['op_code'] != OpCode.WRITE_CLASS_OF_DEVICE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:3], byteorder='little')
        fields['class_of_device'] = value_
        span = span[3:]
        return WriteClassOfDevice(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.class_of_device > 16777215:
            print(f"Invalid value for field WriteClassOfDevice::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class WriteClassOfDeviceComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_CLASS_OF_DEVICE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteClassOfDeviceComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_CLASS_OF_DEVICE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteClassOfDeviceComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadVoiceSetting(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_VOICE_SETTING

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadVoiceSetting', bytes]:
        if fields['op_code'] != OpCode.READ_VOICE_SETTING:
            raise Exception("Invalid constraint field values")
        return ReadVoiceSetting(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadVoiceSettingComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    voice_setting: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_VOICE_SETTING
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadVoiceSettingComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_VOICE_SETTING:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['voice_setting'] = (value_ >> 0) & 0x3ff
        span = span[3:]
        return ReadVoiceSettingComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.voice_setting > 1023:
            print(f"Invalid value for field ReadVoiceSettingComplete::voice_setting: {self.voice_setting} > 1023; the value will be truncated")
            self.voice_setting &= 1023
        _span.extend(int.to_bytes((self.voice_setting << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class WriteVoiceSetting(Command):
    voice_setting: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_VOICE_SETTING

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteVoiceSetting', bytes]:
        if fields['op_code'] != OpCode.WRITE_VOICE_SETTING:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['voice_setting'] = (value_ >> 0) & 0x3ff
        span = span[2:]
        return WriteVoiceSetting(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.voice_setting > 1023:
            print(f"Invalid value for field WriteVoiceSetting::voice_setting: {self.voice_setting} > 1023; the value will be truncated")
            self.voice_setting &= 1023
        _span.extend(int.to_bytes((self.voice_setting << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteVoiceSettingComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_VOICE_SETTING
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteVoiceSettingComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_VOICE_SETTING:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteVoiceSettingComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadAutomaticFlushTimeout(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_AUTOMATIC_FLUSH_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAutomaticFlushTimeout', bytes]:
        if fields['op_code'] != OpCode.READ_AUTOMATIC_FLUSH_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadAutomaticFlushTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadAutomaticFlushTimeout::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadAutomaticFlushTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    flush_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_AUTOMATIC_FLUSH_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAutomaticFlushTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_AUTOMATIC_FLUSH_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['flush_timeout'] = value_
        span = span[5:]
        return ReadAutomaticFlushTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadAutomaticFlushTimeoutComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.flush_timeout > 65535:
            print(f"Invalid value for field ReadAutomaticFlushTimeoutComplete::flush_timeout: {self.flush_timeout} > 65535; the value will be truncated")
            self.flush_timeout &= 65535
        _span.extend(int.to_bytes((self.flush_timeout << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class WriteAutomaticFlushTimeout(Command):
    connection_handle: int = field(kw_only=True, default=0)
    flush_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_AUTOMATIC_FLUSH_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteAutomaticFlushTimeout', bytes]:
        if fields['op_code'] != OpCode.WRITE_AUTOMATIC_FLUSH_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['flush_timeout'] = value_
        span = span[4:]
        return WriteAutomaticFlushTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field WriteAutomaticFlushTimeout::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.flush_timeout > 65535:
            print(f"Invalid value for field WriteAutomaticFlushTimeout::flush_timeout: {self.flush_timeout} > 65535; the value will be truncated")
            self.flush_timeout &= 65535
        _span.extend(int.to_bytes((self.flush_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class WriteAutomaticFlushTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_AUTOMATIC_FLUSH_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteAutomaticFlushTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_AUTOMATIC_FLUSH_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return WriteAutomaticFlushTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field WriteAutomaticFlushTimeoutComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadNumBroadcastRetransmits(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_NUM_BROADCAST_RETRANSMITS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadNumBroadcastRetransmits', bytes]:
        if fields['op_code'] != OpCode.READ_NUM_BROADCAST_RETRANSMITS:
            raise Exception("Invalid constraint field values")
        return ReadNumBroadcastRetransmits(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadNumBroadcastRetransmitsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    num_broadcast_retransmissions: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_NUM_BROADCAST_RETRANSMITS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadNumBroadcastRetransmitsComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_NUM_BROADCAST_RETRANSMITS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['num_broadcast_retransmissions'] = span[1]
        span = span[2:]
        return ReadNumBroadcastRetransmitsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.num_broadcast_retransmissions > 255:
            print(f"Invalid value for field ReadNumBroadcastRetransmitsComplete::num_broadcast_retransmissions: {self.num_broadcast_retransmissions} > 255; the value will be truncated")
            self.num_broadcast_retransmissions &= 255
        _span.append((self.num_broadcast_retransmissions << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteNumBroadcastRetransmits(Command):
    num_broadcast_retransmissions: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_NUM_BROADCAST_RETRANSMITS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteNumBroadcastRetransmits', bytes]:
        if fields['op_code'] != OpCode.WRITE_NUM_BROADCAST_RETRANSMITS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['num_broadcast_retransmissions'] = span[0]
        span = span[1:]
        return WriteNumBroadcastRetransmits(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.num_broadcast_retransmissions > 255:
            print(f"Invalid value for field WriteNumBroadcastRetransmits::num_broadcast_retransmissions: {self.num_broadcast_retransmissions} > 255; the value will be truncated")
            self.num_broadcast_retransmissions &= 255
        _span.append((self.num_broadcast_retransmissions << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteNumBroadcastRetransmitsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_NUM_BROADCAST_RETRANSMITS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteNumBroadcastRetransmitsComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_NUM_BROADCAST_RETRANSMITS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteNumBroadcastRetransmitsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class HoldModeActivity(enum.IntEnum):
    MAINTAIN_CURRENT_POWER_STATE = 0x0
    SUSPEND_PAGE_SCAN = 0x1
    SUSPEND_INQUIRY_SCAN = 0x2
    SUSPEND_PERIODIC_INQUIRY = 0x3

@dataclass
class ReadHoldModeActivity(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_HOLD_MODE_ACTIVITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadHoldModeActivity', bytes]:
        if fields['op_code'] != OpCode.READ_HOLD_MODE_ACTIVITY:
            raise Exception("Invalid constraint field values")
        return ReadHoldModeActivity(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadHoldModeActivityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    hold_mode_activity: HoldModeActivity = field(kw_only=True, default=HoldModeActivity.MAINTAIN_CURRENT_POWER_STATE)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_HOLD_MODE_ACTIVITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadHoldModeActivityComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_HOLD_MODE_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['hold_mode_activity'] = HoldModeActivity(span[1])
        span = span[2:]
        return ReadHoldModeActivityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.hold_mode_activity << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteHoldModeActivity(Command):
    hold_mode_activity: HoldModeActivity = field(kw_only=True, default=HoldModeActivity.MAINTAIN_CURRENT_POWER_STATE)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_HOLD_MODE_ACTIVITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteHoldModeActivity', bytes]:
        if fields['op_code'] != OpCode.WRITE_HOLD_MODE_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['hold_mode_activity'] = HoldModeActivity(span[0])
        span = span[1:]
        return WriteHoldModeActivity(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.hold_mode_activity << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteHoldModeActivityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_HOLD_MODE_ACTIVITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteHoldModeActivityComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_HOLD_MODE_ACTIVITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteHoldModeActivityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class TransmitPowerLevelType(enum.IntEnum):
    CURRENT = 0x0
    MAXIMUM = 0x1

@dataclass
class ReadTransmitPowerLevel(Command):
    connection_handle: int = field(kw_only=True, default=0)
    transmit_power_level_type: TransmitPowerLevelType = field(kw_only=True, default=TransmitPowerLevelType.CURRENT)

    def __post_init__(self):
        self.op_code = OpCode.READ_TRANSMIT_POWER_LEVEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadTransmitPowerLevel', bytes]:
        if fields['op_code'] != OpCode.READ_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['transmit_power_level_type'] = TransmitPowerLevelType(span[2])
        span = span[3:]
        return ReadTransmitPowerLevel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadTransmitPowerLevel::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.transmit_power_level_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadTransmitPowerLevelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    transmit_power_level: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_TRANSMIT_POWER_LEVEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadTransmitPowerLevelComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['transmit_power_level'] = span[3]
        span = span[4:]
        return ReadTransmitPowerLevelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadTransmitPowerLevelComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.transmit_power_level > 255:
            print(f"Invalid value for field ReadTransmitPowerLevelComplete::transmit_power_level: {self.transmit_power_level} > 255; the value will be truncated")
            self.transmit_power_level &= 255
        _span.append((self.transmit_power_level << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class ReadSynchronousFlowControlEnable(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadSynchronousFlowControlEnable', bytes]:
        if fields['op_code'] != OpCode.READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE:
            raise Exception("Invalid constraint field values")
        return ReadSynchronousFlowControlEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadSynchronousFlowControlEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadSynchronousFlowControlEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['enable'] = Enable(span[1])
        span = span[2:]
        return ReadSynchronousFlowControlEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.enable << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteSynchronousFlowControlEnable(Command):
    enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSynchronousFlowControlEnable', bytes]:
        if fields['op_code'] != OpCode.WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['enable'] = Enable(span[0])
        span = span[1:]
        return WriteSynchronousFlowControlEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteSynchronousFlowControlEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSynchronousFlowControlEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteSynchronousFlowControlEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class SetControllerToHostFlowControl(Command):
    acl: int = field(kw_only=True, default=0)
    synchronous: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SET_CONTROLLER_TO_HOST_FLOW_CONTROL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetControllerToHostFlowControl', bytes]:
        if fields['op_code'] != OpCode.SET_CONTROLLER_TO_HOST_FLOW_CONTROL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['acl'] = (span[0] >> 0) & 0x1
        fields['synchronous'] = (span[0] >> 1) & 0x1
        span = span[1:]
        return SetControllerToHostFlowControl(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.acl > 1:
            print(f"Invalid value for field SetControllerToHostFlowControl::acl: {self.acl} > 1; the value will be truncated")
            self.acl &= 1
        if self.synchronous > 1:
            print(f"Invalid value for field SetControllerToHostFlowControl::synchronous: {self.synchronous} > 1; the value will be truncated")
            self.synchronous &= 1
        _value = (
            (self.acl << 0) |
            (self.synchronous << 1)
        )
        _span.append(_value)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class SetControllerToHostFlowControlComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.SET_CONTROLLER_TO_HOST_FLOW_CONTROL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetControllerToHostFlowControlComplete', bytes]:
        if fields['command_op_code'] != OpCode.SET_CONTROLLER_TO_HOST_FLOW_CONTROL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return SetControllerToHostFlowControlComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class HostBufferSize(Command):
    host_acl_data_packet_length: int = field(kw_only=True, default=0)
    host_synchronous_data_packet_length: int = field(kw_only=True, default=0)
    host_total_num_acl_data_packets: int = field(kw_only=True, default=0)
    host_total_num_synchronous_data_packets: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.HOST_BUFFER_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['HostBufferSize', bytes]:
        if fields['op_code'] != OpCode.HOST_BUFFER_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['host_acl_data_packet_length'] = value_
        fields['host_synchronous_data_packet_length'] = span[2]
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['host_total_num_acl_data_packets'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['host_total_num_synchronous_data_packets'] = value_
        span = span[7:]
        return HostBufferSize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.host_acl_data_packet_length > 65535:
            print(f"Invalid value for field HostBufferSize::host_acl_data_packet_length: {self.host_acl_data_packet_length} > 65535; the value will be truncated")
            self.host_acl_data_packet_length &= 65535
        _span.extend(int.to_bytes((self.host_acl_data_packet_length << 0), length=2, byteorder='little'))
        if self.host_synchronous_data_packet_length > 255:
            print(f"Invalid value for field HostBufferSize::host_synchronous_data_packet_length: {self.host_synchronous_data_packet_length} > 255; the value will be truncated")
            self.host_synchronous_data_packet_length &= 255
        _span.append((self.host_synchronous_data_packet_length << 0))
        if self.host_total_num_acl_data_packets > 65535:
            print(f"Invalid value for field HostBufferSize::host_total_num_acl_data_packets: {self.host_total_num_acl_data_packets} > 65535; the value will be truncated")
            self.host_total_num_acl_data_packets &= 65535
        _span.extend(int.to_bytes((self.host_total_num_acl_data_packets << 0), length=2, byteorder='little'))
        if self.host_total_num_synchronous_data_packets > 65535:
            print(f"Invalid value for field HostBufferSize::host_total_num_synchronous_data_packets: {self.host_total_num_synchronous_data_packets} > 65535; the value will be truncated")
            self.host_total_num_synchronous_data_packets &= 65535
        _span.extend(int.to_bytes((self.host_total_num_synchronous_data_packets << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class HostBufferSizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.HOST_BUFFER_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['HostBufferSizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.HOST_BUFFER_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return HostBufferSizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class CompletedPackets(Packet):
    connection_handle: int = field(kw_only=True, default=0)
    host_num_of_completed_packets: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CompletedPackets', bytes]:
        fields = {'payload': None}
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['host_num_of_completed_packets'] = value_
        span = span[4:]
        return CompletedPackets(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field CompletedPackets::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.host_num_of_completed_packets > 65535:
            print(f"Invalid value for field CompletedPackets::host_num_of_completed_packets: {self.host_num_of_completed_packets} > 65535; the value will be truncated")
            self.host_num_of_completed_packets &= 65535
        _span.extend(int.to_bytes((self.host_num_of_completed_packets << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 4

@dataclass
class HostNumCompletedPackets(Command):
    completed_packets: List[CompletedPackets] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.HOST_NUMBER_OF_COMPLETED_PACKETS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['HostNumCompletedPackets', bytes]:
        if fields['op_code'] != OpCode.HOST_NUMBER_OF_COMPLETED_PACKETS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        completed_packets_count = span[0]
        span = span[1:]
        if len(span) < completed_packets_count * 4:
            raise Exception('Invalid packet size')
        completed_packets = []
        for n in range(completed_packets_count):
            completed_packets.append(CompletedPackets.parse_all(span[n * 4:(n + 1) * 4]))
        fields['completed_packets'] = completed_packets
        span = span[completed_packets_count * 4:]
        return HostNumCompletedPackets(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.completed_packets) > 255:
            print(f"Invalid length for field HostNumCompletedPackets::completed_packets:  {len(self.completed_packets)} > 255; the array will be truncated")
            del self.completed_packets[255:]
        _span.append((len(self.completed_packets) << 0))
        for _elt in self.completed_packets:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.completed_packets]) + 1

@dataclass
class HostNumCompletedPacketsError(CommandComplete):
    error_code: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.HOST_NUMBER_OF_COMPLETED_PACKETS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['HostNumCompletedPacketsError', bytes]:
        if fields['command_op_code'] != OpCode.HOST_NUMBER_OF_COMPLETED_PACKETS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['error_code'] = ErrorCode(span[0])
        span = span[1:]
        return HostNumCompletedPacketsError(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.error_code << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadLinkSupervisionTimeout(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_LINK_SUPERVISION_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLinkSupervisionTimeout', bytes]:
        if fields['op_code'] != OpCode.READ_LINK_SUPERVISION_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadLinkSupervisionTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLinkSupervisionTimeout::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadLinkSupervisionTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    link_supervision_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LINK_SUPERVISION_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLinkSupervisionTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LINK_SUPERVISION_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['link_supervision_timeout'] = value_
        span = span[5:]
        return ReadLinkSupervisionTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLinkSupervisionTimeoutComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.link_supervision_timeout > 65535:
            print(f"Invalid value for field ReadLinkSupervisionTimeoutComplete::link_supervision_timeout: {self.link_supervision_timeout} > 65535; the value will be truncated")
            self.link_supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.link_supervision_timeout << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class WriteLinkSupervisionTimeout(Command):
    connection_handle: int = field(kw_only=True, default=0)
    link_supervision_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_LINK_SUPERVISION_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLinkSupervisionTimeout', bytes]:
        if fields['op_code'] != OpCode.WRITE_LINK_SUPERVISION_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['link_supervision_timeout'] = value_
        span = span[4:]
        return WriteLinkSupervisionTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field WriteLinkSupervisionTimeout::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.link_supervision_timeout > 65535:
            print(f"Invalid value for field WriteLinkSupervisionTimeout::link_supervision_timeout: {self.link_supervision_timeout} > 65535; the value will be truncated")
            self.link_supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.link_supervision_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class WriteLinkSupervisionTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_LINK_SUPERVISION_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLinkSupervisionTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_LINK_SUPERVISION_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return WriteLinkSupervisionTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field WriteLinkSupervisionTimeoutComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadNumberOfSupportedIac(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_NUMBER_OF_SUPPORTED_IAC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadNumberOfSupportedIac', bytes]:
        if fields['op_code'] != OpCode.READ_NUMBER_OF_SUPPORTED_IAC:
            raise Exception("Invalid constraint field values")
        return ReadNumberOfSupportedIac(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadNumberOfSupportedIacComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    num_support_iac: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_NUMBER_OF_SUPPORTED_IAC
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadNumberOfSupportedIacComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_NUMBER_OF_SUPPORTED_IAC:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['num_support_iac'] = span[1]
        span = span[2:]
        return ReadNumberOfSupportedIacComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.num_support_iac > 255:
            print(f"Invalid value for field ReadNumberOfSupportedIacComplete::num_support_iac: {self.num_support_iac} > 255; the value will be truncated")
            self.num_support_iac &= 255
        _span.append((self.num_support_iac << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadCurrentIacLap(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_CURRENT_IAC_LAP

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadCurrentIacLap', bytes]:
        if fields['op_code'] != OpCode.READ_CURRENT_IAC_LAP:
            raise Exception("Invalid constraint field values")
        return ReadCurrentIacLap(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadCurrentIacLapComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    laps_to_read: List[Lap] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_CURRENT_IAC_LAP
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadCurrentIacLapComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_CURRENT_IAC_LAP:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        laps_to_read_count = span[1]
        span = span[2:]
        if len(span) < laps_to_read_count * 3:
            raise Exception('Invalid packet size')
        laps_to_read = []
        for n in range(laps_to_read_count):
            laps_to_read.append(Lap.parse_all(span[n * 3:(n + 1) * 3]))
        fields['laps_to_read'] = laps_to_read
        span = span[laps_to_read_count * 3:]
        return ReadCurrentIacLapComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if len(self.laps_to_read) > 255:
            print(f"Invalid length for field ReadCurrentIacLapComplete::laps_to_read:  {len(self.laps_to_read)} > 255; the array will be truncated")
            del self.laps_to_read[255:]
        _span.append((len(self.laps_to_read) << 0))
        for _elt in self.laps_to_read:
            _span.extend(_elt.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.laps_to_read]) + 2

@dataclass
class WriteCurrentIacLap(Command):
    laps_to_write: List[Lap] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_CURRENT_IAC_LAP

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteCurrentIacLap', bytes]:
        if fields['op_code'] != OpCode.WRITE_CURRENT_IAC_LAP:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        laps_to_write_count = span[0]
        span = span[1:]
        if len(span) < laps_to_write_count * 3:
            raise Exception('Invalid packet size')
        laps_to_write = []
        for n in range(laps_to_write_count):
            laps_to_write.append(Lap.parse_all(span[n * 3:(n + 1) * 3]))
        fields['laps_to_write'] = laps_to_write
        span = span[laps_to_write_count * 3:]
        return WriteCurrentIacLap(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.laps_to_write) > 255:
            print(f"Invalid length for field WriteCurrentIacLap::laps_to_write:  {len(self.laps_to_write)} > 255; the array will be truncated")
            del self.laps_to_write[255:]
        _span.append((len(self.laps_to_write) << 0))
        for _elt in self.laps_to_write:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.laps_to_write]) + 1

@dataclass
class WriteCurrentIacLapComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_CURRENT_IAC_LAP
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteCurrentIacLapComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_CURRENT_IAC_LAP:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteCurrentIacLapComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class SetAfhHostChannelClassification(Command):
    afh_host_channel_classification: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.SET_AFH_HOST_CHANNEL_CLASSIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetAfhHostChannelClassification', bytes]:
        if fields['op_code'] != OpCode.SET_AFH_HOST_CHANNEL_CLASSIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['afh_host_channel_classification'] = list(span[:10])
        span = span[10:]
        return SetAfhHostChannelClassification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.afh_host_channel_classification)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class SetAfhHostChannelClassificationComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.SET_AFH_HOST_CHANNEL_CLASSIFICATION
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetAfhHostChannelClassificationComplete', bytes]:
        if fields['command_op_code'] != OpCode.SET_AFH_HOST_CHANNEL_CLASSIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return SetAfhHostChannelClassificationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class InquiryScanType(enum.IntEnum):
    STANDARD = 0x0
    INTERLACED = 0x1

@dataclass
class ReadInquiryScanType(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_INQUIRY_SCAN_TYPE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryScanType', bytes]:
        if fields['op_code'] != OpCode.READ_INQUIRY_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        return ReadInquiryScanType(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadInquiryScanTypeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    inquiry_scan_type: InquiryScanType = field(kw_only=True, default=InquiryScanType.STANDARD)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_INQUIRY_SCAN_TYPE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryScanTypeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_INQUIRY_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['inquiry_scan_type'] = InquiryScanType(span[1])
        span = span[2:]
        return ReadInquiryScanTypeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.inquiry_scan_type << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteInquiryScanType(Command):
    inquiry_scan_type: InquiryScanType = field(kw_only=True, default=InquiryScanType.STANDARD)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_INQUIRY_SCAN_TYPE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryScanType', bytes]:
        if fields['op_code'] != OpCode.WRITE_INQUIRY_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['inquiry_scan_type'] = InquiryScanType(span[0])
        span = span[1:]
        return WriteInquiryScanType(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.inquiry_scan_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteInquiryScanTypeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_INQUIRY_SCAN_TYPE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryScanTypeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_INQUIRY_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteInquiryScanTypeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class InquiryMode(enum.IntEnum):
    STANDARD = 0x0
    RSSI = 0x1
    RSSI_OR_EXTENDED = 0x2

@dataclass
class ReadInquiryMode(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_INQUIRY_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryMode', bytes]:
        if fields['op_code'] != OpCode.READ_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        return ReadInquiryMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadInquiryModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    inquiry_mode: InquiryMode = field(kw_only=True, default=InquiryMode.STANDARD)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_INQUIRY_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['inquiry_mode'] = InquiryMode(span[1])
        span = span[2:]
        return ReadInquiryModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.inquiry_mode << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteInquiryMode(Command):
    inquiry_mode: InquiryMode = field(kw_only=True, default=InquiryMode.STANDARD)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_INQUIRY_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryMode', bytes]:
        if fields['op_code'] != OpCode.WRITE_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['inquiry_mode'] = InquiryMode(span[0])
        span = span[1:]
        return WriteInquiryMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.inquiry_mode << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteInquiryModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_INQUIRY_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_INQUIRY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteInquiryModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class PageScanType(enum.IntEnum):
    STANDARD = 0x0
    INTERLACED = 0x1

@dataclass
class ReadPageScanType(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_PAGE_SCAN_TYPE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPageScanType', bytes]:
        if fields['op_code'] != OpCode.READ_PAGE_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        return ReadPageScanType(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadPageScanTypeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    page_scan_type: PageScanType = field(kw_only=True, default=PageScanType.STANDARD)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_PAGE_SCAN_TYPE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadPageScanTypeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_PAGE_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['page_scan_type'] = PageScanType(span[1])
        span = span[2:]
        return ReadPageScanTypeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.page_scan_type << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WritePageScanType(Command):
    page_scan_type: PageScanType = field(kw_only=True, default=PageScanType.STANDARD)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_PAGE_SCAN_TYPE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePageScanType', bytes]:
        if fields['op_code'] != OpCode.WRITE_PAGE_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['page_scan_type'] = PageScanType(span[0])
        span = span[1:]
        return WritePageScanType(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.page_scan_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WritePageScanTypeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_PAGE_SCAN_TYPE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WritePageScanTypeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_PAGE_SCAN_TYPE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WritePageScanTypeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadAfhChannelAssessmentMode(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_AFH_CHANNEL_ASSESSMENT_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAfhChannelAssessmentMode', bytes]:
        if fields['op_code'] != OpCode.READ_AFH_CHANNEL_ASSESSMENT_MODE:
            raise Exception("Invalid constraint field values")
        return ReadAfhChannelAssessmentMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadAfhChannelAssessmentModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    controller_channel_assessment: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_AFH_CHANNEL_ASSESSMENT_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAfhChannelAssessmentModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_AFH_CHANNEL_ASSESSMENT_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['controller_channel_assessment'] = Enable(span[1])
        span = span[2:]
        return ReadAfhChannelAssessmentModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.controller_channel_assessment << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteAfhChannelAssessmentMode(Command):
    controller_channel_assessment: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_AFH_CHANNEL_ASSESSMENT_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteAfhChannelAssessmentMode', bytes]:
        if fields['op_code'] != OpCode.WRITE_AFH_CHANNEL_ASSESSMENT_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['controller_channel_assessment'] = Enable(span[0])
        span = span[1:]
        return WriteAfhChannelAssessmentMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.controller_channel_assessment << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteAfhChannelAssessmentModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_AFH_CHANNEL_ASSESSMENT_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteAfhChannelAssessmentModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_AFH_CHANNEL_ASSESSMENT_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteAfhChannelAssessmentModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class FecRequired(enum.IntEnum):
    NOT_REQUIRED = 0x0
    REQUIRED = 0x1

@dataclass
class ReadExtendedInquiryResponse(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_EXTENDED_INQUIRY_RESPONSE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadExtendedInquiryResponse', bytes]:
        if fields['op_code'] != OpCode.READ_EXTENDED_INQUIRY_RESPONSE:
            raise Exception("Invalid constraint field values")
        return ReadExtendedInquiryResponse(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadExtendedInquiryResponseComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    fec_required: FecRequired = field(kw_only=True, default=FecRequired.NOT_REQUIRED)
    extended_inquiry_response: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_EXTENDED_INQUIRY_RESPONSE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadExtendedInquiryResponseComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_EXTENDED_INQUIRY_RESPONSE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['fec_required'] = FecRequired(span[1])
        span = span[2:]
        if len(span) < 240:
            raise Exception('Invalid packet size')
        fields['extended_inquiry_response'] = list(span[:240])
        span = span[240:]
        return ReadExtendedInquiryResponseComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.fec_required << 0))
        _span.extend(self.extended_inquiry_response)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 242

@dataclass
class WriteExtendedInquiryResponse(Command):
    fec_required: FecRequired = field(kw_only=True, default=FecRequired.NOT_REQUIRED)
    extended_inquiry_response: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_EXTENDED_INQUIRY_RESPONSE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteExtendedInquiryResponse', bytes]:
        if fields['op_code'] != OpCode.WRITE_EXTENDED_INQUIRY_RESPONSE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['fec_required'] = FecRequired(span[0])
        span = span[1:]
        if len(span) < 240:
            raise Exception('Invalid packet size')
        fields['extended_inquiry_response'] = list(span[:240])
        span = span[240:]
        return WriteExtendedInquiryResponse(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.fec_required << 0))
        _span.extend(self.extended_inquiry_response)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 241

@dataclass
class WriteExtendedInquiryResponseComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_EXTENDED_INQUIRY_RESPONSE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteExtendedInquiryResponseComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_EXTENDED_INQUIRY_RESPONSE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteExtendedInquiryResponseComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class RefreshEncryptionKey(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.REFRESH_ENCRYPTION_KEY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RefreshEncryptionKey', bytes]:
        if fields['op_code'] != OpCode.REFRESH_ENCRYPTION_KEY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return RefreshEncryptionKey(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field RefreshEncryptionKey::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class RefreshEncryptionKeyStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.REFRESH_ENCRYPTION_KEY
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RefreshEncryptionKeyStatus', bytes]:
        if fields['command_op_code'] != OpCode.REFRESH_ENCRYPTION_KEY:
            raise Exception("Invalid constraint field values")
        return RefreshEncryptionKeyStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadSimplePairingMode(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_SIMPLE_PAIRING_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadSimplePairingMode', bytes]:
        if fields['op_code'] != OpCode.READ_SIMPLE_PAIRING_MODE:
            raise Exception("Invalid constraint field values")
        return ReadSimplePairingMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadSimplePairingModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    simple_pairing_mode: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_SIMPLE_PAIRING_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadSimplePairingModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_SIMPLE_PAIRING_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['simple_pairing_mode'] = Enable(span[1])
        span = span[2:]
        return ReadSimplePairingModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.simple_pairing_mode << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteSimplePairingMode(Command):
    simple_pairing_mode: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_SIMPLE_PAIRING_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSimplePairingMode', bytes]:
        if fields['op_code'] != OpCode.WRITE_SIMPLE_PAIRING_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['simple_pairing_mode'] = Enable(span[0])
        span = span[1:]
        return WriteSimplePairingMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.simple_pairing_mode << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteSimplePairingModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_SIMPLE_PAIRING_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSimplePairingModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_SIMPLE_PAIRING_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteSimplePairingModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadLocalOobData(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_OOB_DATA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalOobData', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_OOB_DATA:
            raise Exception("Invalid constraint field values")
        return ReadLocalOobData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLocalOobDataComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    c: bytearray = field(kw_only=True, default_factory=bytearray)
    r: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_OOB_DATA
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalOobDataComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_OOB_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['c'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['r'] = list(span[:16])
        span = span[16:]
        return ReadLocalOobDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.c)
        _span.extend(self.r)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 33

@dataclass
class ReadInquiryResponseTransmitPowerLevel(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryResponseTransmitPowerLevel', bytes]:
        if fields['op_code'] != OpCode.READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        return ReadInquiryResponseTransmitPowerLevel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadInquiryResponseTransmitPowerLevelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    tx_power: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadInquiryResponseTransmitPowerLevelComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['tx_power'] = span[1]
        span = span[2:]
        return ReadInquiryResponseTransmitPowerLevelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.tx_power > 255:
            print(f"Invalid value for field ReadInquiryResponseTransmitPowerLevelComplete::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteInquiryTransmitPowerLevel(Command):
    tx_power: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_INQUIRY_TRANSMIT_POWER_LEVEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryTransmitPowerLevel', bytes]:
        if fields['op_code'] != OpCode.WRITE_INQUIRY_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['tx_power'] = span[0]
        span = span[1:]
        return WriteInquiryTransmitPowerLevel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.tx_power > 255:
            print(f"Invalid value for field WriteInquiryTransmitPowerLevel::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteInquiryResponseTransmitPowerLevelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_INQUIRY_TRANSMIT_POWER_LEVEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteInquiryResponseTransmitPowerLevelComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_INQUIRY_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteInquiryResponseTransmitPowerLevelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class KeypressNotificationType(enum.IntEnum):
    ENTRY_STARTED = 0x0
    DIGIT_ENTERED = 0x1
    DIGIT_ERASED = 0x2
    CLEARED = 0x3
    ENTRY_COMPLETED = 0x4

@dataclass
class SendKeypressNotification(Command):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    notification_type: KeypressNotificationType = field(kw_only=True, default=KeypressNotificationType.ENTRY_STARTED)

    def __post_init__(self):
        self.op_code = OpCode.SEND_KEYPRESS_NOTIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SendKeypressNotification', bytes]:
        if fields['op_code'] != OpCode.SEND_KEYPRESS_NOTIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['notification_type'] = KeypressNotificationType(span[6])
        span = span[7:]
        return SendKeypressNotification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.notification_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class SendKeypressNotificationComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.SEND_KEYPRESS_NOTIFICATION
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SendKeypressNotificationComplete', bytes]:
        if fields['command_op_code'] != OpCode.SEND_KEYPRESS_NOTIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return SendKeypressNotificationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class SetEventMaskPage2(Command):
    event_mask_page_2: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SET_EVENT_MASK_PAGE_2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventMaskPage2', bytes]:
        if fields['op_code'] != OpCode.SET_EVENT_MASK_PAGE_2:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:8], byteorder='little')
        fields['event_mask_page_2'] = value_
        span = span[8:]
        return SetEventMaskPage2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.event_mask_page_2 > 18446744073709551615:
            print(f"Invalid value for field SetEventMaskPage2::event_mask_page_2: {self.event_mask_page_2} > 18446744073709551615; the value will be truncated")
            self.event_mask_page_2 &= 18446744073709551615
        _span.extend(int.to_bytes((self.event_mask_page_2 << 0), length=8, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class SetEventMaskPage2Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.SET_EVENT_MASK_PAGE_2
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEventMaskPage2Complete', bytes]:
        if fields['command_op_code'] != OpCode.SET_EVENT_MASK_PAGE_2:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return SetEventMaskPage2Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadEnhancedTransmitPowerLevel(Command):
    connection_handle: int = field(kw_only=True, default=0)
    transmit_power_level_type: TransmitPowerLevelType = field(kw_only=True, default=TransmitPowerLevelType.CURRENT)

    def __post_init__(self):
        self.op_code = OpCode.READ_ENHANCED_TRANSMIT_POWER_LEVEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadEnhancedTransmitPowerLevel', bytes]:
        if fields['op_code'] != OpCode.READ_ENHANCED_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['transmit_power_level_type'] = TransmitPowerLevelType(span[2])
        span = span[3:]
        return ReadEnhancedTransmitPowerLevel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadEnhancedTransmitPowerLevel::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.transmit_power_level_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadEnhancedTransmitPowerLevelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    tx_power_level_gfsk: int = field(kw_only=True, default=0)
    tx_power_level_dqpsk: int = field(kw_only=True, default=0)
    tx_power_level_8dpsk: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_ENHANCED_TRANSMIT_POWER_LEVEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadEnhancedTransmitPowerLevelComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_ENHANCED_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['tx_power_level_gfsk'] = span[3]
        fields['tx_power_level_dqpsk'] = span[4]
        fields['tx_power_level_8dpsk'] = span[5]
        span = span[6:]
        return ReadEnhancedTransmitPowerLevelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadEnhancedTransmitPowerLevelComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.tx_power_level_gfsk > 255:
            print(f"Invalid value for field ReadEnhancedTransmitPowerLevelComplete::tx_power_level_gfsk: {self.tx_power_level_gfsk} > 255; the value will be truncated")
            self.tx_power_level_gfsk &= 255
        _span.append((self.tx_power_level_gfsk << 0))
        if self.tx_power_level_dqpsk > 255:
            print(f"Invalid value for field ReadEnhancedTransmitPowerLevelComplete::tx_power_level_dqpsk: {self.tx_power_level_dqpsk} > 255; the value will be truncated")
            self.tx_power_level_dqpsk &= 255
        _span.append((self.tx_power_level_dqpsk << 0))
        if self.tx_power_level_8dpsk > 255:
            print(f"Invalid value for field ReadEnhancedTransmitPowerLevelComplete::tx_power_level_8dpsk: {self.tx_power_level_8dpsk} > 255; the value will be truncated")
            self.tx_power_level_8dpsk &= 255
        _span.append((self.tx_power_level_8dpsk << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class ReadLeHostSupport(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LE_HOST_SUPPORT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLeHostSupport', bytes]:
        if fields['op_code'] != OpCode.READ_LE_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        return ReadLeHostSupport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLeHostSupportComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    le_supported_host: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LE_HOST_SUPPORT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLeHostSupportComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LE_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['le_supported_host'] = Enable(span[1])
        span = span[3:]
        return ReadLeHostSupportComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.le_supported_host << 0))
        _span.extend([0] * 1)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class WriteLeHostSupport(Command):
    le_supported_host: Enable = field(kw_only=True, default=Enable.DISABLED)
    simultaneous_le_host: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_LE_HOST_SUPPORT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLeHostSupport', bytes]:
        if fields['op_code'] != OpCode.WRITE_LE_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['le_supported_host'] = Enable(span[0])
        fields['simultaneous_le_host'] = Enable(span[1])
        span = span[2:]
        return WriteLeHostSupport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.le_supported_host << 0))
        _span.append((self.simultaneous_le_host << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteLeHostSupportComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_LE_HOST_SUPPORT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLeHostSupportComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_LE_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteLeHostSupportComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadSecureConnectionsHostSupport(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_SECURE_CONNECTIONS_HOST_SUPPORT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadSecureConnectionsHostSupport', bytes]:
        if fields['op_code'] != OpCode.READ_SECURE_CONNECTIONS_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        return ReadSecureConnectionsHostSupport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadSecureConnectionsHostSupportComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    secure_connections_host_support: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_SECURE_CONNECTIONS_HOST_SUPPORT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadSecureConnectionsHostSupportComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_SECURE_CONNECTIONS_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['secure_connections_host_support'] = Enable(span[1])
        span = span[2:]
        return ReadSecureConnectionsHostSupportComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.secure_connections_host_support << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteSecureConnectionsHostSupport(Command):
    secure_connections_host_support: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_SECURE_CONNECTIONS_HOST_SUPPORT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSecureConnectionsHostSupport', bytes]:
        if fields['op_code'] != OpCode.WRITE_SECURE_CONNECTIONS_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['secure_connections_host_support'] = Enable(span[0])
        span = span[1:]
        return WriteSecureConnectionsHostSupport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.secure_connections_host_support << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteSecureConnectionsHostSupportComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_SECURE_CONNECTIONS_HOST_SUPPORT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSecureConnectionsHostSupportComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_SECURE_CONNECTIONS_HOST_SUPPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteSecureConnectionsHostSupportComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadLocalOobExtendedData(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_OOB_EXTENDED_DATA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalOobExtendedData', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_OOB_EXTENDED_DATA:
            raise Exception("Invalid constraint field values")
        return ReadLocalOobExtendedData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLocalOobExtendedDataComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    c_192: bytearray = field(kw_only=True, default_factory=bytearray)
    r_192: bytearray = field(kw_only=True, default_factory=bytearray)
    c_256: bytearray = field(kw_only=True, default_factory=bytearray)
    r_256: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_OOB_EXTENDED_DATA
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalOobExtendedDataComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_OOB_EXTENDED_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['c_192'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['r_192'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['c_256'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['r_256'] = list(span[:16])
        span = span[16:]
        return ReadLocalOobExtendedDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.c_192)
        _span.extend(self.r_192)
        _span.extend(self.c_256)
        _span.extend(self.r_256)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 65

@dataclass
class SetEcosystemBaseInterval(Command):
    interval: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SET_ECOSYSTEM_BASE_INTERVAL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEcosystemBaseInterval', bytes]:
        if fields['op_code'] != OpCode.SET_ECOSYSTEM_BASE_INTERVAL:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['interval'] = value_
        span = span[2:]
        return SetEcosystemBaseInterval(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.interval > 65535:
            print(f"Invalid value for field SetEcosystemBaseInterval::interval: {self.interval} > 65535; the value will be truncated")
            self.interval &= 65535
        _span.extend(int.to_bytes((self.interval << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class SetEcosystemBaseIntervalComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.SET_ECOSYSTEM_BASE_INTERVAL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetEcosystemBaseIntervalComplete', bytes]:
        if fields['command_op_code'] != OpCode.SET_ECOSYSTEM_BASE_INTERVAL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return SetEcosystemBaseIntervalComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class DataPathDirection(enum.IntEnum):
    INPUT = 0x0
    OUTPUT = 0x1

@dataclass
class ConfigureDataPath(Command):
    data_path_direction: DataPathDirection = field(kw_only=True, default=DataPathDirection.INPUT)
    data_path_id: int = field(kw_only=True, default=0)
    vendor_specific_config: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.CONFIGURE_DATA_PATH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ConfigureDataPath', bytes]:
        if fields['op_code'] != OpCode.CONFIGURE_DATA_PATH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['data_path_direction'] = DataPathDirection(span[0])
        fields['data_path_id'] = span[1]
        vendor_specific_config_size = span[2]
        span = span[3:]
        if len(span) < vendor_specific_config_size:
            raise Exception('Invalid packet size')
        fields['vendor_specific_config'] = list(span[:vendor_specific_config_size])
        span = span[vendor_specific_config_size:]
        return ConfigureDataPath(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.data_path_direction << 0))
        if self.data_path_id > 255:
            print(f"Invalid value for field ConfigureDataPath::data_path_id: {self.data_path_id} > 255; the value will be truncated")
            self.data_path_id &= 255
        _span.append((self.data_path_id << 0))
        _span.append(((len(self.vendor_specific_config) * 1) << 0))
        _span.extend(self.vendor_specific_config)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.vendor_specific_config) * 1 + 3

@dataclass
class ConfigureDataPathComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.CONFIGURE_DATA_PATH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ConfigureDataPathComplete', bytes]:
        if fields['command_op_code'] != OpCode.CONFIGURE_DATA_PATH:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return ConfigureDataPathComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class SetMinEncryptionKeySize(Command):
    min_encryption_key_size: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.SET_MIN_ENCRYPTION_KEY_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetMinEncryptionKeySize', bytes]:
        if fields['op_code'] != OpCode.SET_MIN_ENCRYPTION_KEY_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['min_encryption_key_size'] = span[0]
        span = span[1:]
        return SetMinEncryptionKeySize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.min_encryption_key_size > 255:
            print(f"Invalid value for field SetMinEncryptionKeySize::min_encryption_key_size: {self.min_encryption_key_size} > 255; the value will be truncated")
            self.min_encryption_key_size &= 255
        _span.append((self.min_encryption_key_size << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class SetMinEncryptionKeySizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.SET_MIN_ENCRYPTION_KEY_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SetMinEncryptionKeySizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.SET_MIN_ENCRYPTION_KEY_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return SetMinEncryptionKeySizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ReadLocalVersionInformation(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_VERSION_INFORMATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalVersionInformation', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_VERSION_INFORMATION:
            raise Exception("Invalid constraint field values")
        return ReadLocalVersionInformation(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class HciVersion(enum.IntEnum):
    V_1_0B = 0x0
    V_1_1 = 0x1
    V_1_2 = 0x2
    V_2_0 = 0x3
    V_2_1 = 0x4
    V_3_0 = 0x5
    V_4_0 = 0x6
    V_4_1 = 0x7
    V_4_2 = 0x8
    V_5_0 = 0x9
    V_5_1 = 0xa
    V_5_2 = 0xb
    V_5_3 = 0xc
    V_5_4 = 0xd
    V_6_0 = 0xe

class LmpVersion(enum.IntEnum):
    V_1_0B = 0x0
    V_1_1 = 0x1
    V_1_2 = 0x2
    V_2_0 = 0x3
    V_2_1 = 0x4
    V_3_0 = 0x5
    V_4_0 = 0x6
    V_4_1 = 0x7
    V_4_2 = 0x8
    V_5_0 = 0x9
    V_5_1 = 0xa
    V_5_2 = 0xb
    V_5_3 = 0xc
    V_5_4 = 0xd
    V_6_0 = 0xe

@dataclass
class LocalVersionInformation(Packet):
    hci_version: HciVersion = field(kw_only=True, default=HciVersion.V_1_0B)
    hci_revision: int = field(kw_only=True, default=0)
    lmp_version: LmpVersion = field(kw_only=True, default=LmpVersion.V_1_0B)
    manufacturer_name: int = field(kw_only=True, default=0)
    lmp_subversion: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LocalVersionInformation', bytes]:
        fields = {'payload': None}
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['hci_version'] = HciVersion(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['hci_revision'] = value_
        fields['lmp_version'] = LmpVersion(span[3])
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['manufacturer_name'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['lmp_subversion'] = value_
        span = span[8:]
        return LocalVersionInformation(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.hci_version << 0))
        if self.hci_revision > 65535:
            print(f"Invalid value for field LocalVersionInformation::hci_revision: {self.hci_revision} > 65535; the value will be truncated")
            self.hci_revision &= 65535
        _span.extend(int.to_bytes((self.hci_revision << 0), length=2, byteorder='little'))
        _span.append((self.lmp_version << 0))
        if self.manufacturer_name > 65535:
            print(f"Invalid value for field LocalVersionInformation::manufacturer_name: {self.manufacturer_name} > 65535; the value will be truncated")
            self.manufacturer_name &= 65535
        _span.extend(int.to_bytes((self.manufacturer_name << 0), length=2, byteorder='little'))
        if self.lmp_subversion > 65535:
            print(f"Invalid value for field LocalVersionInformation::lmp_subversion: {self.lmp_subversion} > 65535; the value will be truncated")
            self.lmp_subversion &= 65535
        _span.extend(int.to_bytes((self.lmp_subversion << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 8

@dataclass
class ReadLocalVersionInformationComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    local_version_information: LocalVersionInformation = field(kw_only=True, default_factory=LocalVersionInformation)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_VERSION_INFORMATION
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalVersionInformationComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_VERSION_INFORMATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['local_version_information'] = LocalVersionInformation.parse_all(span[1:9])
        span = span[9:]
        return ReadLocalVersionInformationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.local_version_information.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class ReadLocalSupportedCommands(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_SUPPORTED_COMMANDS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCommands', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_SUPPORTED_COMMANDS:
            raise Exception("Invalid constraint field values")
        return ReadLocalSupportedCommands(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLocalSupportedCommandsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    supported_commands: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_SUPPORTED_COMMANDS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCommandsComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_SUPPORTED_COMMANDS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        if len(span) < 64:
            raise Exception('Invalid packet size')
        fields['supported_commands'] = list(span[:64])
        span = span[64:]
        return ReadLocalSupportedCommandsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.supported_commands)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 65

@dataclass
class ReadLocalSupportedFeatures(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_SUPPORTED_FEATURES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedFeatures', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        return ReadLocalSupportedFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLocalSupportedFeaturesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    lmp_features: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_SUPPORTED_FEATURES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedFeaturesComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:9], byteorder='little')
        fields['lmp_features'] = value_
        span = span[9:]
        return ReadLocalSupportedFeaturesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.lmp_features > 18446744073709551615:
            print(f"Invalid value for field ReadLocalSupportedFeaturesComplete::lmp_features: {self.lmp_features} > 18446744073709551615; the value will be truncated")
            self.lmp_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.lmp_features << 0), length=8, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class ReadLocalExtendedFeatures(Command):
    page_number: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_EXTENDED_FEATURES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalExtendedFeatures', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_EXTENDED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['page_number'] = span[0]
        span = span[1:]
        return ReadLocalExtendedFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.page_number > 255:
            print(f"Invalid value for field ReadLocalExtendedFeatures::page_number: {self.page_number} > 255; the value will be truncated")
            self.page_number &= 255
        _span.append((self.page_number << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class LMPFeaturesPage0Bits(enum.IntEnum):
    LMP_3_SLOT_PACKETS = 0x1
    LMP_5_SLOT_PACKETS = 0x2
    ENCRYPTION = 0x4
    SLOT_OFFSET = 0x8
    TIMING_ACCURACY = 0x10
    ROLE_SWITCH = 0x20
    HOLD_MODE = 0x40
    SNIFF_MODE = 0x80
    POWER_CONTROL_REQUESTS = 0x200
    CHANNEL_QUALITY_DRIVEN_DATA_RATE = 0x400
    SCO_LINK = 0x800
    HV2_PACKETS = 0x1000
    HV3_PACKETS = 0x2000
    M_LAW_LOG_SYNCHRONOUS_DATA = 0x4000
    A_LAW_LOG_SYNCHRONOUS_DATA = 0x8000
    CVSD_SYNCHRONOUS_DATA = 0x10000
    PAGING_PARAMETER_NEGOTIATION = 0x20000
    POWER_CONTROL = 0x40000
    TRANSPARENT_SYNCHRONOUS_DATA = 0x80000
    FLOW_CONTROL_LAG_LEAST_SIGNIFICANT_BIT = 0x100000
    FLOW_CONTROL_LAG_MIDDLE_BIT = 0x200000
    FLOW_CONTROL_LAG_MOST_SIGNIFICANT_BIT = 0x400000
    BROADCAST_ENCRYPTION = 0x800000
    ENHANCED_DATA_RATE_ACL_2_MB_S_MODE = 0x2000000
    ENHANCED_DATA_RATE_ACL_3_MB_S_MODE = 0x4000000
    ENHANCED_INQUIRY_SCAN = 0x8000000
    INTERLACED_INQUIRY_SCAN = 0x10000000
    INTERLACED_PAGE_SCAN = 0x20000000
    RSSI_WITH_INQUIRY_RESULTS = 0x40000000
    EXTENDED_SCO_LINK = 0x80000000
    EV4_PACKETS = 0x100000000
    EV5_PACKETS = 0x200000000
    AFH_CAPABLE_PERIPHERAL = 0x800000000
    AFH_CLASSIFICATION_PERIPHERAL = 0x1000000000
    BR_EDR_NOT_SUPPORTED = 0x2000000000
    LE_SUPPORTED_CONTROLLER = 0x4000000000
    LMP_3_SLOT_ENHANCED_DATA_RATE_ACL_PACKETS = 0x8000000000
    LMP_5_SLOT_ENHANCED_DATA_RATE_ACL_PACKETS = 0x10000000000
    SNIFF_SUBRATING = 0x20000000000
    PAUSE_ENCRYPTION = 0x40000000000
    AFH_CAPABLE_CENTRAL = 0x80000000000
    AFH_CLASSIFICATION_CENTRAL = 0x100000000000
    ENHANCED_DATA_RATE_ESCO_2_MB_S_MODE = 0x200000000000
    ENHANCED_DATA_RATE_ESCO_3_MB_S_MODE = 0x400000000000
    LMP_3_SLOT_ENHANCED_DATA_RATE_ESCO_PACKETS = 0x800000000000
    EXTENDED_INQUIRY_RESPONSE = 0x1000000000000
    SIMULTANEOUS_LE_AND_BR_CONTROLLER = 0x2000000000000
    SECURE_SIMPLE_PAIRING_CONTROLLER = 0x8000000000000
    ENCAPSULATED_PDU = 0x10000000000000
    ERRONEOUS_DATA_REPORTING = 0x20000000000000
    NON_FLUSHABLE_PACKET_BOUNDARY_FLAG = 0x40000000000000
    HCI_LINK_SUPERVISION_TIMEOUT_CHANGED_EVENT = 0x100000000000000
    VARIABLE_INQUIRY_TX_POWER_LEVEL = 0x200000000000000
    ENHANCED_POWER_CONTROL = 0x400000000000000
    EXTENDED_FEATURES = 0x8000000000000000

class LMPFeaturesPage1Bits(enum.IntEnum):
    SECURE_SIMPLE_PAIRING_HOST_SUPPORT = 0x1
    LE_SUPPORTED_HOST = 0x2
    SIMULTANEOUS_LE_AND_BR_HOST = 0x4
    SECURE_CONNECTIONS_HOST_SUPPORT = 0x8

class LMPFeaturesPage2Bits(enum.IntEnum):
    CONNECTIONLESS_PERIPHERAL_BROADCAST_TRANSMITTER_OPERATION = 0x1
    CONNECTIONLESS_PERIPHERAL_BROADCAST_RECEIVER_OPERATION = 0x2
    SYNCHRONIZATION_TRAIN = 0x4
    SYNCHRONIZATION_SCAN = 0x8
    HCI_INQUIRY_RESPONSE_NOTIFICATION_EVENT = 0x10
    GENERALIZED_INTERLACED_SCAN = 0x20
    COARSE_CLOCK_ADJUSTMENT = 0x40
    SECURE_CONNECTIONS_CONTROLLER_SUPPORT = 0x100
    PING = 0x200
    SLOT_AVAILABILITY_MASK = 0x400
    TRAIN_NUDGING = 0x800

@dataclass
class ReadLocalExtendedFeaturesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    page_number: int = field(kw_only=True, default=0)
    maximum_page_number: int = field(kw_only=True, default=0)
    extended_lmp_features: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_EXTENDED_FEATURES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalExtendedFeaturesComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_EXTENDED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['page_number'] = span[1]
        fields['maximum_page_number'] = span[2]
        value_ = int.from_bytes(span[3:11], byteorder='little')
        fields['extended_lmp_features'] = value_
        span = span[11:]
        return ReadLocalExtendedFeaturesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.page_number > 255:
            print(f"Invalid value for field ReadLocalExtendedFeaturesComplete::page_number: {self.page_number} > 255; the value will be truncated")
            self.page_number &= 255
        _span.append((self.page_number << 0))
        if self.maximum_page_number > 255:
            print(f"Invalid value for field ReadLocalExtendedFeaturesComplete::maximum_page_number: {self.maximum_page_number} > 255; the value will be truncated")
            self.maximum_page_number &= 255
        _span.append((self.maximum_page_number << 0))
        if self.extended_lmp_features > 18446744073709551615:
            print(f"Invalid value for field ReadLocalExtendedFeaturesComplete::extended_lmp_features: {self.extended_lmp_features} > 18446744073709551615; the value will be truncated")
            self.extended_lmp_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.extended_lmp_features << 0), length=8, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

@dataclass
class ReadBufferSize(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_BUFFER_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadBufferSize', bytes]:
        if fields['op_code'] != OpCode.READ_BUFFER_SIZE:
            raise Exception("Invalid constraint field values")
        return ReadBufferSize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadBufferSizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    acl_data_packet_length: int = field(kw_only=True, default=0)
    synchronous_data_packet_length: int = field(kw_only=True, default=0)
    total_num_acl_data_packets: int = field(kw_only=True, default=0)
    total_num_synchronous_data_packets: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_BUFFER_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadBufferSizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_BUFFER_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['acl_data_packet_length'] = value_
        fields['synchronous_data_packet_length'] = span[3]
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['total_num_acl_data_packets'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['total_num_synchronous_data_packets'] = value_
        span = span[8:]
        return ReadBufferSizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.acl_data_packet_length > 65535:
            print(f"Invalid value for field ReadBufferSizeComplete::acl_data_packet_length: {self.acl_data_packet_length} > 65535; the value will be truncated")
            self.acl_data_packet_length &= 65535
        _span.extend(int.to_bytes((self.acl_data_packet_length << 0), length=2, byteorder='little'))
        if self.synchronous_data_packet_length > 255:
            print(f"Invalid value for field ReadBufferSizeComplete::synchronous_data_packet_length: {self.synchronous_data_packet_length} > 255; the value will be truncated")
            self.synchronous_data_packet_length &= 255
        _span.append((self.synchronous_data_packet_length << 0))
        if self.total_num_acl_data_packets > 65535:
            print(f"Invalid value for field ReadBufferSizeComplete::total_num_acl_data_packets: {self.total_num_acl_data_packets} > 65535; the value will be truncated")
            self.total_num_acl_data_packets &= 65535
        _span.extend(int.to_bytes((self.total_num_acl_data_packets << 0), length=2, byteorder='little'))
        if self.total_num_synchronous_data_packets > 65535:
            print(f"Invalid value for field ReadBufferSizeComplete::total_num_synchronous_data_packets: {self.total_num_synchronous_data_packets} > 65535; the value will be truncated")
            self.total_num_synchronous_data_packets &= 65535
        _span.extend(int.to_bytes((self.total_num_synchronous_data_packets << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class ReadBdAddr(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_BD_ADDR

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadBdAddr', bytes]:
        if fields['op_code'] != OpCode.READ_BD_ADDR:
            raise Exception("Invalid constraint field values")
        return ReadBdAddr(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadBdAddrComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_BD_ADDR
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadBdAddrComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_BD_ADDR:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return ReadBdAddrComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class ReadDataBlockSize(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_DATA_BLOCK_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadDataBlockSize', bytes]:
        if fields['op_code'] != OpCode.READ_DATA_BLOCK_SIZE:
            raise Exception("Invalid constraint field values")
        return ReadDataBlockSize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadDataBlockSizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    max_acl_data_packet_length: int = field(kw_only=True, default=0)
    data_block_length: int = field(kw_only=True, default=0)
    total_num_data_blocks: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_DATA_BLOCK_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadDataBlockSizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_DATA_BLOCK_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['max_acl_data_packet_length'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['data_block_length'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['total_num_data_blocks'] = value_
        span = span[7:]
        return ReadDataBlockSizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.max_acl_data_packet_length > 65535:
            print(f"Invalid value for field ReadDataBlockSizeComplete::max_acl_data_packet_length: {self.max_acl_data_packet_length} > 65535; the value will be truncated")
            self.max_acl_data_packet_length &= 65535
        _span.extend(int.to_bytes((self.max_acl_data_packet_length << 0), length=2, byteorder='little'))
        if self.data_block_length > 65535:
            print(f"Invalid value for field ReadDataBlockSizeComplete::data_block_length: {self.data_block_length} > 65535; the value will be truncated")
            self.data_block_length &= 65535
        _span.extend(int.to_bytes((self.data_block_length << 0), length=2, byteorder='little'))
        if self.total_num_data_blocks > 65535:
            print(f"Invalid value for field ReadDataBlockSizeComplete::total_num_data_blocks: {self.total_num_data_blocks} > 65535; the value will be truncated")
            self.total_num_data_blocks &= 65535
        _span.extend(int.to_bytes((self.total_num_data_blocks << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class ReadLocalSupportedCodecsV1(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_SUPPORTED_CODECS_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCodecsV1', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_SUPPORTED_CODECS_V1:
            raise Exception("Invalid constraint field values")
        return ReadLocalSupportedCodecsV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLocalSupportedCodecsV1Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    supported_codecs: bytearray = field(kw_only=True, default_factory=bytearray)
    vendor_specific_codecs: List[int] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_SUPPORTED_CODECS_V1
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCodecsV1Complete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_SUPPORTED_CODECS_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        supported_codecs_count = span[1]
        span = span[2:]
        if len(span) < supported_codecs_count:
            raise Exception('Invalid packet size')
        fields['supported_codecs'] = list(span[:supported_codecs_count])
        span = span[supported_codecs_count:]
        if len(span) < 1:
            raise Exception('Invalid packet size')
        vendor_specific_codecs_count = span[0]
        span = span[1:]
        if len(span) < vendor_specific_codecs_count * 4:
            raise Exception('Invalid packet size')
        vendor_specific_codecs = []
        for n in range(vendor_specific_codecs_count):
            vendor_specific_codecs.append(int.from_bytes(span[n * 4:(n + 1) * 4], byteorder='little'))
        fields['vendor_specific_codecs'] = vendor_specific_codecs
        span = span[vendor_specific_codecs_count * 4:]
        return ReadLocalSupportedCodecsV1Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if len(self.supported_codecs) > 255:
            print(f"Invalid length for field ReadLocalSupportedCodecsV1Complete::supported_codecs:  {len(self.supported_codecs)} > 255; the array will be truncated")
            del self.supported_codecs[255:]
        _span.append((len(self.supported_codecs) << 0))
        _span.extend(self.supported_codecs)
        if len(self.vendor_specific_codecs) > 255:
            print(f"Invalid length for field ReadLocalSupportedCodecsV1Complete::vendor_specific_codecs:  {len(self.vendor_specific_codecs)} > 255; the array will be truncated")
            del self.vendor_specific_codecs[255:]
        _span.append((len(self.vendor_specific_codecs) << 0))
        for _elt in self.vendor_specific_codecs:
            _span.extend(int.to_bytes(_elt, length=4, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3 + (
        len(self.supported_codecs) * 1 +
            len(self.vendor_specific_codecs) * 4
        )

@dataclass
class ReadLocalSupportedCodecsV2(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_SUPPORTED_CODECS_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCodecsV2', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_SUPPORTED_CODECS_V2:
            raise Exception("Invalid constraint field values")
        return ReadLocalSupportedCodecsV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class CodecConfiguration(Packet):
    codec_id: int = field(kw_only=True, default=0)
    br_edr: int = field(kw_only=True, default=0)
    br_edr_sco_and_esco: int = field(kw_only=True, default=0)
    le_cis: int = field(kw_only=True, default=0)
    le_bis: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CodecConfiguration', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['codec_id'] = span[0]
        fields['br_edr'] = (span[1] >> 0) & 0x1
        fields['br_edr_sco_and_esco'] = (span[1] >> 1) & 0x1
        fields['le_cis'] = (span[1] >> 2) & 0x1
        fields['le_bis'] = (span[1] >> 3) & 0x1
        span = span[2:]
        return CodecConfiguration(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.codec_id > 255:
            print(f"Invalid value for field CodecConfiguration::codec_id: {self.codec_id} > 255; the value will be truncated")
            self.codec_id &= 255
        _span.append((self.codec_id << 0))
        if self.br_edr > 1:
            print(f"Invalid value for field CodecTransport::br_edr: {self.br_edr} > 1; the value will be truncated")
            self.br_edr &= 1
        if self.br_edr_sco_and_esco > 1:
            print(f"Invalid value for field CodecTransport::br_edr_sco_and_esco: {self.br_edr_sco_and_esco} > 1; the value will be truncated")
            self.br_edr_sco_and_esco &= 1
        if self.le_cis > 1:
            print(f"Invalid value for field CodecTransport::le_cis: {self.le_cis} > 1; the value will be truncated")
            self.le_cis &= 1
        if self.le_bis > 1:
            print(f"Invalid value for field CodecTransport::le_bis: {self.le_bis} > 1; the value will be truncated")
            self.le_bis &= 1
        _value = (
            (self.br_edr << 0) |
            (self.br_edr_sco_and_esco << 1) |
            (self.le_cis << 2) |
            (self.le_bis << 3)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class VendorCodecConfiguration(Packet):
    company_id: int = field(kw_only=True, default=0)
    codec_vendor_id: int = field(kw_only=True, default=0)
    br_edr: int = field(kw_only=True, default=0)
    br_edr_sco_and_esco: int = field(kw_only=True, default=0)
    le_cis: int = field(kw_only=True, default=0)
    le_bis: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['VendorCodecConfiguration', bytes]:
        fields = {'payload': None}
        if len(span) < 5:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['company_id'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['codec_vendor_id'] = value_
        fields['br_edr'] = (span[4] >> 0) & 0x1
        fields['br_edr_sco_and_esco'] = (span[4] >> 1) & 0x1
        fields['le_cis'] = (span[4] >> 2) & 0x1
        fields['le_bis'] = (span[4] >> 3) & 0x1
        span = span[5:]
        return VendorCodecConfiguration(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.company_id > 65535:
            print(f"Invalid value for field VendorCodecConfiguration::company_id: {self.company_id} > 65535; the value will be truncated")
            self.company_id &= 65535
        _span.extend(int.to_bytes((self.company_id << 0), length=2, byteorder='little'))
        if self.codec_vendor_id > 65535:
            print(f"Invalid value for field VendorCodecConfiguration::codec_vendor_id: {self.codec_vendor_id} > 65535; the value will be truncated")
            self.codec_vendor_id &= 65535
        _span.extend(int.to_bytes((self.codec_vendor_id << 0), length=2, byteorder='little'))
        if self.br_edr > 1:
            print(f"Invalid value for field CodecTransport::br_edr: {self.br_edr} > 1; the value will be truncated")
            self.br_edr &= 1
        if self.br_edr_sco_and_esco > 1:
            print(f"Invalid value for field CodecTransport::br_edr_sco_and_esco: {self.br_edr_sco_and_esco} > 1; the value will be truncated")
            self.br_edr_sco_and_esco &= 1
        if self.le_cis > 1:
            print(f"Invalid value for field CodecTransport::le_cis: {self.le_cis} > 1; the value will be truncated")
            self.le_cis &= 1
        if self.le_bis > 1:
            print(f"Invalid value for field CodecTransport::le_bis: {self.le_bis} > 1; the value will be truncated")
            self.le_bis &= 1
        _value = (
            (self.br_edr << 0) |
            (self.br_edr_sco_and_esco << 1) |
            (self.le_cis << 2) |
            (self.le_bis << 3)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 5

@dataclass
class ReadLocalSupportedCodecsV2Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    supported_codecs: List[CodecConfiguration] = field(kw_only=True, default_factory=list)
    vendor_specific_codecs: List[VendorCodecConfiguration] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_SUPPORTED_CODECS_V2
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCodecsV2Complete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_SUPPORTED_CODECS_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        supported_codecs_count = span[1]
        span = span[2:]
        if len(span) < supported_codecs_count * 2:
            raise Exception('Invalid packet size')
        supported_codecs = []
        for n in range(supported_codecs_count):
            supported_codecs.append(CodecConfiguration.parse_all(span[n * 2:(n + 1) * 2]))
        fields['supported_codecs'] = supported_codecs
        span = span[supported_codecs_count * 2:]
        if len(span) < 1:
            raise Exception('Invalid packet size')
        vendor_specific_codecs_count = span[0]
        span = span[1:]
        if len(span) < vendor_specific_codecs_count * 5:
            raise Exception('Invalid packet size')
        vendor_specific_codecs = []
        for n in range(vendor_specific_codecs_count):
            vendor_specific_codecs.append(VendorCodecConfiguration.parse_all(span[n * 5:(n + 1) * 5]))
        fields['vendor_specific_codecs'] = vendor_specific_codecs
        span = span[vendor_specific_codecs_count * 5:]
        return ReadLocalSupportedCodecsV2Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if len(self.supported_codecs) > 255:
            print(f"Invalid length for field ReadLocalSupportedCodecsV2Complete::supported_codecs:  {len(self.supported_codecs)} > 255; the array will be truncated")
            del self.supported_codecs[255:]
        _span.append((len(self.supported_codecs) << 0))
        for _elt in self.supported_codecs:
            _span.extend(_elt.serialize())
        if len(self.vendor_specific_codecs) > 255:
            print(f"Invalid length for field ReadLocalSupportedCodecsV2Complete::vendor_specific_codecs:  {len(self.vendor_specific_codecs)} > 255; the array will be truncated")
            del self.vendor_specific_codecs[255:]
        _span.append((len(self.vendor_specific_codecs) << 0))
        for _elt in self.vendor_specific_codecs:
            _span.extend(_elt.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3 + (
        sum([elt.size for elt in self.supported_codecs]) +
            sum([elt.size for elt in self.vendor_specific_codecs])
        )

@dataclass
class ReadLocalSupportedCodecCapabilities(Command):
    codec_id: int = field(kw_only=True, default=0)
    company_id: int = field(kw_only=True, default=0)
    codec_vendor_id: int = field(kw_only=True, default=0)
    br_edr: int = field(kw_only=True, default=0)
    br_edr_sco_and_esco: int = field(kw_only=True, default=0)
    le_cis: int = field(kw_only=True, default=0)
    le_bis: int = field(kw_only=True, default=0)
    direction: DataPathDirection = field(kw_only=True, default=DataPathDirection.INPUT)

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_SUPPORTED_CODEC_CAPABILITIES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCodecCapabilities', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_SUPPORTED_CODEC_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['codec_id'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['company_id'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['codec_vendor_id'] = value_
        fields['br_edr'] = (span[5] >> 0) & 0x1
        fields['br_edr_sco_and_esco'] = (span[5] >> 1) & 0x1
        fields['le_cis'] = (span[5] >> 2) & 0x1
        fields['le_bis'] = (span[5] >> 3) & 0x1
        fields['direction'] = DataPathDirection(span[6])
        span = span[7:]
        return ReadLocalSupportedCodecCapabilities(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.codec_id > 255:
            print(f"Invalid value for field ReadLocalSupportedCodecCapabilities::codec_id: {self.codec_id} > 255; the value will be truncated")
            self.codec_id &= 255
        _span.append((self.codec_id << 0))
        if self.company_id > 65535:
            print(f"Invalid value for field ReadLocalSupportedCodecCapabilities::company_id: {self.company_id} > 65535; the value will be truncated")
            self.company_id &= 65535
        _span.extend(int.to_bytes((self.company_id << 0), length=2, byteorder='little'))
        if self.codec_vendor_id > 65535:
            print(f"Invalid value for field ReadLocalSupportedCodecCapabilities::codec_vendor_id: {self.codec_vendor_id} > 65535; the value will be truncated")
            self.codec_vendor_id &= 65535
        _span.extend(int.to_bytes((self.codec_vendor_id << 0), length=2, byteorder='little'))
        if self.br_edr > 1:
            print(f"Invalid value for field CodecTransport::br_edr: {self.br_edr} > 1; the value will be truncated")
            self.br_edr &= 1
        if self.br_edr_sco_and_esco > 1:
            print(f"Invalid value for field CodecTransport::br_edr_sco_and_esco: {self.br_edr_sco_and_esco} > 1; the value will be truncated")
            self.br_edr_sco_and_esco &= 1
        if self.le_cis > 1:
            print(f"Invalid value for field CodecTransport::le_cis: {self.le_cis} > 1; the value will be truncated")
            self.le_cis &= 1
        if self.le_bis > 1:
            print(f"Invalid value for field CodecTransport::le_bis: {self.le_bis} > 1; the value will be truncated")
            self.le_bis &= 1
        _value = (
            (self.br_edr << 0) |
            (self.br_edr_sco_and_esco << 1) |
            (self.le_cis << 2) |
            (self.le_bis << 3)
        )
        _span.append(_value)
        _span.append((self.direction << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class CodecCapability(Packet):
    capability: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CodecCapability', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        capability_size = span[0]
        span = span[1:]
        if len(span) < capability_size:
            raise Exception('Invalid packet size')
        fields['capability'] = list(span[:capability_size])
        span = span[capability_size:]
        return CodecCapability(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append(((len(self.capability) * 1) << 0))
        _span.extend(self.capability)
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.capability) * 1 + 1

@dataclass
class ReadLocalSupportedCodecCapabilitiesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    codec_capabilities: List[CodecCapability] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_SUPPORTED_CODEC_CAPABILITIES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedCodecCapabilitiesComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_SUPPORTED_CODEC_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        codec_capabilities_count = span[1]
        span = span[2:]
        codec_capabilities = []
        for n in range(codec_capabilities_count):
            element, span = CodecCapability.parse(span)
            codec_capabilities.append(element)
        fields['codec_capabilities'] = codec_capabilities
        return ReadLocalSupportedCodecCapabilitiesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if len(self.codec_capabilities) > 255:
            print(f"Invalid length for field ReadLocalSupportedCodecCapabilitiesComplete::codec_capabilities:  {len(self.codec_capabilities)} > 255; the array will be truncated")
            del self.codec_capabilities[255:]
        _span.append((len(self.codec_capabilities) << 0))
        for _elt in self.codec_capabilities:
            _span.extend(_elt.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.codec_capabilities]) + 2

@dataclass
class ReadLocalSupportedControllerDelay(Command):
    codec_id: int = field(kw_only=True, default=0)
    company_id: int = field(kw_only=True, default=0)
    codec_vendor_id: int = field(kw_only=True, default=0)
    br_edr: int = field(kw_only=True, default=0)
    br_edr_sco_and_esco: int = field(kw_only=True, default=0)
    le_cis: int = field(kw_only=True, default=0)
    le_bis: int = field(kw_only=True, default=0)
    direction: DataPathDirection = field(kw_only=True, default=DataPathDirection.INPUT)
    codec_configuration: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.READ_LOCAL_SUPPORTED_CONTROLLER_DELAY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedControllerDelay', bytes]:
        if fields['op_code'] != OpCode.READ_LOCAL_SUPPORTED_CONTROLLER_DELAY:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['codec_id'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['company_id'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['codec_vendor_id'] = value_
        fields['br_edr'] = (span[5] >> 0) & 0x1
        fields['br_edr_sco_and_esco'] = (span[5] >> 1) & 0x1
        fields['le_cis'] = (span[5] >> 2) & 0x1
        fields['le_bis'] = (span[5] >> 3) & 0x1
        fields['direction'] = DataPathDirection(span[6])
        codec_configuration_size = span[7]
        span = span[8:]
        if len(span) < codec_configuration_size:
            raise Exception('Invalid packet size')
        fields['codec_configuration'] = list(span[:codec_configuration_size])
        span = span[codec_configuration_size:]
        return ReadLocalSupportedControllerDelay(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.codec_id > 255:
            print(f"Invalid value for field ReadLocalSupportedControllerDelay::codec_id: {self.codec_id} > 255; the value will be truncated")
            self.codec_id &= 255
        _span.append((self.codec_id << 0))
        if self.company_id > 65535:
            print(f"Invalid value for field ReadLocalSupportedControllerDelay::company_id: {self.company_id} > 65535; the value will be truncated")
            self.company_id &= 65535
        _span.extend(int.to_bytes((self.company_id << 0), length=2, byteorder='little'))
        if self.codec_vendor_id > 65535:
            print(f"Invalid value for field ReadLocalSupportedControllerDelay::codec_vendor_id: {self.codec_vendor_id} > 65535; the value will be truncated")
            self.codec_vendor_id &= 65535
        _span.extend(int.to_bytes((self.codec_vendor_id << 0), length=2, byteorder='little'))
        if self.br_edr > 1:
            print(f"Invalid value for field CodecTransport::br_edr: {self.br_edr} > 1; the value will be truncated")
            self.br_edr &= 1
        if self.br_edr_sco_and_esco > 1:
            print(f"Invalid value for field CodecTransport::br_edr_sco_and_esco: {self.br_edr_sco_and_esco} > 1; the value will be truncated")
            self.br_edr_sco_and_esco &= 1
        if self.le_cis > 1:
            print(f"Invalid value for field CodecTransport::le_cis: {self.le_cis} > 1; the value will be truncated")
            self.le_cis &= 1
        if self.le_bis > 1:
            print(f"Invalid value for field CodecTransport::le_bis: {self.le_bis} > 1; the value will be truncated")
            self.le_bis &= 1
        _value = (
            (self.br_edr << 0) |
            (self.br_edr_sco_and_esco << 1) |
            (self.le_cis << 2) |
            (self.le_bis << 3)
        )
        _span.append(_value)
        _span.append((self.direction << 0))
        _span.append(((len(self.codec_configuration) * 1) << 0))
        _span.extend(self.codec_configuration)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.codec_configuration) * 1 + 8

@dataclass
class ReadLocalSupportedControllerDelayComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    min_controller_delay: int = field(kw_only=True, default=0)
    max_controller_delay: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOCAL_SUPPORTED_CONTROLLER_DELAY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLocalSupportedControllerDelayComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOCAL_SUPPORTED_CONTROLLER_DELAY:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:4], byteorder='little')
        fields['min_controller_delay'] = value_
        value_ = int.from_bytes(span[4:7], byteorder='little')
        fields['max_controller_delay'] = value_
        span = span[7:]
        return ReadLocalSupportedControllerDelayComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.min_controller_delay > 16777215:
            print(f"Invalid value for field ReadLocalSupportedControllerDelayComplete::min_controller_delay: {self.min_controller_delay} > 16777215; the value will be truncated")
            self.min_controller_delay &= 16777215
        _span.extend(int.to_bytes((self.min_controller_delay << 0), length=3, byteorder='little'))
        if self.max_controller_delay > 16777215:
            print(f"Invalid value for field ReadLocalSupportedControllerDelayComplete::max_controller_delay: {self.max_controller_delay} > 16777215; the value will be truncated")
            self.max_controller_delay &= 16777215
        _span.extend(int.to_bytes((self.max_controller_delay << 0), length=3, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class ReadFailedContactCounter(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_FAILED_CONTACT_COUNTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadFailedContactCounter', bytes]:
        if fields['op_code'] != OpCode.READ_FAILED_CONTACT_COUNTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadFailedContactCounter(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadFailedContactCounter::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadFailedContactCounterComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    failed_contact_counter: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_FAILED_CONTACT_COUNTER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadFailedContactCounterComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_FAILED_CONTACT_COUNTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['failed_contact_counter'] = value_
        span = span[5:]
        return ReadFailedContactCounterComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadFailedContactCounterComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.failed_contact_counter > 65535:
            print(f"Invalid value for field ReadFailedContactCounterComplete::failed_contact_counter: {self.failed_contact_counter} > 65535; the value will be truncated")
            self.failed_contact_counter &= 65535
        _span.extend(int.to_bytes((self.failed_contact_counter << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class ResetFailedContactCounter(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.RESET_FAILED_CONTACT_COUNTER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ResetFailedContactCounter', bytes]:
        if fields['op_code'] != OpCode.RESET_FAILED_CONTACT_COUNTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ResetFailedContactCounter(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ResetFailedContactCounter::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ResetFailedContactCounterComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.RESET_FAILED_CONTACT_COUNTER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ResetFailedContactCounterComplete', bytes]:
        if fields['command_op_code'] != OpCode.RESET_FAILED_CONTACT_COUNTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return ResetFailedContactCounterComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ResetFailedContactCounterComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadLinkQuality(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_LINK_QUALITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLinkQuality', bytes]:
        if fields['op_code'] != OpCode.READ_LINK_QUALITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadLinkQuality(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLinkQuality::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadLinkQualityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    link_quality: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LINK_QUALITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLinkQualityComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LINK_QUALITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['link_quality'] = span[3]
        span = span[4:]
        return ReadLinkQualityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadLinkQualityComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.link_quality > 255:
            print(f"Invalid value for field ReadLinkQualityComplete::link_quality: {self.link_quality} > 255; the value will be truncated")
            self.link_quality &= 255
        _span.append((self.link_quality << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class ReadRssi(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_RSSI

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRssi', bytes]:
        if fields['op_code'] != OpCode.READ_RSSI:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadRssi(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRssi::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadRssiComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_RSSI
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRssiComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_RSSI:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['rssi'] = span[3]
        span = span[4:]
        return ReadRssiComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRssiComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.rssi > 255:
            print(f"Invalid value for field ReadRssiComplete::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class ReadAfhChannelMap(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_AFH_CHANNEL_MAP

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAfhChannelMap', bytes]:
        if fields['op_code'] != OpCode.READ_AFH_CHANNEL_MAP:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadAfhChannelMap(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadAfhChannelMap::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class AfhMode(enum.IntEnum):
    AFH_DISABLED = 0x0
    AFH_ENABLED = 0x1

@dataclass
class ReadAfhChannelMapComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    afh_mode: AfhMode = field(kw_only=True, default=AfhMode.AFH_DISABLED)
    afh_channel_map: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_AFH_CHANNEL_MAP
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadAfhChannelMapComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_AFH_CHANNEL_MAP:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['afh_mode'] = AfhMode(span[3])
        span = span[4:]
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['afh_channel_map'] = list(span[:10])
        span = span[10:]
        return ReadAfhChannelMapComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadAfhChannelMapComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.afh_mode << 0))
        _span.extend(self.afh_channel_map)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 14

class WhichClock(enum.IntEnum):
    LOCAL = 0x0
    PICONET = 0x1

@dataclass
class ReadClock(Command):
    connection_handle: int = field(kw_only=True, default=0)
    which_clock: WhichClock = field(kw_only=True, default=WhichClock.LOCAL)

    def __post_init__(self):
        self.op_code = OpCode.READ_CLOCK

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadClock', bytes]:
        if fields['op_code'] != OpCode.READ_CLOCK:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['which_clock'] = WhichClock(span[2])
        span = span[3:]
        return ReadClock(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadClock::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.which_clock << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadClockComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    clock: int = field(kw_only=True, default=0)
    accuracy: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_CLOCK
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadClockComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_CLOCK:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:7], byteorder='little')
        fields['clock'] = (value_ >> 0) & 0xfffffff
        value_ = int.from_bytes(span[7:9], byteorder='little')
        fields['accuracy'] = value_
        span = span[9:]
        return ReadClockComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadClockComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.clock > 268435455:
            print(f"Invalid value for field ReadClockComplete::clock: {self.clock} > 268435455; the value will be truncated")
            self.clock &= 268435455
        _span.extend(int.to_bytes((self.clock << 0), length=4, byteorder='little'))
        if self.accuracy > 65535:
            print(f"Invalid value for field ReadClockComplete::accuracy: {self.accuracy} > 65535; the value will be truncated")
            self.accuracy &= 65535
        _span.extend(int.to_bytes((self.accuracy << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class ReadEncryptionKeySize(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.READ_ENCRYPTION_KEY_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadEncryptionKeySize', bytes]:
        if fields['op_code'] != OpCode.READ_ENCRYPTION_KEY_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return ReadEncryptionKeySize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadEncryptionKeySize::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class ReadEncryptionKeySizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    key_size: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_ENCRYPTION_KEY_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadEncryptionKeySizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_ENCRYPTION_KEY_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['key_size'] = span[3]
        span = span[4:]
        return ReadEncryptionKeySizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadEncryptionKeySizeComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.key_size > 255:
            print(f"Invalid value for field ReadEncryptionKeySizeComplete::key_size: {self.key_size} > 255; the value will be truncated")
            self.key_size &= 255
        _span.append((self.key_size << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

class LoopbackMode(enum.IntEnum):
    NO_LOOPBACK = 0x0
    ENABLE_LOCAL = 0x1
    ENABLE_REMOTE = 0x2

@dataclass
class ReadLoopbackMode(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.READ_LOOPBACK_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLoopbackMode', bytes]:
        if fields['op_code'] != OpCode.READ_LOOPBACK_MODE:
            raise Exception("Invalid constraint field values")
        return ReadLoopbackMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class ReadLoopbackModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    loopback_mode: LoopbackMode = field(kw_only=True, default=LoopbackMode.NO_LOOPBACK)

    def __post_init__(self):
        self.command_op_code = OpCode.READ_LOOPBACK_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadLoopbackModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.READ_LOOPBACK_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['loopback_mode'] = LoopbackMode(span[1])
        span = span[2:]
        return ReadLoopbackModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.loopback_mode << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class WriteLoopbackMode(Command):
    loopback_mode: LoopbackMode = field(kw_only=True, default=LoopbackMode.NO_LOOPBACK)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_LOOPBACK_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLoopbackMode', bytes]:
        if fields['op_code'] != OpCode.WRITE_LOOPBACK_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['loopback_mode'] = LoopbackMode(span[0])
        span = span[1:]
        return WriteLoopbackMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.loopback_mode << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteLoopbackModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_LOOPBACK_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteLoopbackModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_LOOPBACK_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteLoopbackModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class EnableImplementationUnderTestMode(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.ENABLE_IMPLEMENTATION_UNDER_TEST_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnableImplementationUnderTestMode', bytes]:
        if fields['op_code'] != OpCode.ENABLE_IMPLEMENTATION_UNDER_TEST_MODE:
            raise Exception("Invalid constraint field values")
        return EnableImplementationUnderTestMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class EnableImplementationUnderTestModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.ENABLE_IMPLEMENTATION_UNDER_TEST_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnableImplementationUnderTestModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.ENABLE_IMPLEMENTATION_UNDER_TEST_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return EnableImplementationUnderTestModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteSimplePairingDebugMode(Command):
    simple_pairing_debug_mode: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_SIMPLE_PAIRING_DEBUG_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSimplePairingDebugMode', bytes]:
        if fields['op_code'] != OpCode.WRITE_SIMPLE_PAIRING_DEBUG_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['simple_pairing_debug_mode'] = Enable(span[0])
        span = span[1:]
        return WriteSimplePairingDebugMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.simple_pairing_debug_mode << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteSimplePairingDebugModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_SIMPLE_PAIRING_DEBUG_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSimplePairingDebugModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_SIMPLE_PAIRING_DEBUG_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteSimplePairingDebugModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class WriteSecureConnectionsTestMode(Command):
    connection_handle: int = field(kw_only=True, default=0)
    dm1_aclu_mode: Enable = field(kw_only=True, default=Enable.DISABLED)
    esco_loopback_mode: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.WRITE_SECURE_CONNECTIONS_TEST_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSecureConnectionsTestMode', bytes]:
        if fields['op_code'] != OpCode.WRITE_SECURE_CONNECTIONS_TEST_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['dm1_aclu_mode'] = Enable(span[2])
        fields['esco_loopback_mode'] = Enable(span[3])
        span = span[4:]
        return WriteSecureConnectionsTestMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field WriteSecureConnectionsTestMode::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.dm1_aclu_mode << 0))
        _span.append((self.esco_loopback_mode << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class WriteSecureConnectionsTestModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.WRITE_SECURE_CONNECTIONS_TEST_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['WriteSecureConnectionsTestModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.WRITE_SECURE_CONNECTIONS_TEST_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return WriteSecureConnectionsTestModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetEventMask(Command):
    le_event_mask: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EVENT_MASK

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetEventMask', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EVENT_MASK:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:8], byteorder='little')
        fields['le_event_mask'] = value_
        span = span[8:]
        return LeSetEventMask(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.le_event_mask > 18446744073709551615:
            print(f"Invalid value for field LeSetEventMask::le_event_mask: {self.le_event_mask} > 18446744073709551615; the value will be truncated")
            self.le_event_mask &= 18446744073709551615
        _span.extend(int.to_bytes((self.le_event_mask << 0), length=8, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeSetEventMaskComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EVENT_MASK
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetEventMaskComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EVENT_MASK:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetEventMaskComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadBufferSizeV1(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_BUFFER_SIZE_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadBufferSizeV1', bytes]:
        if fields['op_code'] != OpCode.LE_READ_BUFFER_SIZE_V1:
            raise Exception("Invalid constraint field values")
        return LeReadBufferSizeV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeBufferSize(Packet):
    le_data_packet_length: int = field(kw_only=True, default=0)
    total_num_le_packets: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LeBufferSize', bytes]:
        fields = {'payload': None}
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['le_data_packet_length'] = value_
        fields['total_num_le_packets'] = span[2]
        span = span[3:]
        return LeBufferSize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.le_data_packet_length > 65535:
            print(f"Invalid value for field LeBufferSize::le_data_packet_length: {self.le_data_packet_length} > 65535; the value will be truncated")
            self.le_data_packet_length &= 65535
        _span.extend(int.to_bytes((self.le_data_packet_length << 0), length=2, byteorder='little'))
        if self.total_num_le_packets > 255:
            print(f"Invalid value for field LeBufferSize::total_num_le_packets: {self.total_num_le_packets} > 255; the value will be truncated")
            self.total_num_le_packets &= 255
        _span.append((self.total_num_le_packets << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeReadBufferSizeV1Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    le_buffer_size: LeBufferSize = field(kw_only=True, default_factory=LeBufferSize)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_BUFFER_SIZE_V1
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadBufferSizeV1Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_BUFFER_SIZE_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['le_buffer_size'] = LeBufferSize.parse_all(span[1:4])
        span = span[4:]
        return LeReadBufferSizeV1Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.le_buffer_size.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

class LLFeaturesBits(enum.IntEnum):
    LE_ENCRYPTION = 0x1
    CONNECTION_PARAMETERS_REQUEST_PROCEDURE = 0x2
    EXTENDED_REJECT_INDICATION = 0x4
    PERIPHERAL_INITIATED_FEATURES_EXCHANGE = 0x8
    LE_PING = 0x10
    LE_DATA_PACKET_LENGTH_EXTENSION = 0x20
    LL_PRIVACY = 0x40
    EXTENDED_SCANNER_FILTER_POLICIES = 0x80
    LE_2M_PHY = 0x100
    STABLE_MODULATION_INDEX_TRANSMITTER = 0x200
    STABLE_MODULATION_INDEX_RECEIVER = 0x400
    LE_CODED_PHY = 0x800
    LE_EXTENDED_ADVERTISING = 0x1000
    LE_PERIODIC_ADVERTISING = 0x2000
    CHANNEL_SELECTION_ALGORITHM_2 = 0x4000
    LE_POWER_CLASS_1 = 0x8000
    MINIMUM_NUMBER_OF_USED_CHANNELS_PROCEDURE = 0x10000
    CONNECTION_CTE_REQUEST = 0x20000
    CONNECTION_CTE_RESPONSE = 0x40000
    CONNECTIONLESS_CTE_TRANSMITTER = 0x80000
    CONNECTIONLESS_CTE_RECEIVER = 0x100000
    ANTENNA_SWITCHING_DURING_CTE_TRANSMISSION = 0x200000
    ANTENNA_SWITCHING_DURING_CTE_RECEPTION = 0x400000
    RECEIVING_CONSTANT_TONE_EXTENSIONS = 0x800000
    PERIODIC_ADVERTISING_SYNC_TRANSFER_SENDER = 0x1000000
    PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT = 0x2000000
    SLEEP_CLOCK_ACCURACY_UPDATES = 0x4000000
    REMOTE_PUBLIC_KEY_VALIDATION = 0x8000000
    CONNECTED_ISOCHRONOUS_STREAM_CENTRAL = 0x10000000
    CONNECTED_ISOCHRONOUS_STREAM_PERIPHERAL = 0x20000000
    ISOCHRONOUS_BROADCASTER = 0x40000000
    SYNCHRONIZED_RECEIVER = 0x80000000
    CONNECTED_ISOCHRONOUS_STREAM_HOST_SUPPORT = 0x100000000
    LE_POWER_CONTROL_REQUEST = 0x200000000
    LE_POWER_CONTROL_REQUEST_BIS = 0x400000000
    LE_PATH_LOSS_MONITORING = 0x800000000
    PERIODIC_ADVERTISING_ADI_SUPPORT = 0x1000000000
    CONNECTION_SUBRATING = 0x2000000000
    CONNECTION_SUBRATING_HOST_SUPPORT = 0x4000000000
    CHANNEL_CLASSIFICATION = 0x8000000000
    ADVERTISING_CODING_SELECTION = 0x10000000000
    ADVERTISING_CODING_SELECTION_HOST_SUPPORT = 0x20000000000
    DECISION_BASED_ADVERTISING_FILTERING = 0x40000000000
    PERIODIC_ADVERTISING_WITH_RESPONSES_ADVERTISER = 0x80000000000
    PERIODIC_ADVERTISING_WITH_RESPONSES_SCANNER = 0x100000000000
    UNSEGMENTED_FRAMED_MODE = 0x200000000000
    CHANNEL_SOUNDING = 0x400000000000
    CHANNEL_SOUNDING_HOST_SUPPORT = 0x800000000000

@dataclass
class LeReadLocalSupportedFeaturesPage0(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_LOCAL_SUPPORTED_FEATURES_PAGE_0

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadLocalSupportedFeaturesPage0', bytes]:
        if fields['op_code'] != OpCode.LE_READ_LOCAL_SUPPORTED_FEATURES_PAGE_0:
            raise Exception("Invalid constraint field values")
        return LeReadLocalSupportedFeaturesPage0(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadLocalSupportedFeaturesPage0Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    le_features: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_LOCAL_SUPPORTED_FEATURES_PAGE_0
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadLocalSupportedFeaturesPage0Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_LOCAL_SUPPORTED_FEATURES_PAGE_0:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:9], byteorder='little')
        fields['le_features'] = value_
        span = span[9:]
        return LeReadLocalSupportedFeaturesPage0Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.le_features > 18446744073709551615:
            print(f"Invalid value for field LeReadLocalSupportedFeaturesPage0Complete::le_features: {self.le_features} > 18446744073709551615; the value will be truncated")
            self.le_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.le_features << 0), length=8, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class LeReadAllLocalSupportedFeatures(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_ALL_LOCAL_SUPPORTED_FEATURES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadAllLocalSupportedFeatures', bytes]:
        if fields['op_code'] != OpCode.LE_READ_ALL_LOCAL_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        return LeReadAllLocalSupportedFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadAllLocalSupportedFeaturesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    max_page: int = field(kw_only=True, default=0)
    le_features: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_ALL_LOCAL_SUPPORTED_FEATURES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadAllLocalSupportedFeaturesComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_ALL_LOCAL_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['max_page'] = span[1]
        span = span[2:]
        if len(span) < 248:
            raise Exception('Invalid packet size')
        fields['le_features'] = list(span[:248])
        span = span[248:]
        return LeReadAllLocalSupportedFeaturesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.max_page > 255:
            print(f"Invalid value for field LeReadAllLocalSupportedFeaturesComplete::max_page: {self.max_page} > 255; the value will be truncated")
            self.max_page &= 255
        _span.append((self.max_page << 0))
        _span.extend(self.le_features)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 250

@dataclass
class LeSetRandomAddress(Command):
    random_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_RANDOM_ADDRESS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetRandomAddress', bytes]:
        if fields['op_code'] != OpCode.LE_SET_RANDOM_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['random_address'] = Address.parse_all(span[0:6])
        span = span[6:]
        return LeSetRandomAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.random_address.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LeSetRandomAddressComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_RANDOM_ADDRESS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetRandomAddressComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_RANDOM_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetRandomAddressComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class AdvertisingFilterPolicy(enum.IntEnum):
    ALL_DEVICES = 0x0
    LISTED_SCAN = 0x1
    LISTED_CONNECT = 0x2
    LISTED_SCAN_AND_CONNECT = 0x3

class PeerAddressType(enum.IntEnum):
    PUBLIC_DEVICE_OR_IDENTITY_ADDRESS = 0x0
    RANDOM_DEVICE_OR_IDENTITY_ADDRESS = 0x1

class AdvertisingType(enum.IntEnum):
    ADV_IND = 0x0
    ADV_DIRECT_IND_HIGH = 0x1
    ADV_SCAN_IND = 0x2
    ADV_NONCONN_IND = 0x3
    ADV_DIRECT_IND_LOW = 0x4

class AddressType(enum.IntEnum):
    PUBLIC_DEVICE_ADDRESS = 0x0
    RANDOM_DEVICE_ADDRESS = 0x1
    PUBLIC_IDENTITY_ADDRESS = 0x2
    RANDOM_IDENTITY_ADDRESS = 0x3

class OwnAddressType(enum.IntEnum):
    PUBLIC_DEVICE_ADDRESS = 0x0
    RANDOM_DEVICE_ADDRESS = 0x1
    RESOLVABLE_OR_PUBLIC_ADDRESS = 0x2
    RESOLVABLE_OR_RANDOM_ADDRESS = 0x3

@dataclass
class LeSetAdvertisingParameters(Command):
    advertising_interval_min: int = field(kw_only=True, default=0)
    advertising_interval_max: int = field(kw_only=True, default=0)
    advertising_type: AdvertisingType = field(kw_only=True, default=AdvertisingType.ADV_IND)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    advertising_channel_map: int = field(kw_only=True, default=0)
    advertising_filter_policy: AdvertisingFilterPolicy = field(kw_only=True, default=AdvertisingFilterPolicy.ALL_DEVICES)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_ADVERTISING_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingParameters', bytes]:
        if fields['op_code'] != OpCode.LE_SET_ADVERTISING_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 15:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['advertising_interval_min'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['advertising_interval_max'] = value_
        fields['advertising_type'] = AdvertisingType(span[4])
        fields['own_address_type'] = OwnAddressType(span[5])
        fields['peer_address_type'] = PeerAddressType(span[6])
        fields['peer_address'] = Address.parse_all(span[7:13])
        fields['advertising_channel_map'] = span[13]
        fields['advertising_filter_policy'] = AdvertisingFilterPolicy((span[14] >> 0) & 0x3)
        span = span[15:]
        return LeSetAdvertisingParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_interval_min > 65535:
            print(f"Invalid value for field LeSetAdvertisingParameters::advertising_interval_min: {self.advertising_interval_min} > 65535; the value will be truncated")
            self.advertising_interval_min &= 65535
        _span.extend(int.to_bytes((self.advertising_interval_min << 0), length=2, byteorder='little'))
        if self.advertising_interval_max > 65535:
            print(f"Invalid value for field LeSetAdvertisingParameters::advertising_interval_max: {self.advertising_interval_max} > 65535; the value will be truncated")
            self.advertising_interval_max &= 65535
        _span.extend(int.to_bytes((self.advertising_interval_max << 0), length=2, byteorder='little'))
        _span.append((self.advertising_type << 0))
        _span.append((self.own_address_type << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        if self.advertising_channel_map > 255:
            print(f"Invalid value for field LeSetAdvertisingParameters::advertising_channel_map: {self.advertising_channel_map} > 255; the value will be truncated")
            self.advertising_channel_map &= 255
        _span.append((self.advertising_channel_map << 0))
        _span.append((self.advertising_filter_policy << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 15

@dataclass
class LeSetAdvertisingParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_ADVERTISING_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_ADVERTISING_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetAdvertisingParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadAdvertisingPhysicalChannelTxPower(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadAdvertisingPhysicalChannelTxPower', bytes]:
        if fields['op_code'] != OpCode.LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER:
            raise Exception("Invalid constraint field values")
        return LeReadAdvertisingPhysicalChannelTxPower(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadAdvertisingPhysicalChannelTxPowerComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    transmit_power_level: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadAdvertisingPhysicalChannelTxPowerComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_ADVERTISING_PHYSICAL_CHANNEL_TX_POWER:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['transmit_power_level'] = span[1]
        span = span[2:]
        return LeReadAdvertisingPhysicalChannelTxPowerComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.transmit_power_level > 255:
            print(f"Invalid value for field LeReadAdvertisingPhysicalChannelTxPowerComplete::transmit_power_level: {self.transmit_power_level} > 255; the value will be truncated")
            self.transmit_power_level &= 255
        _span.append((self.transmit_power_level << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetAdvertisingData(Command):
    advertising_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_ADVERTISING_DATA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingData', bytes]:
        if fields['op_code'] != OpCode.LE_SET_ADVERTISING_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        advertising_data_size = span[0]
        span = span[1:]
        if len(span) < 31:
            raise Exception('Invalid packet size')
        if advertising_data_size > 31:
            raise Exception('Array size is larger than the padding size')
        fields['advertising_data'] = list(span[:advertising_data_size])
        span = span[31:]
        return LeSetAdvertisingData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append(((len(self.advertising_data) * 1) << 0))
        _advertising_data_start = len(_span)
        _span.extend(self.advertising_data)
        _span.extend([0] * (31 - len(_span) + _advertising_data_start))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 32

@dataclass
class LeSetAdvertisingDataComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_ADVERTISING_DATA
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingDataComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_ADVERTISING_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetAdvertisingDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetScanResponseData(Command):
    advertising_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_SCAN_RESPONSE_DATA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetScanResponseData', bytes]:
        if fields['op_code'] != OpCode.LE_SET_SCAN_RESPONSE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        advertising_data_size = span[0]
        span = span[1:]
        if len(span) < 31:
            raise Exception('Invalid packet size')
        if advertising_data_size > 31:
            raise Exception('Array size is larger than the padding size')
        fields['advertising_data'] = list(span[:advertising_data_size])
        span = span[31:]
        return LeSetScanResponseData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append(((len(self.advertising_data) * 1) << 0))
        _advertising_data_start = len(_span)
        _span.extend(self.advertising_data)
        _span.extend([0] * (31 - len(_span) + _advertising_data_start))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 32

@dataclass
class LeSetScanResponseDataComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_SCAN_RESPONSE_DATA
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetScanResponseDataComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_SCAN_RESPONSE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetScanResponseDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetAdvertisingEnable(Command):
    advertising_enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_ADVERTISING_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['advertising_enable'] = Enable(span[0])
        span = span[1:]
        return LeSetAdvertisingEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.advertising_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetAdvertisingEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_ADVERTISING_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetAdvertisingEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class LeScanType(enum.IntEnum):
    PASSIVE = 0x0
    ACTIVE = 0x1

class LeScanningFilterPolicy(enum.IntEnum):
    ACCEPT_ALL = 0x0
    FILTER_ACCEPT_LIST_ONLY = 0x1
    CHECK_INITIATORS_IDENTITY = 0x2
    FILTER_ACCEPT_LIST_AND_INITIATORS_IDENTITY = 0x3

@dataclass
class LeSetScanParameters(Command):
    le_scan_type: LeScanType = field(kw_only=True, default=LeScanType.PASSIVE)
    le_scan_interval: int = field(kw_only=True, default=0)
    le_scan_window: int = field(kw_only=True, default=0)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    scanning_filter_policy: LeScanningFilterPolicy = field(kw_only=True, default=LeScanningFilterPolicy.ACCEPT_ALL)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_SCAN_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetScanParameters', bytes]:
        if fields['op_code'] != OpCode.LE_SET_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['le_scan_type'] = LeScanType(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['le_scan_interval'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['le_scan_window'] = value_
        fields['own_address_type'] = OwnAddressType(span[5])
        fields['scanning_filter_policy'] = LeScanningFilterPolicy(span[6])
        span = span[7:]
        return LeSetScanParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.le_scan_type << 0))
        if self.le_scan_interval > 65535:
            print(f"Invalid value for field LeSetScanParameters::le_scan_interval: {self.le_scan_interval} > 65535; the value will be truncated")
            self.le_scan_interval &= 65535
        _span.extend(int.to_bytes((self.le_scan_interval << 0), length=2, byteorder='little'))
        if self.le_scan_window > 65535:
            print(f"Invalid value for field LeSetScanParameters::le_scan_window: {self.le_scan_window} > 65535; the value will be truncated")
            self.le_scan_window &= 65535
        _span.extend(int.to_bytes((self.le_scan_window << 0), length=2, byteorder='little'))
        _span.append((self.own_address_type << 0))
        _span.append((self.scanning_filter_policy << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeSetScanParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_SCAN_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetScanParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetScanParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetScanEnable(Command):
    le_scan_enable: Enable = field(kw_only=True, default=Enable.DISABLED)
    filter_duplicates: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_SCAN_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetScanEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['le_scan_enable'] = Enable(span[0])
        fields['filter_duplicates'] = Enable(span[1])
        span = span[2:]
        return LeSetScanEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.le_scan_enable << 0))
        _span.append((self.filter_duplicates << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetScanEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_SCAN_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetScanEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetScanEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class InitiatorFilterPolicy(enum.IntEnum):
    USE_PEER_ADDRESS = 0x0
    USE_FILTER_ACCEPT_LIST_WITH_PEER_ADDRESS = 0x1
    USE_DECISION_PDUS = 0x2
    USE_FILTER_ACCEPT_LIST_WITH_DECISION_PDUS = 0x3

@dataclass
class LeCreateConnection(Command):
    le_scan_interval: int = field(kw_only=True, default=0)
    le_scan_window: int = field(kw_only=True, default=0)
    initiator_filter_policy: InitiatorFilterPolicy = field(kw_only=True, default=InitiatorFilterPolicy.USE_PEER_ADDRESS)
    peer_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    connection_interval_min: int = field(kw_only=True, default=0)
    connection_interval_max: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)
    min_ce_length: int = field(kw_only=True, default=0)
    max_ce_length: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CREATE_CONNECTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateConnection', bytes]:
        if fields['op_code'] != OpCode.LE_CREATE_CONNECTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 25:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['le_scan_interval'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['le_scan_window'] = value_
        fields['initiator_filter_policy'] = InitiatorFilterPolicy(span[4])
        fields['peer_address_type'] = AddressType(span[5])
        fields['peer_address'] = Address.parse_all(span[6:12])
        fields['own_address_type'] = OwnAddressType(span[12])
        value_ = int.from_bytes(span[13:15], byteorder='little')
        fields['connection_interval_min'] = value_
        value_ = int.from_bytes(span[15:17], byteorder='little')
        fields['connection_interval_max'] = value_
        value_ = int.from_bytes(span[17:19], byteorder='little')
        fields['max_latency'] = value_
        value_ = int.from_bytes(span[19:21], byteorder='little')
        fields['supervision_timeout'] = value_
        value_ = int.from_bytes(span[21:23], byteorder='little')
        fields['min_ce_length'] = value_
        value_ = int.from_bytes(span[23:25], byteorder='little')
        fields['max_ce_length'] = value_
        span = span[25:]
        return LeCreateConnection(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.le_scan_interval > 65535:
            print(f"Invalid value for field LeCreateConnection::le_scan_interval: {self.le_scan_interval} > 65535; the value will be truncated")
            self.le_scan_interval &= 65535
        _span.extend(int.to_bytes((self.le_scan_interval << 0), length=2, byteorder='little'))
        if self.le_scan_window > 65535:
            print(f"Invalid value for field LeCreateConnection::le_scan_window: {self.le_scan_window} > 65535; the value will be truncated")
            self.le_scan_window &= 65535
        _span.extend(int.to_bytes((self.le_scan_window << 0), length=2, byteorder='little'))
        _span.append((self.initiator_filter_policy << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        _span.append((self.own_address_type << 0))
        if self.connection_interval_min > 65535:
            print(f"Invalid value for field LeCreateConnection::connection_interval_min: {self.connection_interval_min} > 65535; the value will be truncated")
            self.connection_interval_min &= 65535
        _span.extend(int.to_bytes((self.connection_interval_min << 0), length=2, byteorder='little'))
        if self.connection_interval_max > 65535:
            print(f"Invalid value for field LeCreateConnection::connection_interval_max: {self.connection_interval_max} > 65535; the value will be truncated")
            self.connection_interval_max &= 65535
        _span.extend(int.to_bytes((self.connection_interval_max << 0), length=2, byteorder='little'))
        if self.max_latency > 65535:
            print(f"Invalid value for field LeCreateConnection::max_latency: {self.max_latency} > 65535; the value will be truncated")
            self.max_latency &= 65535
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 65535:
            print(f"Invalid value for field LeCreateConnection::supervision_timeout: {self.supervision_timeout} > 65535; the value will be truncated")
            self.supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        if self.min_ce_length > 65535:
            print(f"Invalid value for field LeCreateConnection::min_ce_length: {self.min_ce_length} > 65535; the value will be truncated")
            self.min_ce_length &= 65535
        _span.extend(int.to_bytes((self.min_ce_length << 0), length=2, byteorder='little'))
        if self.max_ce_length > 65535:
            print(f"Invalid value for field LeCreateConnection::max_ce_length: {self.max_ce_length} > 65535; the value will be truncated")
            self.max_ce_length &= 65535
        _span.extend(int.to_bytes((self.max_ce_length << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 25

@dataclass
class LeCreateConnectionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CREATE_CONNECTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateConnectionStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CREATE_CONNECTION:
            raise Exception("Invalid constraint field values")
        return LeCreateConnectionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCreateConnectionCancel(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_CREATE_CONNECTION_CANCEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateConnectionCancel', bytes]:
        if fields['op_code'] != OpCode.LE_CREATE_CONNECTION_CANCEL:
            raise Exception("Invalid constraint field values")
        return LeCreateConnectionCancel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCreateConnectionCancelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CREATE_CONNECTION_CANCEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateConnectionCancelComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CREATE_CONNECTION_CANCEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeCreateConnectionCancelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadFilterAcceptListSize(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_FILTER_ACCEPT_LIST_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadFilterAcceptListSize', bytes]:
        if fields['op_code'] != OpCode.LE_READ_FILTER_ACCEPT_LIST_SIZE:
            raise Exception("Invalid constraint field values")
        return LeReadFilterAcceptListSize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadFilterAcceptListSizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    filter_accept_list_size: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_FILTER_ACCEPT_LIST_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadFilterAcceptListSizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_FILTER_ACCEPT_LIST_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['filter_accept_list_size'] = span[1]
        span = span[2:]
        return LeReadFilterAcceptListSizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.filter_accept_list_size > 255:
            print(f"Invalid value for field LeReadFilterAcceptListSizeComplete::filter_accept_list_size: {self.filter_accept_list_size} > 255; the value will be truncated")
            self.filter_accept_list_size &= 255
        _span.append((self.filter_accept_list_size << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeClearFilterAcceptList(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_CLEAR_FILTER_ACCEPT_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearFilterAcceptList', bytes]:
        if fields['op_code'] != OpCode.LE_CLEAR_FILTER_ACCEPT_LIST:
            raise Exception("Invalid constraint field values")
        return LeClearFilterAcceptList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeClearFilterAcceptListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CLEAR_FILTER_ACCEPT_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearFilterAcceptListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CLEAR_FILTER_ACCEPT_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeClearFilterAcceptListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class FilterAcceptListAddressType(enum.IntEnum):
    PUBLIC = 0x0
    RANDOM = 0x1
    ANONYMOUS_ADVERTISERS = 0xff

@dataclass
class LeAddDeviceToFilterAcceptList(Command):
    address_type: FilterAcceptListAddressType = field(kw_only=True, default=FilterAcceptListAddressType.PUBLIC)
    address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAddDeviceToFilterAcceptList', bytes]:
        if fields['op_code'] != OpCode.LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['address_type'] = FilterAcceptListAddressType(span[0])
        fields['address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeAddDeviceToFilterAcceptList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.address_type << 0))
        _span.extend(self.address.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeAddDeviceToFilterAcceptListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAddDeviceToFilterAcceptListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeAddDeviceToFilterAcceptListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeRemoveDeviceFromFilterAcceptList(Command):
    address_type: FilterAcceptListAddressType = field(kw_only=True, default=FilterAcceptListAddressType.PUBLIC)
    address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveDeviceFromFilterAcceptList', bytes]:
        if fields['op_code'] != OpCode.LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['address_type'] = FilterAcceptListAddressType(span[0])
        fields['address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeRemoveDeviceFromFilterAcceptList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.address_type << 0))
        _span.extend(self.address.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeRemoveDeviceFromFilterAcceptListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveDeviceFromFilterAcceptListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeRemoveDeviceFromFilterAcceptListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeConnectionUpdate(Command):
    connection_handle: int = field(kw_only=True, default=0)
    connection_interval_min: int = field(kw_only=True, default=0)
    connection_interval_max: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)
    min_ce_length: int = field(kw_only=True, default=0)
    max_ce_length: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CONNECTION_UPDATE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeConnectionUpdate', bytes]:
        if fields['op_code'] != OpCode.LE_CONNECTION_UPDATE:
            raise Exception("Invalid constraint field values")
        if len(span) < 14:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['connection_interval_min'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['connection_interval_max'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['max_latency'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['supervision_timeout'] = value_
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['min_ce_length'] = value_
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['max_ce_length'] = value_
        span = span[14:]
        return LeConnectionUpdate(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeConnectionUpdate::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.connection_interval_min > 65535:
            print(f"Invalid value for field LeConnectionUpdate::connection_interval_min: {self.connection_interval_min} > 65535; the value will be truncated")
            self.connection_interval_min &= 65535
        _span.extend(int.to_bytes((self.connection_interval_min << 0), length=2, byteorder='little'))
        if self.connection_interval_max > 65535:
            print(f"Invalid value for field LeConnectionUpdate::connection_interval_max: {self.connection_interval_max} > 65535; the value will be truncated")
            self.connection_interval_max &= 65535
        _span.extend(int.to_bytes((self.connection_interval_max << 0), length=2, byteorder='little'))
        if self.max_latency > 65535:
            print(f"Invalid value for field LeConnectionUpdate::max_latency: {self.max_latency} > 65535; the value will be truncated")
            self.max_latency &= 65535
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 65535:
            print(f"Invalid value for field LeConnectionUpdate::supervision_timeout: {self.supervision_timeout} > 65535; the value will be truncated")
            self.supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        if self.min_ce_length > 65535:
            print(f"Invalid value for field LeConnectionUpdate::min_ce_length: {self.min_ce_length} > 65535; the value will be truncated")
            self.min_ce_length &= 65535
        _span.extend(int.to_bytes((self.min_ce_length << 0), length=2, byteorder='little'))
        if self.max_ce_length > 65535:
            print(f"Invalid value for field LeConnectionUpdate::max_ce_length: {self.max_ce_length} > 65535; the value will be truncated")
            self.max_ce_length &= 65535
        _span.extend(int.to_bytes((self.max_ce_length << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 14

@dataclass
class LeConnectionUpdateStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CONNECTION_UPDATE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeConnectionUpdateStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CONNECTION_UPDATE:
            raise Exception("Invalid constraint field values")
        return LeConnectionUpdateStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeSetHostChannelClassification(Command):
    channel_map: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_HOST_CHANNEL_CLASSIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetHostChannelClassification', bytes]:
        if fields['op_code'] != OpCode.LE_SET_HOST_CHANNEL_CLASSIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['channel_map'] = list(span[:5])
        span = span[5:]
        return LeSetHostChannelClassification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.channel_map)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class LeSetHostChannelClassificationComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_HOST_CHANNEL_CLASSIFICATION
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetHostChannelClassificationComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_HOST_CHANNEL_CLASSIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetHostChannelClassificationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadChannelMap(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_CHANNEL_MAP

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadChannelMap', bytes]:
        if fields['op_code'] != OpCode.LE_READ_CHANNEL_MAP:
            raise Exception("Invalid constraint field values")
        return LeReadChannelMap(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadChannelMapComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    channel_map: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_CHANNEL_MAP
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadChannelMapComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_CHANNEL_MAP:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['channel_map'] = list(span[:5])
        span = span[5:]
        return LeReadChannelMapComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadChannelMapComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.channel_map)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeReadRemoteFeaturesPage0(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_REMOTE_FEATURES_PAGE_0

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadRemoteFeaturesPage0', bytes]:
        if fields['op_code'] != OpCode.LE_READ_REMOTE_FEATURES_PAGE_0:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeReadRemoteFeaturesPage0(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadRemoteFeaturesPage0::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeReadRemoteFeaturesPage0Status(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_REMOTE_FEATURES_PAGE_0
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadRemoteFeaturesPage0Status', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_REMOTE_FEATURES_PAGE_0:
            raise Exception("Invalid constraint field values")
        return LeReadRemoteFeaturesPage0Status(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadRemoteFeaturesPage0Complete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    le_features: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_READ_REMOTE_FEATURES_PAGE_0_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadRemoteFeaturesPage0Complete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_READ_REMOTE_FEATURES_PAGE_0_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:11], byteorder='little')
        fields['le_features'] = value_
        span = span[11:]
        return LeReadRemoteFeaturesPage0Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadRemoteFeaturesPage0Complete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.le_features > 18446744073709551615:
            print(f"Invalid value for field LeReadRemoteFeaturesPage0Complete::le_features: {self.le_features} > 18446744073709551615; the value will be truncated")
            self.le_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.le_features << 0), length=8, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

@dataclass
class LeReadAllRemoteFeatures(Command):
    connection_handle: int = field(kw_only=True, default=0)
    pages_requested: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_ALL_REMOTE_FEATURES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadAllRemoteFeatures', bytes]:
        if fields['op_code'] != OpCode.LE_READ_ALL_REMOTE_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['pages_requested'] = span[2]
        span = span[3:]
        return LeReadAllRemoteFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadAllRemoteFeatures::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.pages_requested > 255:
            print(f"Invalid value for field LeReadAllRemoteFeatures::pages_requested: {self.pages_requested} > 255; the value will be truncated")
            self.pages_requested &= 255
        _span.append((self.pages_requested << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeReadAllRemoteFeaturesStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_ALL_REMOTE_FEATURES
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadAllRemoteFeaturesStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_ALL_REMOTE_FEATURES:
            raise Exception("Invalid constraint field values")
        return LeReadAllRemoteFeaturesStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadAllRemoteFeaturesComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    max_remote_page: int = field(kw_only=True, default=0)
    max_valid_page: int = field(kw_only=True, default=0)
    le_features: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_READ_ALL_REMOTE_FEATURES_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadAllRemoteFeaturesComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_READ_ALL_REMOTE_FEATURES_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['max_remote_page'] = span[3]
        fields['max_valid_page'] = span[4]
        span = span[5:]
        if len(span) < 248:
            raise Exception('Invalid packet size')
        fields['le_features'] = list(span[:248])
        span = span[248:]
        return LeReadAllRemoteFeaturesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadAllRemoteFeaturesComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.max_remote_page > 255:
            print(f"Invalid value for field LeReadAllRemoteFeaturesComplete::max_remote_page: {self.max_remote_page} > 255; the value will be truncated")
            self.max_remote_page &= 255
        _span.append((self.max_remote_page << 0))
        if self.max_valid_page > 255:
            print(f"Invalid value for field LeReadAllRemoteFeaturesComplete::max_valid_page: {self.max_valid_page} > 255; the value will be truncated")
            self.max_valid_page &= 255
        _span.append((self.max_valid_page << 0))
        _span.extend(self.le_features)
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 253

@dataclass
class LeEncrypt(Command):
    key: bytearray = field(kw_only=True, default_factory=bytearray)
    plaintext_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_ENCRYPT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEncrypt', bytes]:
        if fields['op_code'] != OpCode.LE_ENCRYPT:
            raise Exception("Invalid constraint field values")
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['key'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['plaintext_data'] = list(span[:16])
        span = span[16:]
        return LeEncrypt(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.key)
        _span.extend(self.plaintext_data)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 32

@dataclass
class LeEncryptComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    encrypted_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_ENCRYPT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEncryptComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_ENCRYPT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['encrypted_data'] = list(span[:16])
        span = span[16:]
        return LeEncryptComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.encrypted_data)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 17

@dataclass
class LeRand(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_RAND

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRand', bytes]:
        if fields['op_code'] != OpCode.LE_RAND:
            raise Exception("Invalid constraint field values")
        return LeRand(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeRandComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    random_number: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_RAND
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRandComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_RAND:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:9], byteorder='little')
        fields['random_number'] = value_
        span = span[9:]
        return LeRandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.random_number > 18446744073709551615:
            print(f"Invalid value for field LeRandComplete::random_number: {self.random_number} > 18446744073709551615; the value will be truncated")
            self.random_number &= 18446744073709551615
        _span.extend(int.to_bytes((self.random_number << 0), length=8, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class LeStartEncryption(Command):
    connection_handle: int = field(kw_only=True, default=0)
    rand: bytearray = field(kw_only=True, default_factory=bytearray)
    ediv: int = field(kw_only=True, default=0)
    ltk: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_START_ENCRYPTION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeStartEncryption', bytes]:
        if fields['op_code'] != OpCode.LE_START_ENCRYPTION:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = value_
        span = span[2:]
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['rand'] = list(span[:8])
        span = span[8:]
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['ediv'] = value_
        span = span[2:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['ltk'] = list(span[:16])
        span = span[16:]
        return LeStartEncryption(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 65535:
            print(f"Invalid value for field LeStartEncryption::connection_handle: {self.connection_handle} > 65535; the value will be truncated")
            self.connection_handle &= 65535
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.rand)
        if self.ediv > 65535:
            print(f"Invalid value for field LeStartEncryption::ediv: {self.ediv} > 65535; the value will be truncated")
            self.ediv &= 65535
        _span.extend(int.to_bytes((self.ediv << 0), length=2, byteorder='little'))
        _span.extend(self.ltk)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 28

@dataclass
class LeStartEncryptionStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_START_ENCRYPTION
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeStartEncryptionStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_START_ENCRYPTION:
            raise Exception("Invalid constraint field values")
        return LeStartEncryptionStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeLongTermKeyRequestReply(Command):
    connection_handle: int = field(kw_only=True, default=0)
    long_term_key: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_LONG_TERM_KEY_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeLongTermKeyRequestReply', bytes]:
        if fields['op_code'] != OpCode.LE_LONG_TERM_KEY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = value_
        span = span[2:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['long_term_key'] = list(span[:16])
        span = span[16:]
        return LeLongTermKeyRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 65535:
            print(f"Invalid value for field LeLongTermKeyRequestReply::connection_handle: {self.connection_handle} > 65535; the value will be truncated")
            self.connection_handle &= 65535
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.long_term_key)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 18

@dataclass
class LeLongTermKeyRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_LONG_TERM_KEY_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeLongTermKeyRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_LONG_TERM_KEY_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeLongTermKeyRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeLongTermKeyRequestReplyComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeLongTermKeyRequestNegativeReply(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeLongTermKeyRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeLongTermKeyRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeLongTermKeyRequestNegativeReply::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeLongTermKeyRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeLongTermKeyRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeLongTermKeyRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeLongTermKeyRequestNegativeReplyComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeReadSupportedStates(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_SUPPORTED_STATES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadSupportedStates', bytes]:
        if fields['op_code'] != OpCode.LE_READ_SUPPORTED_STATES:
            raise Exception("Invalid constraint field values")
        return LeReadSupportedStates(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadSupportedStatesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    le_states: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_SUPPORTED_STATES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadSupportedStatesComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_SUPPORTED_STATES:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:9], byteorder='little')
        fields['le_states'] = value_
        span = span[9:]
        return LeReadSupportedStatesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.le_states > 18446744073709551615:
            print(f"Invalid value for field LeReadSupportedStatesComplete::le_states: {self.le_states} > 18446744073709551615; the value will be truncated")
            self.le_states &= 18446744073709551615
        _span.extend(int.to_bytes((self.le_states << 0), length=8, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class LeReceiverTest(Command):
    rx_channel: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_RECEIVER_TEST_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReceiverTest', bytes]:
        if fields['op_code'] != OpCode.LE_RECEIVER_TEST_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['rx_channel'] = span[0]
        span = span[1:]
        return LeReceiverTest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.rx_channel > 255:
            print(f"Invalid value for field LeReceiverTest::rx_channel: {self.rx_channel} > 255; the value will be truncated")
            self.rx_channel &= 255
        _span.append((self.rx_channel << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReceiverTestComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_RECEIVER_TEST_V1
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReceiverTestComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_RECEIVER_TEST_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeReceiverTestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class LeTestPayload(enum.IntEnum):
    PRBS9 = 0x0
    REPEATED_F0 = 0x1
    REPEATED_AA = 0x2
    PRBS15 = 0x3
    REPEATED_FF = 0x4
    REPEATED_00 = 0x5
    REPEATED_0F = 0x6
    REPEATED_55 = 0x7

@dataclass
class LeTransmitterTest(Command):
    tx_channel: int = field(kw_only=True, default=0)
    test_data_length: int = field(kw_only=True, default=0)
    packet_payload: LeTestPayload = field(kw_only=True, default=LeTestPayload.PRBS9)

    def __post_init__(self):
        self.op_code = OpCode.LE_TRANSMITTER_TEST_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTransmitterTest', bytes]:
        if fields['op_code'] != OpCode.LE_TRANSMITTER_TEST_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['tx_channel'] = span[0]
        fields['test_data_length'] = span[1]
        fields['packet_payload'] = LeTestPayload(span[2])
        span = span[3:]
        return LeTransmitterTest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.tx_channel > 255:
            print(f"Invalid value for field LeTransmitterTest::tx_channel: {self.tx_channel} > 255; the value will be truncated")
            self.tx_channel &= 255
        _span.append((self.tx_channel << 0))
        if self.test_data_length > 255:
            print(f"Invalid value for field LeTransmitterTest::test_data_length: {self.test_data_length} > 255; the value will be truncated")
            self.test_data_length &= 255
        _span.append((self.test_data_length << 0))
        _span.append((self.packet_payload << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeTransmitterTestComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_TRANSMITTER_TEST_V1
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTransmitterTestComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_TRANSMITTER_TEST_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeTransmitterTestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeTestEnd(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_TEST_END

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTestEnd', bytes]:
        if fields['op_code'] != OpCode.LE_TEST_END:
            raise Exception("Invalid constraint field values")
        return LeTestEnd(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeTestEndComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_TEST_END
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTestEndComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_TEST_END:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeTestEndComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeRemoteConnectionParameterRequestReply(Command):
    connection_handle: int = field(kw_only=True, default=0)
    interval_min: int = field(kw_only=True, default=0)
    interval_max: int = field(kw_only=True, default=0)
    latency: int = field(kw_only=True, default=0)
    timeout: int = field(kw_only=True, default=0)
    minimum_ce_length: int = field(kw_only=True, default=0)
    maximum_ce_length: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoteConnectionParameterRequestReply', bytes]:
        if fields['op_code'] != OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 14:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['interval_min'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['interval_max'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['latency'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['timeout'] = value_
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['minimum_ce_length'] = value_
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['maximum_ce_length'] = value_
        span = span[14:]
        return LeRemoteConnectionParameterRequestReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReply::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.interval_min > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReply::interval_min: {self.interval_min} > 65535; the value will be truncated")
            self.interval_min &= 65535
        _span.extend(int.to_bytes((self.interval_min << 0), length=2, byteorder='little'))
        if self.interval_max > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReply::interval_max: {self.interval_max} > 65535; the value will be truncated")
            self.interval_max &= 65535
        _span.extend(int.to_bytes((self.interval_max << 0), length=2, byteorder='little'))
        if self.latency > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReply::latency: {self.latency} > 65535; the value will be truncated")
            self.latency &= 65535
        _span.extend(int.to_bytes((self.latency << 0), length=2, byteorder='little'))
        if self.timeout > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReply::timeout: {self.timeout} > 65535; the value will be truncated")
            self.timeout &= 65535
        _span.extend(int.to_bytes((self.timeout << 0), length=2, byteorder='little'))
        if self.minimum_ce_length > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReply::minimum_ce_length: {self.minimum_ce_length} > 65535; the value will be truncated")
            self.minimum_ce_length &= 65535
        _span.extend(int.to_bytes((self.minimum_ce_length << 0), length=2, byteorder='little'))
        if self.maximum_ce_length > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReply::maximum_ce_length: {self.maximum_ce_length} > 65535; the value will be truncated")
            self.maximum_ce_length &= 65535
        _span.extend(int.to_bytes((self.maximum_ce_length << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 14

@dataclass
class LeRemoteConnectionParameterRequestReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoteConnectionParameterRequestReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeRemoteConnectionParameterRequestReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestReplyComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeRemoteConnectionParameterRequestNegativeReply(Command):
    connection_handle: int = field(kw_only=True, default=0)
    reason: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_NEGATIVE_REPLY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoteConnectionParameterRequestNegativeReply', bytes]:
        if fields['op_code'] != OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['reason'] = ErrorCode(span[2])
        span = span[3:]
        return LeRemoteConnectionParameterRequestNegativeReply(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestNegativeReply::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.reason << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeRemoteConnectionParameterRequestNegativeReplyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_NEGATIVE_REPLY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoteConnectionParameterRequestNegativeReplyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST_NEGATIVE_REPLY:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeRemoteConnectionParameterRequestNegativeReplyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRemoteConnectionParameterRequestNegativeReplyComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetDataLength(Command):
    connection_handle: int = field(kw_only=True, default=0)
    tx_octets: int = field(kw_only=True, default=0)
    tx_time: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_DATA_LENGTH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDataLength', bytes]:
        if fields['op_code'] != OpCode.LE_SET_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['tx_octets'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['tx_time'] = value_
        span = span[6:]
        return LeSetDataLength(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetDataLength::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.tx_octets > 65535:
            print(f"Invalid value for field LeSetDataLength::tx_octets: {self.tx_octets} > 65535; the value will be truncated")
            self.tx_octets &= 65535
        _span.extend(int.to_bytes((self.tx_octets << 0), length=2, byteorder='little'))
        if self.tx_time > 65535:
            print(f"Invalid value for field LeSetDataLength::tx_time: {self.tx_time} > 65535; the value will be truncated")
            self.tx_time &= 65535
        _span.extend(int.to_bytes((self.tx_time << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LeSetDataLengthComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_DATA_LENGTH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDataLengthComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeSetDataLengthComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetDataLengthComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeReadSuggestedDefaultDataLength(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadSuggestedDefaultDataLength', bytes]:
        if fields['op_code'] != OpCode.LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        return LeReadSuggestedDefaultDataLength(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadSuggestedDefaultDataLengthComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    tx_octets: int = field(kw_only=True, default=0)
    tx_time: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadSuggestedDefaultDataLengthComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['tx_octets'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['tx_time'] = value_
        span = span[5:]
        return LeReadSuggestedDefaultDataLengthComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.tx_octets > 65535:
            print(f"Invalid value for field LeReadSuggestedDefaultDataLengthComplete::tx_octets: {self.tx_octets} > 65535; the value will be truncated")
            self.tx_octets &= 65535
        _span.extend(int.to_bytes((self.tx_octets << 0), length=2, byteorder='little'))
        if self.tx_time > 65535:
            print(f"Invalid value for field LeReadSuggestedDefaultDataLengthComplete::tx_time: {self.tx_time} > 65535; the value will be truncated")
            self.tx_time &= 65535
        _span.extend(int.to_bytes((self.tx_time << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class LeWriteSuggestedDefaultDataLength(Command):
    tx_octets: int = field(kw_only=True, default=0)
    tx_time: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeWriteSuggestedDefaultDataLength', bytes]:
        if fields['op_code'] != OpCode.LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['tx_octets'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['tx_time'] = value_
        span = span[4:]
        return LeWriteSuggestedDefaultDataLength(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.tx_octets > 65535:
            print(f"Invalid value for field LeWriteSuggestedDefaultDataLength::tx_octets: {self.tx_octets} > 65535; the value will be truncated")
            self.tx_octets &= 65535
        _span.extend(int.to_bytes((self.tx_octets << 0), length=2, byteorder='little'))
        if self.tx_time > 65535:
            print(f"Invalid value for field LeWriteSuggestedDefaultDataLength::tx_time: {self.tx_time} > 65535; the value will be truncated")
            self.tx_time &= 65535
        _span.extend(int.to_bytes((self.tx_time << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class LeWriteSuggestedDefaultDataLengthComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeWriteSuggestedDefaultDataLengthComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeWriteSuggestedDefaultDataLengthComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadLocalP256PublicKey(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_LOCAL_P_256_PUBLIC_KEY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadLocalP256PublicKey', bytes]:
        if fields['op_code'] != OpCode.LE_READ_LOCAL_P_256_PUBLIC_KEY:
            raise Exception("Invalid constraint field values")
        return LeReadLocalP256PublicKey(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadLocalP256PublicKeyStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_LOCAL_P_256_PUBLIC_KEY
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadLocalP256PublicKeyStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_LOCAL_P_256_PUBLIC_KEY:
            raise Exception("Invalid constraint field values")
        return LeReadLocalP256PublicKeyStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeGenerateDhkeyV1(Command):
    remote_p_256_public_key: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_GENERATE_DHKEY_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGenerateDhkeyV1', bytes]:
        if fields['op_code'] != OpCode.LE_GENERATE_DHKEY_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 64:
            raise Exception('Invalid packet size')
        fields['remote_p_256_public_key'] = list(span[:64])
        span = span[64:]
        return LeGenerateDhkeyV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.remote_p_256_public_key)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 64

@dataclass
class LeGenerateDhkeyV1Status(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_GENERATE_DHKEY_V1
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGenerateDhkeyV1Status', bytes]:
        if fields['command_op_code'] != OpCode.LE_GENERATE_DHKEY_V1:
            raise Exception("Invalid constraint field values")
        return LeGenerateDhkeyV1Status(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeAddDeviceToResolvingList(Command):
    peer_identity_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_identity_address: Address = field(kw_only=True, default_factory=Address)
    peer_irk: bytearray = field(kw_only=True, default_factory=bytearray)
    local_irk: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_ADD_DEVICE_TO_RESOLVING_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAddDeviceToResolvingList', bytes]:
        if fields['op_code'] != OpCode.LE_ADD_DEVICE_TO_RESOLVING_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['peer_identity_address_type'] = PeerAddressType(span[0])
        fields['peer_identity_address'] = Address.parse_all(span[1:7])
        span = span[7:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['peer_irk'] = list(span[:16])
        span = span[16:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['local_irk'] = list(span[:16])
        span = span[16:]
        return LeAddDeviceToResolvingList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.peer_identity_address_type << 0))
        _span.extend(self.peer_identity_address.serialize())
        _span.extend(self.peer_irk)
        _span.extend(self.local_irk)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 39

@dataclass
class LeAddDeviceToResolvingListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_ADD_DEVICE_TO_RESOLVING_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAddDeviceToResolvingListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_ADD_DEVICE_TO_RESOLVING_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeAddDeviceToResolvingListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeRemoveDeviceFromResolvingList(Command):
    peer_identity_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_identity_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOVE_DEVICE_FROM_RESOLVING_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveDeviceFromResolvingList', bytes]:
        if fields['op_code'] != OpCode.LE_REMOVE_DEVICE_FROM_RESOLVING_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['peer_identity_address_type'] = PeerAddressType(span[0])
        fields['peer_identity_address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeRemoveDeviceFromResolvingList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.peer_identity_address_type << 0))
        _span.extend(self.peer_identity_address.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeRemoveDeviceFromResolvingListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOVE_DEVICE_FROM_RESOLVING_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveDeviceFromResolvingListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOVE_DEVICE_FROM_RESOLVING_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeRemoveDeviceFromResolvingListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeClearResolvingList(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_CLEAR_RESOLVING_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearResolvingList', bytes]:
        if fields['op_code'] != OpCode.LE_CLEAR_RESOLVING_LIST:
            raise Exception("Invalid constraint field values")
        return LeClearResolvingList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeClearResolvingListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CLEAR_RESOLVING_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearResolvingListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CLEAR_RESOLVING_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeClearResolvingListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadResolvingListSize(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_RESOLVING_LIST_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadResolvingListSize', bytes]:
        if fields['op_code'] != OpCode.LE_READ_RESOLVING_LIST_SIZE:
            raise Exception("Invalid constraint field values")
        return LeReadResolvingListSize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadResolvingListSizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    resolving_list_size: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_RESOLVING_LIST_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadResolvingListSizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_RESOLVING_LIST_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['resolving_list_size'] = span[1]
        span = span[2:]
        return LeReadResolvingListSizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.resolving_list_size > 255:
            print(f"Invalid value for field LeReadResolvingListSizeComplete::resolving_list_size: {self.resolving_list_size} > 255; the value will be truncated")
            self.resolving_list_size &= 255
        _span.append((self.resolving_list_size << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeReadPeerResolvableAddress(Command):
    peer_identity_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_identity_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_PEER_RESOLVABLE_ADDRESS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadPeerResolvableAddress', bytes]:
        if fields['op_code'] != OpCode.LE_READ_PEER_RESOLVABLE_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['peer_identity_address_type'] = PeerAddressType(span[0])
        fields['peer_identity_address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeReadPeerResolvableAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.peer_identity_address_type << 0))
        _span.extend(self.peer_identity_address.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeReadPeerResolvableAddressComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    peer_resolvable_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_PEER_RESOLVABLE_ADDRESS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadPeerResolvableAddressComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_PEER_RESOLVABLE_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['peer_resolvable_address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeReadPeerResolvableAddressComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.peer_resolvable_address.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeReadLocalResolvableAddress(Command):
    peer_identity_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_identity_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_LOCAL_RESOLVABLE_ADDRESS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadLocalResolvableAddress', bytes]:
        if fields['op_code'] != OpCode.LE_READ_LOCAL_RESOLVABLE_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['peer_identity_address_type'] = PeerAddressType(span[0])
        fields['peer_identity_address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeReadLocalResolvableAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.peer_identity_address_type << 0))
        _span.extend(self.peer_identity_address.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeReadLocalResolvableAddressComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    local_resolvable_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_LOCAL_RESOLVABLE_ADDRESS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadLocalResolvableAddressComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_LOCAL_RESOLVABLE_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['local_resolvable_address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeReadLocalResolvableAddressComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.local_resolvable_address.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeSetAddressResolutionEnable(Command):
    address_resolution_enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_ADDRESS_RESOLUTION_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAddressResolutionEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_ADDRESS_RESOLUTION_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['address_resolution_enable'] = Enable(span[0])
        span = span[1:]
        return LeSetAddressResolutionEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.address_resolution_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetAddressResolutionEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_ADDRESS_RESOLUTION_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAddressResolutionEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_ADDRESS_RESOLUTION_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetAddressResolutionEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetResolvablePrivateAddressTimeout(Command):
    rpa_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetResolvablePrivateAddressTimeout', bytes]:
        if fields['op_code'] != OpCode.LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['rpa_timeout'] = value_
        span = span[2:]
        return LeSetResolvablePrivateAddressTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.rpa_timeout > 65535:
            print(f"Invalid value for field LeSetResolvablePrivateAddressTimeout::rpa_timeout: {self.rpa_timeout} > 65535; the value will be truncated")
            self.rpa_timeout &= 65535
        _span.extend(int.to_bytes((self.rpa_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetResolvablePrivateAddressTimeoutComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetResolvablePrivateAddressTimeoutComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetResolvablePrivateAddressTimeoutComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadMaximumDataLength(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_MAXIMUM_DATA_LENGTH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadMaximumDataLength', bytes]:
        if fields['op_code'] != OpCode.LE_READ_MAXIMUM_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        return LeReadMaximumDataLength(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeMaximumDataLength(Packet):
    supported_max_tx_octets: int = field(kw_only=True, default=0)
    supported_max_tx_time: int = field(kw_only=True, default=0)
    supported_max_rx_octets: int = field(kw_only=True, default=0)
    supported_max_rx_time: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LeMaximumDataLength', bytes]:
        fields = {'payload': None}
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['supported_max_tx_octets'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['supported_max_tx_time'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['supported_max_rx_octets'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['supported_max_rx_time'] = value_
        span = span[8:]
        return LeMaximumDataLength(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.supported_max_tx_octets > 65535:
            print(f"Invalid value for field LeMaximumDataLength::supported_max_tx_octets: {self.supported_max_tx_octets} > 65535; the value will be truncated")
            self.supported_max_tx_octets &= 65535
        _span.extend(int.to_bytes((self.supported_max_tx_octets << 0), length=2, byteorder='little'))
        if self.supported_max_tx_time > 65535:
            print(f"Invalid value for field LeMaximumDataLength::supported_max_tx_time: {self.supported_max_tx_time} > 65535; the value will be truncated")
            self.supported_max_tx_time &= 65535
        _span.extend(int.to_bytes((self.supported_max_tx_time << 0), length=2, byteorder='little'))
        if self.supported_max_rx_octets > 65535:
            print(f"Invalid value for field LeMaximumDataLength::supported_max_rx_octets: {self.supported_max_rx_octets} > 65535; the value will be truncated")
            self.supported_max_rx_octets &= 65535
        _span.extend(int.to_bytes((self.supported_max_rx_octets << 0), length=2, byteorder='little'))
        if self.supported_max_rx_time > 65535:
            print(f"Invalid value for field LeMaximumDataLength::supported_max_rx_time: {self.supported_max_rx_time} > 65535; the value will be truncated")
            self.supported_max_rx_time &= 65535
        _span.extend(int.to_bytes((self.supported_max_rx_time << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeReadMaximumDataLengthComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    le_maximum_data_length: LeMaximumDataLength = field(kw_only=True, default_factory=LeMaximumDataLength)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_MAXIMUM_DATA_LENGTH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadMaximumDataLengthComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_MAXIMUM_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['le_maximum_data_length'] = LeMaximumDataLength.parse_all(span[1:9])
        span = span[9:]
        return LeReadMaximumDataLengthComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.le_maximum_data_length.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class LeReadPhy(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_PHY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadPhy', bytes]:
        if fields['op_code'] != OpCode.LE_READ_PHY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeReadPhy(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadPhy::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class PhyType(enum.IntEnum):
    LE_1M = 0x1
    LE_2M = 0x2
    LE_CODED = 0x3

@dataclass
class LeReadPhyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    tx_phy: PhyType = field(kw_only=True, default=PhyType.LE_1M)
    rx_phy: PhyType = field(kw_only=True, default=PhyType.LE_1M)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_PHY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadPhyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_PHY:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['tx_phy'] = PhyType(span[3])
        fields['rx_phy'] = PhyType(span[4])
        span = span[5:]
        return LeReadPhyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadPhyComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.tx_phy << 0))
        _span.append((self.rx_phy << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class LeSetDefaultPhy(Command):
    all_phys_no_transmit_preference: int = field(kw_only=True, default=0)
    all_phys_no_receive_preference: int = field(kw_only=True, default=0)
    tx_phys: int = field(kw_only=True, default=0)
    rx_phys: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_DEFAULT_PHY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDefaultPhy', bytes]:
        if fields['op_code'] != OpCode.LE_SET_DEFAULT_PHY:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['all_phys_no_transmit_preference'] = (span[0] >> 0) & 0x1
        fields['all_phys_no_receive_preference'] = (span[0] >> 1) & 0x1
        fields['tx_phys'] = (span[1] >> 0) & 0x7
        fields['rx_phys'] = (span[2] >> 0) & 0x7
        span = span[3:]
        return LeSetDefaultPhy(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.all_phys_no_transmit_preference > 1:
            print(f"Invalid value for field LeSetDefaultPhy::all_phys_no_transmit_preference: {self.all_phys_no_transmit_preference} > 1; the value will be truncated")
            self.all_phys_no_transmit_preference &= 1
        if self.all_phys_no_receive_preference > 1:
            print(f"Invalid value for field LeSetDefaultPhy::all_phys_no_receive_preference: {self.all_phys_no_receive_preference} > 1; the value will be truncated")
            self.all_phys_no_receive_preference &= 1
        _value = (
            (self.all_phys_no_transmit_preference << 0) |
            (self.all_phys_no_receive_preference << 1)
        )
        _span.append(_value)
        if self.tx_phys > 7:
            print(f"Invalid value for field LeSetDefaultPhy::tx_phys: {self.tx_phys} > 7; the value will be truncated")
            self.tx_phys &= 7
        _span.append((self.tx_phys << 0))
        if self.rx_phys > 7:
            print(f"Invalid value for field LeSetDefaultPhy::rx_phys: {self.rx_phys} > 7; the value will be truncated")
            self.rx_phys &= 7
        _span.append((self.rx_phys << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetDefaultPhyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_DEFAULT_PHY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDefaultPhyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_DEFAULT_PHY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetDefaultPhyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class PhyOptions(enum.IntEnum):
    NO_PREFERENCE = 0x0
    S_2 = 0x1
    S_8 = 0x2

@dataclass
class LeSetPhy(Command):
    connection_handle: int = field(kw_only=True, default=0)
    all_phys_no_transmit_preference: int = field(kw_only=True, default=0)
    all_phys_no_receive_preference: int = field(kw_only=True, default=0)
    tx_phys: int = field(kw_only=True, default=0)
    rx_phys: int = field(kw_only=True, default=0)
    phy_options: PhyOptions = field(kw_only=True, default=PhyOptions.NO_PREFERENCE)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PHY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPhy', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PHY:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['all_phys_no_transmit_preference'] = (span[2] >> 0) & 0x1
        fields['all_phys_no_receive_preference'] = (span[2] >> 1) & 0x1
        fields['tx_phys'] = (span[3] >> 0) & 0x7
        fields['rx_phys'] = (span[4] >> 0) & 0x7
        fields['phy_options'] = PhyOptions(span[5])
        span = span[6:]
        return LeSetPhy(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetPhy::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.all_phys_no_transmit_preference > 1:
            print(f"Invalid value for field LeSetPhy::all_phys_no_transmit_preference: {self.all_phys_no_transmit_preference} > 1; the value will be truncated")
            self.all_phys_no_transmit_preference &= 1
        if self.all_phys_no_receive_preference > 1:
            print(f"Invalid value for field LeSetPhy::all_phys_no_receive_preference: {self.all_phys_no_receive_preference} > 1; the value will be truncated")
            self.all_phys_no_receive_preference &= 1
        _value = (
            (self.all_phys_no_transmit_preference << 0) |
            (self.all_phys_no_receive_preference << 1)
        )
        _span.append(_value)
        if self.tx_phys > 7:
            print(f"Invalid value for field LeSetPhy::tx_phys: {self.tx_phys} > 7; the value will be truncated")
            self.tx_phys &= 7
        _span.append((self.tx_phys << 0))
        if self.rx_phys > 7:
            print(f"Invalid value for field LeSetPhy::rx_phys: {self.rx_phys} > 7; the value will be truncated")
            self.rx_phys &= 7
        _span.append((self.rx_phys << 0))
        _span.append((self.phy_options << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LeSetPhyStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PHY
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPhyStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PHY:
            raise Exception("Invalid constraint field values")
        return LeSetPhyStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class ModulationIndex(enum.IntEnum):
    STANDARD = 0x0
    STABLE = 0x1

@dataclass
class LeEnhancedReceiverTest(Command):
    rx_channel: int = field(kw_only=True, default=0)
    phy: PhyType = field(kw_only=True, default=PhyType.LE_1M)
    modulation_index: ModulationIndex = field(kw_only=True, default=ModulationIndex.STANDARD)

    def __post_init__(self):
        self.op_code = OpCode.LE_RECEIVER_TEST_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedReceiverTest', bytes]:
        if fields['op_code'] != OpCode.LE_RECEIVER_TEST_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['rx_channel'] = span[0]
        fields['phy'] = PhyType(span[1])
        fields['modulation_index'] = ModulationIndex(span[2])
        span = span[3:]
        return LeEnhancedReceiverTest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.rx_channel > 255:
            print(f"Invalid value for field LeEnhancedReceiverTest::rx_channel: {self.rx_channel} > 255; the value will be truncated")
            self.rx_channel &= 255
        _span.append((self.rx_channel << 0))
        _span.append((self.phy << 0))
        _span.append((self.modulation_index << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeEnhancedReceiverTestComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_RECEIVER_TEST_V2
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedReceiverTestComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_RECEIVER_TEST_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeEnhancedReceiverTestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeEnhancedTransmitterTest(Command):
    tx_channel: int = field(kw_only=True, default=0)
    test_data_length: int = field(kw_only=True, default=0)
    packet_payload: LeTestPayload = field(kw_only=True, default=LeTestPayload.PRBS9)
    phy: PhyType = field(kw_only=True, default=PhyType.LE_1M)

    def __post_init__(self):
        self.op_code = OpCode.LE_TRANSMITTER_TEST_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedTransmitterTest', bytes]:
        if fields['op_code'] != OpCode.LE_TRANSMITTER_TEST_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['tx_channel'] = span[0]
        fields['test_data_length'] = span[1]
        fields['packet_payload'] = LeTestPayload(span[2])
        fields['phy'] = PhyType(span[3])
        span = span[4:]
        return LeEnhancedTransmitterTest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.tx_channel > 255:
            print(f"Invalid value for field LeEnhancedTransmitterTest::tx_channel: {self.tx_channel} > 255; the value will be truncated")
            self.tx_channel &= 255
        _span.append((self.tx_channel << 0))
        if self.test_data_length > 255:
            print(f"Invalid value for field LeEnhancedTransmitterTest::test_data_length: {self.test_data_length} > 255; the value will be truncated")
            self.test_data_length &= 255
        _span.append((self.test_data_length << 0))
        _span.append((self.packet_payload << 0))
        _span.append((self.phy << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class LeEnhancedTransmitterTestComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_TRANSMITTER_TEST_V2
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedTransmitterTestComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_TRANSMITTER_TEST_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeEnhancedTransmitterTestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetAdvertisingSetRandomAddress(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    random_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_ADVERTISING_SET_RANDOM_ADDRESS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingSetRandomAddress', bytes]:
        if fields['op_code'] != OpCode.LE_SET_ADVERTISING_SET_RANDOM_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['random_address'] = Address.parse_all(span[1:7])
        span = span[7:]
        return LeSetAdvertisingSetRandomAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetAdvertisingSetRandomAddress::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.extend(self.random_address.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeSetAdvertisingSetRandomAddressComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_ADVERTISING_SET_RANDOM_ADDRESS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetAdvertisingSetRandomAddressComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_ADVERTISING_SET_RANDOM_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetAdvertisingSetRandomAddressComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class LegacyAdvertisingEventProperties(enum.IntEnum):
    ADV_IND = 0x3
    ADV_DIRECT_IND_LOW = 0x5
    ADV_DIRECT_IND_HIGH = 0xd
    ADV_SCAN_IND = 0x2
    ADV_NONCONN_IND = 0x0

@dataclass
class AdvertisingEventProperties(Packet):
    connectable: int = field(kw_only=True, default=0)
    scannable: int = field(kw_only=True, default=0)
    directed: int = field(kw_only=True, default=0)
    high_duty_cycle: int = field(kw_only=True, default=0)
    legacy: int = field(kw_only=True, default=0)
    anonymous: int = field(kw_only=True, default=0)
    include_tx_power: int = field(kw_only=True, default=0)
    decision: int = field(kw_only=True, default=0)
    include_adva: int = field(kw_only=True, default=0)
    include_adi: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['AdvertisingEventProperties', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['connectable'] = (span[0] >> 0) & 0x1
        fields['scannable'] = (span[0] >> 1) & 0x1
        fields['directed'] = (span[0] >> 2) & 0x1
        fields['high_duty_cycle'] = (span[0] >> 3) & 0x1
        fields['legacy'] = (span[0] >> 4) & 0x1
        fields['anonymous'] = (span[0] >> 5) & 0x1
        fields['include_tx_power'] = (span[0] >> 6) & 0x1
        fields['decision'] = (span[0] >> 7) & 0x1
        fields['include_adva'] = (span[1] >> 0) & 0x1
        fields['include_adi'] = (span[1] >> 1) & 0x1
        span = span[2:]
        return AdvertisingEventProperties(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connectable > 1:
            print(f"Invalid value for field AdvertisingEventProperties::connectable: {self.connectable} > 1; the value will be truncated")
            self.connectable &= 1
        if self.scannable > 1:
            print(f"Invalid value for field AdvertisingEventProperties::scannable: {self.scannable} > 1; the value will be truncated")
            self.scannable &= 1
        if self.directed > 1:
            print(f"Invalid value for field AdvertisingEventProperties::directed: {self.directed} > 1; the value will be truncated")
            self.directed &= 1
        if self.high_duty_cycle > 1:
            print(f"Invalid value for field AdvertisingEventProperties::high_duty_cycle: {self.high_duty_cycle} > 1; the value will be truncated")
            self.high_duty_cycle &= 1
        if self.legacy > 1:
            print(f"Invalid value for field AdvertisingEventProperties::legacy: {self.legacy} > 1; the value will be truncated")
            self.legacy &= 1
        if self.anonymous > 1:
            print(f"Invalid value for field AdvertisingEventProperties::anonymous: {self.anonymous} > 1; the value will be truncated")
            self.anonymous &= 1
        if self.include_tx_power > 1:
            print(f"Invalid value for field AdvertisingEventProperties::include_tx_power: {self.include_tx_power} > 1; the value will be truncated")
            self.include_tx_power &= 1
        if self.decision > 1:
            print(f"Invalid value for field AdvertisingEventProperties::decision: {self.decision} > 1; the value will be truncated")
            self.decision &= 1
        _value = (
            (self.connectable << 0) |
            (self.scannable << 1) |
            (self.directed << 2) |
            (self.high_duty_cycle << 3) |
            (self.legacy << 4) |
            (self.anonymous << 5) |
            (self.include_tx_power << 6) |
            (self.decision << 7)
        )
        _span.append(_value)
        if self.include_adva > 1:
            print(f"Invalid value for field AdvertisingEventProperties::include_adva: {self.include_adva} > 1; the value will be truncated")
            self.include_adva &= 1
        if self.include_adi > 1:
            print(f"Invalid value for field AdvertisingEventProperties::include_adi: {self.include_adi} > 1; the value will be truncated")
            self.include_adi &= 1
        _value = (
            (self.include_adva << 0) |
            (self.include_adi << 1)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

class PrimaryPhyType(enum.IntEnum):
    LE_1M = 0x1
    LE_CODED = 0x3

class SecondaryPhyType(enum.IntEnum):
    NO_PACKETS = 0x0
    LE_1M = 0x1
    LE_2M = 0x2
    LE_CODED = 0x3

class AdvertisingPhyOptions(enum.IntEnum):
    NO_PREFERENCE = 0x0
    S2_CODING_PREFERRED = 0x1
    S8_CODING_PREFERRED = 0x2
    S2_CODING_REQUIRED = 0x3
    S8_CODING_REQUIRED = 0x4

@dataclass
class LeSetExtendedAdvertisingParametersV1(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    advertising_event_properties: AdvertisingEventProperties = field(kw_only=True, default_factory=AdvertisingEventProperties)
    primary_advertising_interval_min: int = field(kw_only=True, default=0)
    primary_advertising_interval_max: int = field(kw_only=True, default=0)
    primary_advertising_channel_map: int = field(kw_only=True, default=0)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    advertising_filter_policy: AdvertisingFilterPolicy = field(kw_only=True, default=AdvertisingFilterPolicy.ALL_DEVICES)
    advertising_tx_power: int = field(kw_only=True, default=0)
    primary_advertising_phy: PrimaryPhyType = field(kw_only=True, default=PrimaryPhyType.LE_1M)
    secondary_advertising_max_skip: int = field(kw_only=True, default=0)
    secondary_advertising_phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    advertising_sid: int = field(kw_only=True, default=0)
    scan_request_notification_enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingParametersV1', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 25:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['advertising_event_properties'] = AdvertisingEventProperties.parse_all(span[1:3])
        value_ = int.from_bytes(span[3:6], byteorder='little')
        fields['primary_advertising_interval_min'] = value_
        value_ = int.from_bytes(span[6:9], byteorder='little')
        fields['primary_advertising_interval_max'] = value_
        fields['primary_advertising_channel_map'] = (span[9] >> 0) & 0x7
        fields['own_address_type'] = OwnAddressType(span[10])
        fields['peer_address_type'] = PeerAddressType(span[11])
        fields['peer_address'] = Address.parse_all(span[12:18])
        fields['advertising_filter_policy'] = AdvertisingFilterPolicy((span[18] >> 0) & 0x3)
        fields['advertising_tx_power'] = span[19]
        fields['primary_advertising_phy'] = PrimaryPhyType(span[20])
        fields['secondary_advertising_max_skip'] = span[21]
        fields['secondary_advertising_phy'] = SecondaryPhyType(span[22])
        fields['advertising_sid'] = span[23]
        fields['scan_request_notification_enable'] = Enable(span[24])
        span = span[25:]
        return LeSetExtendedAdvertisingParametersV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.extend(self.advertising_event_properties.serialize())
        if self.primary_advertising_interval_min > 16777215:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1::primary_advertising_interval_min: {self.primary_advertising_interval_min} > 16777215; the value will be truncated")
            self.primary_advertising_interval_min &= 16777215
        _span.extend(int.to_bytes((self.primary_advertising_interval_min << 0), length=3, byteorder='little'))
        if self.primary_advertising_interval_max > 16777215:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1::primary_advertising_interval_max: {self.primary_advertising_interval_max} > 16777215; the value will be truncated")
            self.primary_advertising_interval_max &= 16777215
        _span.extend(int.to_bytes((self.primary_advertising_interval_max << 0), length=3, byteorder='little'))
        if self.primary_advertising_channel_map > 7:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1::primary_advertising_channel_map: {self.primary_advertising_channel_map} > 7; the value will be truncated")
            self.primary_advertising_channel_map &= 7
        _span.append((self.primary_advertising_channel_map << 0))
        _span.append((self.own_address_type << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        _span.append((self.advertising_filter_policy << 0))
        if self.advertising_tx_power > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1::advertising_tx_power: {self.advertising_tx_power} > 255; the value will be truncated")
            self.advertising_tx_power &= 255
        _span.append((self.advertising_tx_power << 0))
        _span.append((self.primary_advertising_phy << 0))
        if self.secondary_advertising_max_skip > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1::secondary_advertising_max_skip: {self.secondary_advertising_max_skip} > 255; the value will be truncated")
            self.secondary_advertising_max_skip &= 255
        _span.append((self.secondary_advertising_max_skip << 0))
        _span.append((self.secondary_advertising_phy << 0))
        if self.advertising_sid > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        _span.append((self.scan_request_notification_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 25

@dataclass
class LeSetExtendedAdvertisingParametersV1Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    selected_tx_power: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V1
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingParametersV1Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['selected_tx_power'] = span[1]
        span = span[2:]
        return LeSetExtendedAdvertisingParametersV1Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.selected_tx_power > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV1Complete::selected_tx_power: {self.selected_tx_power} > 255; the value will be truncated")
            self.selected_tx_power &= 255
        _span.append((self.selected_tx_power << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetExtendedAdvertisingParametersV2(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    advertising_event_properties: AdvertisingEventProperties = field(kw_only=True, default_factory=AdvertisingEventProperties)
    primary_advertising_interval_min: int = field(kw_only=True, default=0)
    primary_advertising_interval_max: int = field(kw_only=True, default=0)
    primary_advertising_channel_map: int = field(kw_only=True, default=0)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    advertising_filter_policy: AdvertisingFilterPolicy = field(kw_only=True, default=AdvertisingFilterPolicy.ALL_DEVICES)
    advertising_tx_power: int = field(kw_only=True, default=0)
    primary_advertising_phy: PrimaryPhyType = field(kw_only=True, default=PrimaryPhyType.LE_1M)
    secondary_advertising_max_skip: int = field(kw_only=True, default=0)
    secondary_advertising_phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    advertising_sid: int = field(kw_only=True, default=0)
    scan_request_notification_enable: Enable = field(kw_only=True, default=Enable.DISABLED)
    primary_advertising_phy_options: AdvertisingPhyOptions = field(kw_only=True, default=AdvertisingPhyOptions.NO_PREFERENCE)
    secondary_advertising_phy_options: AdvertisingPhyOptions = field(kw_only=True, default=AdvertisingPhyOptions.NO_PREFERENCE)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingParametersV2', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 27:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['advertising_event_properties'] = AdvertisingEventProperties.parse_all(span[1:3])
        value_ = int.from_bytes(span[3:6], byteorder='little')
        fields['primary_advertising_interval_min'] = value_
        value_ = int.from_bytes(span[6:9], byteorder='little')
        fields['primary_advertising_interval_max'] = value_
        fields['primary_advertising_channel_map'] = (span[9] >> 0) & 0x7
        fields['own_address_type'] = OwnAddressType(span[10])
        fields['peer_address_type'] = PeerAddressType(span[11])
        fields['peer_address'] = Address.parse_all(span[12:18])
        fields['advertising_filter_policy'] = AdvertisingFilterPolicy((span[18] >> 0) & 0x3)
        fields['advertising_tx_power'] = span[19]
        fields['primary_advertising_phy'] = PrimaryPhyType(span[20])
        fields['secondary_advertising_max_skip'] = span[21]
        fields['secondary_advertising_phy'] = SecondaryPhyType(span[22])
        fields['advertising_sid'] = span[23]
        fields['scan_request_notification_enable'] = Enable(span[24])
        fields['primary_advertising_phy_options'] = AdvertisingPhyOptions(span[25])
        fields['secondary_advertising_phy_options'] = AdvertisingPhyOptions(span[26])
        span = span[27:]
        return LeSetExtendedAdvertisingParametersV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.extend(self.advertising_event_properties.serialize())
        if self.primary_advertising_interval_min > 16777215:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2::primary_advertising_interval_min: {self.primary_advertising_interval_min} > 16777215; the value will be truncated")
            self.primary_advertising_interval_min &= 16777215
        _span.extend(int.to_bytes((self.primary_advertising_interval_min << 0), length=3, byteorder='little'))
        if self.primary_advertising_interval_max > 16777215:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2::primary_advertising_interval_max: {self.primary_advertising_interval_max} > 16777215; the value will be truncated")
            self.primary_advertising_interval_max &= 16777215
        _span.extend(int.to_bytes((self.primary_advertising_interval_max << 0), length=3, byteorder='little'))
        if self.primary_advertising_channel_map > 7:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2::primary_advertising_channel_map: {self.primary_advertising_channel_map} > 7; the value will be truncated")
            self.primary_advertising_channel_map &= 7
        _span.append((self.primary_advertising_channel_map << 0))
        _span.append((self.own_address_type << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        _span.append((self.advertising_filter_policy << 0))
        if self.advertising_tx_power > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2::advertising_tx_power: {self.advertising_tx_power} > 255; the value will be truncated")
            self.advertising_tx_power &= 255
        _span.append((self.advertising_tx_power << 0))
        _span.append((self.primary_advertising_phy << 0))
        if self.secondary_advertising_max_skip > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2::secondary_advertising_max_skip: {self.secondary_advertising_max_skip} > 255; the value will be truncated")
            self.secondary_advertising_max_skip &= 255
        _span.append((self.secondary_advertising_max_skip << 0))
        _span.append((self.secondary_advertising_phy << 0))
        if self.advertising_sid > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        _span.append((self.scan_request_notification_enable << 0))
        _span.append((self.primary_advertising_phy_options << 0))
        _span.append((self.secondary_advertising_phy_options << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 27

@dataclass
class LeSetExtendedAdvertisingParametersV2Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    selected_tx_power: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingParametersV2Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_PARAMETERS_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['selected_tx_power'] = span[1]
        span = span[2:]
        return LeSetExtendedAdvertisingParametersV2Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.selected_tx_power > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingParametersV2Complete::selected_tx_power: {self.selected_tx_power} > 255; the value will be truncated")
            self.selected_tx_power &= 255
        _span.append((self.selected_tx_power << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class Operation(enum.IntEnum):
    INTERMEDIATE_FRAGMENT = 0x0
    FIRST_FRAGMENT = 0x1
    LAST_FRAGMENT = 0x2
    COMPLETE_ADVERTISEMENT = 0x3
    UNCHANGED_DATA = 0x4

class FragmentPreference(enum.IntEnum):
    CONTROLLER_MAY_FRAGMENT = 0x0
    CONTROLLER_SHOULD_NOT = 0x1

@dataclass
class LeSetExtendedAdvertisingData(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    operation: Operation = field(kw_only=True, default=Operation.INTERMEDIATE_FRAGMENT)
    fragment_preference: FragmentPreference = field(kw_only=True, default=FragmentPreference.CONTROLLER_MAY_FRAGMENT)
    advertising_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_DATA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingData', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['operation'] = Operation((span[1] >> 0) & 0x7)
        fields['fragment_preference'] = FragmentPreference((span[2] >> 0) & 0x1)
        advertising_data_size = span[3]
        span = span[4:]
        if len(span) < advertising_data_size:
            raise Exception('Invalid packet size')
        fields['advertising_data'] = list(span[:advertising_data_size])
        span = span[advertising_data_size:]
        return LeSetExtendedAdvertisingData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetExtendedAdvertisingData::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.append((self.operation << 0))
        _span.append((self.fragment_preference << 0))
        _span.append(((len(self.advertising_data) * 1) << 0))
        _span.extend(self.advertising_data)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.advertising_data) * 1 + 4

@dataclass
class LeSetExtendedAdvertisingDataComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_DATA
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingDataComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetExtendedAdvertisingDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetExtendedScanResponseData(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    operation: Operation = field(kw_only=True, default=Operation.INTERMEDIATE_FRAGMENT)
    fragment_preference: FragmentPreference = field(kw_only=True, default=FragmentPreference.CONTROLLER_MAY_FRAGMENT)
    scan_response_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_SCAN_RESPONSE_DATA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedScanResponseData', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_SCAN_RESPONSE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['operation'] = Operation((span[1] >> 0) & 0x7)
        fields['fragment_preference'] = FragmentPreference((span[2] >> 0) & 0x1)
        scan_response_data_size = span[3]
        span = span[4:]
        if len(span) < scan_response_data_size:
            raise Exception('Invalid packet size')
        fields['scan_response_data'] = list(span[:scan_response_data_size])
        span = span[scan_response_data_size:]
        return LeSetExtendedScanResponseData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetExtendedScanResponseData::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.append((self.operation << 0))
        _span.append((self.fragment_preference << 0))
        _span.append(((len(self.scan_response_data) * 1) << 0))
        _span.extend(self.scan_response_data)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.scan_response_data) * 1 + 4

@dataclass
class LeSetExtendedScanResponseDataComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EXTENDED_SCAN_RESPONSE_DATA
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedScanResponseDataComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EXTENDED_SCAN_RESPONSE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetExtendedScanResponseDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetExtendedAdvertisingEnableDisableAll(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingEnableDisableAll', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        if span[0] != 0x0:
            raise Exception('Unexpected fixed field value')
        if span[1] != 0x0:
            raise Exception('Unexpected fixed field value')
        span = span[2:]
        return LeSetExtendedAdvertisingEnableDisableAll(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((0 << 0))
        _span.append((0 << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class EnabledSet(Packet):
    advertising_handle: int = field(kw_only=True, default=0)
    duration: int = field(kw_only=True, default=0)
    max_extended_advertising_events: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['EnabledSet', bytes]:
        fields = {'payload': None}
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['duration'] = value_
        fields['max_extended_advertising_events'] = span[3]
        span = span[4:]
        return EnabledSet(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field EnabledSet::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.duration > 65535:
            print(f"Invalid value for field EnabledSet::duration: {self.duration} > 65535; the value will be truncated")
            self.duration &= 65535
        _span.extend(int.to_bytes((self.duration << 0), length=2, byteorder='little'))
        if self.max_extended_advertising_events > 255:
            print(f"Invalid value for field EnabledSet::max_extended_advertising_events: {self.max_extended_advertising_events} > 255; the value will be truncated")
            self.max_extended_advertising_events &= 255
        _span.append((self.max_extended_advertising_events << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 4

@dataclass
class DisabledSet(Packet):
    advertising_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['DisabledSet', bytes]:
        fields = {'payload': None}
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        if value_ != 0x0:
            raise Exception('Unexpected fixed field value')
        if span[3] != 0x0:
            raise Exception('Unexpected fixed field value')
        span = span[4:]
        return DisabledSet(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field DisabledSet::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.extend(int.to_bytes((0 << 0), length=2, byteorder='little'))
        _span.append((0 << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 4

@dataclass
class LeSetExtendedAdvertisingDisable(Command):
    disabled_sets: List[DisabledSet] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingDisable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        if span[0] != 0x0:
            raise Exception('Unexpected fixed field value')
        disabled_sets_count = span[1]
        span = span[2:]
        if len(span) < disabled_sets_count * 4:
            raise Exception('Invalid packet size')
        disabled_sets = []
        for n in range(disabled_sets_count):
            disabled_sets.append(DisabledSet.parse_all(span[n * 4:(n + 1) * 4]))
        fields['disabled_sets'] = disabled_sets
        span = span[disabled_sets_count * 4:]
        return LeSetExtendedAdvertisingDisable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((0 << 0))
        if len(self.disabled_sets) > 255:
            print(f"Invalid length for field LeSetExtendedAdvertisingDisable::disabled_sets:  {len(self.disabled_sets)} > 255; the array will be truncated")
            del self.disabled_sets[255:]
        _span.append((len(self.disabled_sets) << 0))
        for _elt in self.disabled_sets:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.disabled_sets]) + 2

@dataclass
class LeSetExtendedAdvertisingEnable(Command):
    enable: Enable = field(kw_only=True, default=Enable.DISABLED)
    enabled_sets: List[EnabledSet] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['enable'] = Enable(span[0])
        enabled_sets_count = span[1]
        span = span[2:]
        if len(span) < enabled_sets_count * 4:
            raise Exception('Invalid packet size')
        enabled_sets = []
        for n in range(enabled_sets_count):
            enabled_sets.append(EnabledSet.parse_all(span[n * 4:(n + 1) * 4]))
        fields['enabled_sets'] = enabled_sets
        span = span[enabled_sets_count * 4:]
        return LeSetExtendedAdvertisingEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.enable << 0))
        if len(self.enabled_sets) > 255:
            print(f"Invalid length for field LeSetExtendedAdvertisingEnable::enabled_sets:  {len(self.enabled_sets)} > 255; the array will be truncated")
            del self.enabled_sets[255:]
        _span.append((len(self.enabled_sets) << 0))
        for _elt in self.enabled_sets:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.enabled_sets]) + 2

@dataclass
class LeSetExtendedAdvertisingEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedAdvertisingEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EXTENDED_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetExtendedAdvertisingEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadMaximumAdvertisingDataLength(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadMaximumAdvertisingDataLength', bytes]:
        if fields['op_code'] != OpCode.LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        return LeReadMaximumAdvertisingDataLength(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadMaximumAdvertisingDataLengthComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    maximum_advertising_data_length: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadMaximumAdvertisingDataLengthComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['maximum_advertising_data_length'] = value_
        span = span[3:]
        return LeReadMaximumAdvertisingDataLengthComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.maximum_advertising_data_length > 65535:
            print(f"Invalid value for field LeReadMaximumAdvertisingDataLengthComplete::maximum_advertising_data_length: {self.maximum_advertising_data_length} > 65535; the value will be truncated")
            self.maximum_advertising_data_length &= 65535
        _span.extend(int.to_bytes((self.maximum_advertising_data_length << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeReadNumberOfSupportedAdvertisingSets(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadNumberOfSupportedAdvertisingSets', bytes]:
        if fields['op_code'] != OpCode.LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS:
            raise Exception("Invalid constraint field values")
        return LeReadNumberOfSupportedAdvertisingSets(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadNumberOfSupportedAdvertisingSetsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    number_supported_advertising_sets: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadNumberOfSupportedAdvertisingSetsComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['number_supported_advertising_sets'] = span[1]
        span = span[2:]
        return LeReadNumberOfSupportedAdvertisingSetsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.number_supported_advertising_sets > 255:
            print(f"Invalid value for field LeReadNumberOfSupportedAdvertisingSetsComplete::number_supported_advertising_sets: {self.number_supported_advertising_sets} > 255; the value will be truncated")
            self.number_supported_advertising_sets &= 255
        _span.append((self.number_supported_advertising_sets << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeRemoveAdvertisingSet(Command):
    advertising_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOVE_ADVERTISING_SET

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveAdvertisingSet', bytes]:
        if fields['op_code'] != OpCode.LE_REMOVE_ADVERTISING_SET:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        span = span[1:]
        return LeRemoveAdvertisingSet(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeRemoveAdvertisingSet::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeRemoveAdvertisingSetComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOVE_ADVERTISING_SET
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveAdvertisingSetComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOVE_ADVERTISING_SET:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeRemoveAdvertisingSetComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeClearAdvertisingSets(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_CLEAR_ADVERTISING_SETS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearAdvertisingSets', bytes]:
        if fields['op_code'] != OpCode.LE_CLEAR_ADVERTISING_SETS:
            raise Exception("Invalid constraint field values")
        return LeClearAdvertisingSets(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeClearAdvertisingSetsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CLEAR_ADVERTISING_SETS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearAdvertisingSetsComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CLEAR_ADVERTISING_SETS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeClearAdvertisingSetsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetPeriodicAdvertisingParametersV1(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    periodic_advertising_interval_min: int = field(kw_only=True, default=0)
    periodic_advertising_interval_max: int = field(kw_only=True, default=0)
    include_tx_power: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingParametersV1', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['periodic_advertising_interval_min'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['periodic_advertising_interval_max'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['include_tx_power'] = (value_ >> 6) & 0x1
        span = span[7:]
        return LeSetPeriodicAdvertisingParametersV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV1::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.periodic_advertising_interval_min > 65535:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV1::periodic_advertising_interval_min: {self.periodic_advertising_interval_min} > 65535; the value will be truncated")
            self.periodic_advertising_interval_min &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval_min << 0), length=2, byteorder='little'))
        if self.periodic_advertising_interval_max > 65535:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV1::periodic_advertising_interval_max: {self.periodic_advertising_interval_max} > 65535; the value will be truncated")
            self.periodic_advertising_interval_max &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval_max << 0), length=2, byteorder='little'))
        if self.include_tx_power > 1:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV1::include_tx_power: {self.include_tx_power} > 1; the value will be truncated")
            self.include_tx_power &= 1
        _span.extend(int.to_bytes((self.include_tx_power << 6), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeSetPeriodicAdvertisingParametersV1Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V1
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingParametersV1Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetPeriodicAdvertisingParametersV1Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetPeriodicAdvertisingParametersV2(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    periodic_advertising_interval_min: int = field(kw_only=True, default=0)
    periodic_advertising_interval_max: int = field(kw_only=True, default=0)
    include_tx_power: int = field(kw_only=True, default=0)
    num_subevents: int = field(kw_only=True, default=0)
    subevent_interval: int = field(kw_only=True, default=0)
    response_slot_delay: int = field(kw_only=True, default=0)
    response_slot_spacing: int = field(kw_only=True, default=0)
    num_response_slots: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingParametersV2', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 12:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['periodic_advertising_interval_min'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['periodic_advertising_interval_max'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['include_tx_power'] = (value_ >> 6) & 0x1
        fields['num_subevents'] = span[7]
        fields['subevent_interval'] = span[8]
        fields['response_slot_delay'] = span[9]
        fields['response_slot_spacing'] = span[10]
        fields['num_response_slots'] = span[11]
        span = span[12:]
        return LeSetPeriodicAdvertisingParametersV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.periodic_advertising_interval_min > 65535:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::periodic_advertising_interval_min: {self.periodic_advertising_interval_min} > 65535; the value will be truncated")
            self.periodic_advertising_interval_min &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval_min << 0), length=2, byteorder='little'))
        if self.periodic_advertising_interval_max > 65535:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::periodic_advertising_interval_max: {self.periodic_advertising_interval_max} > 65535; the value will be truncated")
            self.periodic_advertising_interval_max &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval_max << 0), length=2, byteorder='little'))
        if self.include_tx_power > 1:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::include_tx_power: {self.include_tx_power} > 1; the value will be truncated")
            self.include_tx_power &= 1
        _span.extend(int.to_bytes((self.include_tx_power << 6), length=2, byteorder='little'))
        if self.num_subevents > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::num_subevents: {self.num_subevents} > 255; the value will be truncated")
            self.num_subevents &= 255
        _span.append((self.num_subevents << 0))
        if self.subevent_interval > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::subevent_interval: {self.subevent_interval} > 255; the value will be truncated")
            self.subevent_interval &= 255
        _span.append((self.subevent_interval << 0))
        if self.response_slot_delay > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::response_slot_delay: {self.response_slot_delay} > 255; the value will be truncated")
            self.response_slot_delay &= 255
        _span.append((self.response_slot_delay << 0))
        if self.response_slot_spacing > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::response_slot_spacing: {self.response_slot_spacing} > 255; the value will be truncated")
            self.response_slot_spacing &= 255
        _span.append((self.response_slot_spacing << 0))
        if self.num_response_slots > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2::num_response_slots: {self.num_response_slots} > 255; the value will be truncated")
            self.num_response_slots &= 255
        _span.append((self.num_response_slots << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 12

@dataclass
class LeSetPeriodicAdvertisingParametersV2Complete(CommandComplete):
    advertising_handle: int = field(kw_only=True, default=0)
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingParametersV2Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_PARAMETERS_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['status'] = ErrorCode(span[1])
        span = span[2:]
        return LeSetPeriodicAdvertisingParametersV2Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingParametersV2Complete::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetPeriodicAdvertisingData(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    operation: Operation = field(kw_only=True, default=Operation.INTERMEDIATE_FRAGMENT)
    advertising_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_DATA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingData', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['operation'] = Operation((span[1] >> 0) & 0x7)
        advertising_data_size = span[2]
        span = span[3:]
        if len(span) < advertising_data_size:
            raise Exception('Invalid packet size')
        fields['advertising_data'] = list(span[:advertising_data_size])
        span = span[advertising_data_size:]
        return LeSetPeriodicAdvertisingData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingData::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.append((self.operation << 0))
        _span.append(((len(self.advertising_data) * 1) << 0))
        _span.extend(self.advertising_data)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.advertising_data) * 1 + 3

@dataclass
class LeSetPeriodicAdvertisingDataComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_DATA
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingDataComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetPeriodicAdvertisingDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetPeriodicAdvertisingEnable(Command):
    enable: int = field(kw_only=True, default=0)
    include_adi: int = field(kw_only=True, default=0)
    advertising_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['enable'] = (span[0] >> 0) & 0x1
        fields['include_adi'] = (span[0] >> 1) & 0x1
        fields['advertising_handle'] = span[1]
        span = span[2:]
        return LeSetPeriodicAdvertisingEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.enable > 1:
            print(f"Invalid value for field LeSetPeriodicAdvertisingEnable::enable: {self.enable} > 1; the value will be truncated")
            self.enable &= 1
        if self.include_adi > 1:
            print(f"Invalid value for field LeSetPeriodicAdvertisingEnable::include_adi: {self.include_adi} > 1; the value will be truncated")
            self.include_adi &= 1
        _value = (
            (self.enable << 0) |
            (self.include_adi << 1)
        )
        _span.append(_value)
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingEnable::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetPeriodicAdvertisingEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetPeriodicAdvertisingEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ScanningPhyParameters(Packet):
    le_scan_type: LeScanType = field(kw_only=True, default=LeScanType.PASSIVE)
    le_scan_interval: int = field(kw_only=True, default=0)
    le_scan_window: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['ScanningPhyParameters', bytes]:
        fields = {'payload': None}
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['le_scan_type'] = LeScanType(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['le_scan_interval'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['le_scan_window'] = value_
        span = span[5:]
        return ScanningPhyParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.le_scan_type << 0))
        if self.le_scan_interval > 65535:
            print(f"Invalid value for field ScanningPhyParameters::le_scan_interval: {self.le_scan_interval} > 65535; the value will be truncated")
            self.le_scan_interval &= 65535
        _span.extend(int.to_bytes((self.le_scan_interval << 0), length=2, byteorder='little'))
        if self.le_scan_window > 65535:
            print(f"Invalid value for field ScanningPhyParameters::le_scan_window: {self.le_scan_window} > 65535; the value will be truncated")
            self.le_scan_window &= 65535
        _span.extend(int.to_bytes((self.le_scan_window << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 5

@dataclass
class LeSetExtendedScanParameters(Command):
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    scanning_filter_policy: LeScanningFilterPolicy = field(kw_only=True, default=LeScanningFilterPolicy.ACCEPT_ALL)
    scanning_phys: int = field(kw_only=True, default=0)
    scanning_phy_parameters: List[ScanningPhyParameters] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_SCAN_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedScanParameters', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['own_address_type'] = OwnAddressType(span[0])
        fields['scanning_filter_policy'] = LeScanningFilterPolicy(span[1])
        fields['scanning_phys'] = span[2]
        span = span[3:]
        if len(span) % 5 != 0:
            raise Exception('Array size is not a multiple of the element size')
        scanning_phy_parameters_count = int(len(span) / 5)
        scanning_phy_parameters = []
        for n in range(scanning_phy_parameters_count):
            scanning_phy_parameters.append(ScanningPhyParameters.parse_all(span[n * 5:(n + 1) * 5]))
        fields['scanning_phy_parameters'] = scanning_phy_parameters
        span = bytes()
        return LeSetExtendedScanParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.own_address_type << 0))
        _span.append((self.scanning_filter_policy << 0))
        if self.scanning_phys > 255:
            print(f"Invalid value for field LeSetExtendedScanParameters::scanning_phys: {self.scanning_phys} > 255; the value will be truncated")
            self.scanning_phys &= 255
        _span.append((self.scanning_phys << 0))
        for _elt in self.scanning_phy_parameters:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.scanning_phy_parameters]) + 3

@dataclass
class LeSetExtendedScanParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EXTENDED_SCAN_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedScanParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EXTENDED_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetExtendedScanParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class FilterDuplicates(enum.IntEnum):
    DISABLED = 0x0
    ENABLED = 0x1
    RESET_EACH_PERIOD = 0x2

@dataclass
class LeSetExtendedScanEnable(Command):
    enable: Enable = field(kw_only=True, default=Enable.DISABLED)
    filter_duplicates: FilterDuplicates = field(kw_only=True, default=FilterDuplicates.DISABLED)
    duration: int = field(kw_only=True, default=0)
    period: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_EXTENDED_SCAN_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedScanEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_EXTENDED_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['enable'] = Enable(span[0])
        fields['filter_duplicates'] = FilterDuplicates(span[1])
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['duration'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['period'] = value_
        span = span[6:]
        return LeSetExtendedScanEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.enable << 0))
        _span.append((self.filter_duplicates << 0))
        if self.duration > 65535:
            print(f"Invalid value for field LeSetExtendedScanEnable::duration: {self.duration} > 65535; the value will be truncated")
            self.duration &= 65535
        _span.extend(int.to_bytes((self.duration << 0), length=2, byteorder='little'))
        if self.period > 65535:
            print(f"Invalid value for field LeSetExtendedScanEnable::period: {self.period} > 65535; the value will be truncated")
            self.period &= 65535
        _span.extend(int.to_bytes((self.period << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LeSetExtendedScanEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_EXTENDED_SCAN_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetExtendedScanEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_EXTENDED_SCAN_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetExtendedScanEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class InitiatingPhyParameters(Packet):
    scan_interval: int = field(kw_only=True, default=0)
    scan_window: int = field(kw_only=True, default=0)
    connection_interval_min: int = field(kw_only=True, default=0)
    connection_interval_max: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)
    min_ce_length: int = field(kw_only=True, default=0)
    max_ce_length: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['InitiatingPhyParameters', bytes]:
        fields = {'payload': None}
        if len(span) < 16:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['scan_interval'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['scan_window'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['connection_interval_min'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['connection_interval_max'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['max_latency'] = value_
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['supervision_timeout'] = value_
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['min_ce_length'] = value_
        value_ = int.from_bytes(span[14:16], byteorder='little')
        fields['max_ce_length'] = value_
        span = span[16:]
        return InitiatingPhyParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.scan_interval > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::scan_interval: {self.scan_interval} > 65535; the value will be truncated")
            self.scan_interval &= 65535
        _span.extend(int.to_bytes((self.scan_interval << 0), length=2, byteorder='little'))
        if self.scan_window > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::scan_window: {self.scan_window} > 65535; the value will be truncated")
            self.scan_window &= 65535
        _span.extend(int.to_bytes((self.scan_window << 0), length=2, byteorder='little'))
        if self.connection_interval_min > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::connection_interval_min: {self.connection_interval_min} > 65535; the value will be truncated")
            self.connection_interval_min &= 65535
        _span.extend(int.to_bytes((self.connection_interval_min << 0), length=2, byteorder='little'))
        if self.connection_interval_max > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::connection_interval_max: {self.connection_interval_max} > 65535; the value will be truncated")
            self.connection_interval_max &= 65535
        _span.extend(int.to_bytes((self.connection_interval_max << 0), length=2, byteorder='little'))
        if self.max_latency > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::max_latency: {self.max_latency} > 65535; the value will be truncated")
            self.max_latency &= 65535
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::supervision_timeout: {self.supervision_timeout} > 65535; the value will be truncated")
            self.supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        if self.min_ce_length > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::min_ce_length: {self.min_ce_length} > 65535; the value will be truncated")
            self.min_ce_length &= 65535
        _span.extend(int.to_bytes((self.min_ce_length << 0), length=2, byteorder='little'))
        if self.max_ce_length > 65535:
            print(f"Invalid value for field InitiatingPhyParameters::max_ce_length: {self.max_ce_length} > 65535; the value will be truncated")
            self.max_ce_length &= 65535
        _span.extend(int.to_bytes((self.max_ce_length << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 16

@dataclass
class LeExtendedCreateConnectionV1(Command):
    initiator_filter_policy: InitiatorFilterPolicy = field(kw_only=True, default=InitiatorFilterPolicy.USE_PEER_ADDRESS)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    initiating_phys: int = field(kw_only=True, default=0)
    initiating_phy_parameters: List[InitiatingPhyParameters] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_EXTENDED_CREATE_CONNECTION_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeExtendedCreateConnectionV1', bytes]:
        if fields['op_code'] != OpCode.LE_EXTENDED_CREATE_CONNECTION_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['initiator_filter_policy'] = InitiatorFilterPolicy(span[0])
        fields['own_address_type'] = OwnAddressType(span[1])
        fields['peer_address_type'] = PeerAddressType(span[2])
        fields['peer_address'] = Address.parse_all(span[3:9])
        fields['initiating_phys'] = span[9]
        span = span[10:]
        if len(span) % 16 != 0:
            raise Exception('Array size is not a multiple of the element size')
        initiating_phy_parameters_count = int(len(span) / 16)
        initiating_phy_parameters = []
        for n in range(initiating_phy_parameters_count):
            initiating_phy_parameters.append(InitiatingPhyParameters.parse_all(span[n * 16:(n + 1) * 16]))
        fields['initiating_phy_parameters'] = initiating_phy_parameters
        span = bytes()
        return LeExtendedCreateConnectionV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.initiator_filter_policy << 0))
        _span.append((self.own_address_type << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        if self.initiating_phys > 255:
            print(f"Invalid value for field LeExtendedCreateConnectionV1::initiating_phys: {self.initiating_phys} > 255; the value will be truncated")
            self.initiating_phys &= 255
        _span.append((self.initiating_phys << 0))
        for _elt in self.initiating_phy_parameters:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.initiating_phy_parameters]) + 10

@dataclass
class LeExtendedCreateConnectionV1Status(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_EXTENDED_CREATE_CONNECTION_V1
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeExtendedCreateConnectionV1Status', bytes]:
        if fields['command_op_code'] != OpCode.LE_EXTENDED_CREATE_CONNECTION_V1:
            raise Exception("Invalid constraint field values")
        return LeExtendedCreateConnectionV1Status(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeExtendedCreateConnectionV2(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    subevent: int = field(kw_only=True, default=0)
    initiator_filter_policy: InitiatorFilterPolicy = field(kw_only=True, default=InitiatorFilterPolicy.USE_PEER_ADDRESS)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    initiating_phys: int = field(kw_only=True, default=0)
    initiating_phy_parameters: List[InitiatingPhyParameters] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_EXTENDED_CREATE_CONNECTION_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeExtendedCreateConnectionV2', bytes]:
        if fields['op_code'] != OpCode.LE_EXTENDED_CREATE_CONNECTION_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 12:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['subevent'] = span[1]
        fields['initiator_filter_policy'] = InitiatorFilterPolicy(span[2])
        fields['own_address_type'] = OwnAddressType(span[3])
        fields['peer_address_type'] = PeerAddressType(span[4])
        fields['peer_address'] = Address.parse_all(span[5:11])
        fields['initiating_phys'] = span[11]
        span = span[12:]
        if len(span) % 16 != 0:
            raise Exception('Array size is not a multiple of the element size')
        initiating_phy_parameters_count = int(len(span) / 16)
        initiating_phy_parameters = []
        for n in range(initiating_phy_parameters_count):
            initiating_phy_parameters.append(InitiatingPhyParameters.parse_all(span[n * 16:(n + 1) * 16]))
        fields['initiating_phy_parameters'] = initiating_phy_parameters
        span = bytes()
        return LeExtendedCreateConnectionV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeExtendedCreateConnectionV2::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.subevent > 255:
            print(f"Invalid value for field LeExtendedCreateConnectionV2::subevent: {self.subevent} > 255; the value will be truncated")
            self.subevent &= 255
        _span.append((self.subevent << 0))
        _span.append((self.initiator_filter_policy << 0))
        _span.append((self.own_address_type << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        if self.initiating_phys > 255:
            print(f"Invalid value for field LeExtendedCreateConnectionV2::initiating_phys: {self.initiating_phys} > 255; the value will be truncated")
            self.initiating_phys &= 255
        _span.append((self.initiating_phys << 0))
        for _elt in self.initiating_phy_parameters:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.initiating_phy_parameters]) + 12

@dataclass
class LeExtendedCreateConnectionV2Status(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_EXTENDED_CREATE_CONNECTION_V2
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeExtendedCreateConnectionV2Status', bytes]:
        if fields['command_op_code'] != OpCode.LE_EXTENDED_CREATE_CONNECTION_V2:
            raise Exception("Invalid constraint field values")
        return LeExtendedCreateConnectionV2Status(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class PeriodicSyncCteType(enum.IntEnum):
    AVOID_AOA_CONSTANT_TONE_EXTENSION = 0x1
    AVOID_AOD_CONSTANT_TONE_EXTENSION_WITH_ONE_US_SLOTS = 0x2
    AVOID_AOD_CONSTANT_TONE_EXTENSION_WITH_TWO_US_SLOTS = 0x4
    AVOID_TYPE_THREE_CONSTANT_TONE_EXTENSION = 0x8
    AVOID_NO_CONSTANT_TONE_EXTENSION = 0x10

@dataclass
class PeriodicAdvertisingOptions(Packet):
    use_periodic_advertiser_list: int = field(kw_only=True, default=0)
    disable_reporting: int = field(kw_only=True, default=0)
    enable_duplicate_filtering: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['PeriodicAdvertisingOptions', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['use_periodic_advertiser_list'] = (span[0] >> 0) & 0x1
        fields['disable_reporting'] = (span[0] >> 1) & 0x1
        fields['enable_duplicate_filtering'] = (span[0] >> 2) & 0x1
        span = span[1:]
        return PeriodicAdvertisingOptions(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.use_periodic_advertiser_list > 1:
            print(f"Invalid value for field PeriodicAdvertisingOptions::use_periodic_advertiser_list: {self.use_periodic_advertiser_list} > 1; the value will be truncated")
            self.use_periodic_advertiser_list &= 1
        if self.disable_reporting > 1:
            print(f"Invalid value for field PeriodicAdvertisingOptions::disable_reporting: {self.disable_reporting} > 1; the value will be truncated")
            self.disable_reporting &= 1
        if self.enable_duplicate_filtering > 1:
            print(f"Invalid value for field PeriodicAdvertisingOptions::enable_duplicate_filtering: {self.enable_duplicate_filtering} > 1; the value will be truncated")
            self.enable_duplicate_filtering &= 1
        _value = (
            (self.use_periodic_advertiser_list << 0) |
            (self.disable_reporting << 1) |
            (self.enable_duplicate_filtering << 2)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

class AdvertiserAddressType(enum.IntEnum):
    PUBLIC_DEVICE_OR_IDENTITY_ADDRESS = 0x0
    RANDOM_DEVICE_OR_IDENTITY_ADDRESS = 0x1

@dataclass
class LePeriodicAdvertisingCreateSync(Command):
    options: PeriodicAdvertisingOptions = field(kw_only=True, default_factory=PeriodicAdvertisingOptions)
    advertising_sid: int = field(kw_only=True, default=0)
    advertiser_address_type: AdvertiserAddressType = field(kw_only=True, default=AdvertiserAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    skip: int = field(kw_only=True, default=0)
    sync_timeout: int = field(kw_only=True, default=0)
    sync_cte_type: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingCreateSync', bytes]:
        if fields['op_code'] != OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 14:
            raise Exception('Invalid packet size')
        fields['options'] = PeriodicAdvertisingOptions.parse_all(span[0:1])
        fields['advertising_sid'] = span[1]
        fields['advertiser_address_type'] = AdvertiserAddressType(span[2])
        fields['advertiser_address'] = Address.parse_all(span[3:9])
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['skip'] = value_
        value_ = int.from_bytes(span[11:13], byteorder='little')
        fields['sync_timeout'] = value_
        fields['sync_cte_type'] = span[13]
        span = span[14:]
        return LePeriodicAdvertisingCreateSync(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.options.serialize())
        if self.advertising_sid > 255:
            print(f"Invalid value for field LePeriodicAdvertisingCreateSync::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        _span.append((self.advertiser_address_type << 0))
        _span.extend(self.advertiser_address.serialize())
        if self.skip > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingCreateSync::skip: {self.skip} > 65535; the value will be truncated")
            self.skip &= 65535
        _span.extend(int.to_bytes((self.skip << 0), length=2, byteorder='little'))
        if self.sync_timeout > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingCreateSync::sync_timeout: {self.sync_timeout} > 65535; the value will be truncated")
            self.sync_timeout &= 65535
        _span.extend(int.to_bytes((self.sync_timeout << 0), length=2, byteorder='little'))
        if self.sync_cte_type > 255:
            print(f"Invalid value for field LePeriodicAdvertisingCreateSync::sync_cte_type: {self.sync_cte_type} > 255; the value will be truncated")
            self.sync_cte_type &= 255
        _span.append((self.sync_cte_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 14

@dataclass
class LePeriodicAdvertisingCreateSyncStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingCreateSyncStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC:
            raise Exception("Invalid constraint field values")
        return LePeriodicAdvertisingCreateSyncStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LePeriodicAdvertisingCreateSyncCancel(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingCreateSyncCancel', bytes]:
        if fields['op_code'] != OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL:
            raise Exception("Invalid constraint field values")
        return LePeriodicAdvertisingCreateSyncCancel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LePeriodicAdvertisingCreateSyncCancelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingCreateSyncCancelComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LePeriodicAdvertisingCreateSyncCancelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LePeriodicAdvertisingTerminateSync(Command):
    sync_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_PERIODIC_ADVERTISING_TERMINATE_SYNC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingTerminateSync', bytes]:
        if fields['op_code'] != OpCode.LE_PERIODIC_ADVERTISING_TERMINATE_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LePeriodicAdvertisingTerminateSync(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingTerminateSync::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LePeriodicAdvertisingTerminateSyncComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_PERIODIC_ADVERTISING_TERMINATE_SYNC
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingTerminateSyncComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_PERIODIC_ADVERTISING_TERMINATE_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LePeriodicAdvertisingTerminateSyncComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeAddDeviceToPeriodicAdvertiserList(Command):
    advertiser_address_type: AdvertiserAddressType = field(kw_only=True, default=AdvertiserAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    advertising_sid: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAddDeviceToPeriodicAdvertiserList', bytes]:
        if fields['op_code'] != OpCode.LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['advertiser_address_type'] = AdvertiserAddressType(span[0])
        fields['advertiser_address'] = Address.parse_all(span[1:7])
        fields['advertising_sid'] = span[7]
        span = span[8:]
        return LeAddDeviceToPeriodicAdvertiserList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.advertiser_address_type << 0))
        _span.extend(self.advertiser_address.serialize())
        if self.advertising_sid > 255:
            print(f"Invalid value for field LeAddDeviceToPeriodicAdvertiserList::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeAddDeviceToPeriodicAdvertiserListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAddDeviceToPeriodicAdvertiserListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeAddDeviceToPeriodicAdvertiserListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeRemoveDeviceFromPeriodicAdvertiserList(Command):
    advertiser_address_type: AdvertiserAddressType = field(kw_only=True, default=AdvertiserAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    advertising_sid: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveDeviceFromPeriodicAdvertiserList', bytes]:
        if fields['op_code'] != OpCode.LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['advertiser_address_type'] = AdvertiserAddressType(span[0])
        fields['advertiser_address'] = Address.parse_all(span[1:7])
        fields['advertising_sid'] = span[7]
        span = span[8:]
        return LeRemoveDeviceFromPeriodicAdvertiserList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.advertiser_address_type << 0))
        _span.extend(self.advertiser_address.serialize())
        if self.advertising_sid > 255:
            print(f"Invalid value for field LeRemoveDeviceFromPeriodicAdvertiserList::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeRemoveDeviceFromPeriodicAdvertiserListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveDeviceFromPeriodicAdvertiserListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeRemoveDeviceFromPeriodicAdvertiserListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeClearPeriodicAdvertiserList(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_CLEAR_PERIODIC_ADVERTISER_LIST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearPeriodicAdvertiserList', bytes]:
        if fields['op_code'] != OpCode.LE_CLEAR_PERIODIC_ADVERTISER_LIST:
            raise Exception("Invalid constraint field values")
        return LeClearPeriodicAdvertiserList(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeClearPeriodicAdvertiserListComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CLEAR_PERIODIC_ADVERTISER_LIST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeClearPeriodicAdvertiserListComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CLEAR_PERIODIC_ADVERTISER_LIST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeClearPeriodicAdvertiserListComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadPeriodicAdvertiserListSize(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_PERIODIC_ADVERTISER_LIST_SIZE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadPeriodicAdvertiserListSize', bytes]:
        if fields['op_code'] != OpCode.LE_READ_PERIODIC_ADVERTISER_LIST_SIZE:
            raise Exception("Invalid constraint field values")
        return LeReadPeriodicAdvertiserListSize(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadPeriodicAdvertiserListSizeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    periodic_advertiser_list_size: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_PERIODIC_ADVERTISER_LIST_SIZE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadPeriodicAdvertiserListSizeComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_PERIODIC_ADVERTISER_LIST_SIZE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['periodic_advertiser_list_size'] = span[1]
        span = span[2:]
        return LeReadPeriodicAdvertiserListSizeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.periodic_advertiser_list_size > 255:
            print(f"Invalid value for field LeReadPeriodicAdvertiserListSizeComplete::periodic_advertiser_list_size: {self.periodic_advertiser_list_size} > 255; the value will be truncated")
            self.periodic_advertiser_list_size &= 255
        _span.append((self.periodic_advertiser_list_size << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeReadTransmitPower(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_TRANSMIT_POWER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadTransmitPower', bytes]:
        if fields['op_code'] != OpCode.LE_READ_TRANSMIT_POWER:
            raise Exception("Invalid constraint field values")
        return LeReadTransmitPower(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadTransmitPowerComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    min_tx_power_dbm: int = field(kw_only=True, default=0)
    max_tx_power_dbm: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_TRANSMIT_POWER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadTransmitPowerComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_TRANSMIT_POWER:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['min_tx_power_dbm'] = span[1]
        fields['max_tx_power_dbm'] = span[2]
        span = span[3:]
        return LeReadTransmitPowerComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.min_tx_power_dbm > 255:
            print(f"Invalid value for field LeReadTransmitPowerComplete::min_tx_power_dbm: {self.min_tx_power_dbm} > 255; the value will be truncated")
            self.min_tx_power_dbm &= 255
        _span.append((self.min_tx_power_dbm << 0))
        if self.max_tx_power_dbm > 255:
            print(f"Invalid value for field LeReadTransmitPowerComplete::max_tx_power_dbm: {self.max_tx_power_dbm} > 255; the value will be truncated")
            self.max_tx_power_dbm &= 255
        _span.append((self.max_tx_power_dbm << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeReadRfPathCompensationPower(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_RF_PATH_COMPENSATION_POWER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadRfPathCompensationPower', bytes]:
        if fields['op_code'] != OpCode.LE_READ_RF_PATH_COMPENSATION_POWER:
            raise Exception("Invalid constraint field values")
        return LeReadRfPathCompensationPower(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadRfPathCompensationPowerComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    rf_tx_path_compensation_tenths_db: int = field(kw_only=True, default=0)
    rf_rx_path_compensation_tenths_db: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_RF_PATH_COMPENSATION_POWER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadRfPathCompensationPowerComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_RF_PATH_COMPENSATION_POWER:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['rf_tx_path_compensation_tenths_db'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['rf_rx_path_compensation_tenths_db'] = value_
        span = span[5:]
        return LeReadRfPathCompensationPowerComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.rf_tx_path_compensation_tenths_db > 65535:
            print(f"Invalid value for field LeReadRfPathCompensationPowerComplete::rf_tx_path_compensation_tenths_db: {self.rf_tx_path_compensation_tenths_db} > 65535; the value will be truncated")
            self.rf_tx_path_compensation_tenths_db &= 65535
        _span.extend(int.to_bytes((self.rf_tx_path_compensation_tenths_db << 0), length=2, byteorder='little'))
        if self.rf_rx_path_compensation_tenths_db > 65535:
            print(f"Invalid value for field LeReadRfPathCompensationPowerComplete::rf_rx_path_compensation_tenths_db: {self.rf_rx_path_compensation_tenths_db} > 65535; the value will be truncated")
            self.rf_rx_path_compensation_tenths_db &= 65535
        _span.extend(int.to_bytes((self.rf_rx_path_compensation_tenths_db << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class LeWriteRfPathCompensationPower(Command):
    rf_tx_path_compensation_tenths_db: int = field(kw_only=True, default=0)
    rf_rx_path_compensation_tenths_db: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_WRITE_RF_PATH_COMPENSATION_POWER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeWriteRfPathCompensationPower', bytes]:
        if fields['op_code'] != OpCode.LE_WRITE_RF_PATH_COMPENSATION_POWER:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['rf_tx_path_compensation_tenths_db'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['rf_rx_path_compensation_tenths_db'] = value_
        span = span[4:]
        return LeWriteRfPathCompensationPower(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.rf_tx_path_compensation_tenths_db > 65535:
            print(f"Invalid value for field LeWriteRfPathCompensationPower::rf_tx_path_compensation_tenths_db: {self.rf_tx_path_compensation_tenths_db} > 65535; the value will be truncated")
            self.rf_tx_path_compensation_tenths_db &= 65535
        _span.extend(int.to_bytes((self.rf_tx_path_compensation_tenths_db << 0), length=2, byteorder='little'))
        if self.rf_rx_path_compensation_tenths_db > 65535:
            print(f"Invalid value for field LeWriteRfPathCompensationPower::rf_rx_path_compensation_tenths_db: {self.rf_rx_path_compensation_tenths_db} > 65535; the value will be truncated")
            self.rf_rx_path_compensation_tenths_db &= 65535
        _span.extend(int.to_bytes((self.rf_rx_path_compensation_tenths_db << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class LeWriteRfPathCompensationPowerComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_WRITE_RF_PATH_COMPENSATION_POWER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeWriteRfPathCompensationPowerComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_WRITE_RF_PATH_COMPENSATION_POWER:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeWriteRfPathCompensationPowerComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class PrivacyMode(enum.IntEnum):
    NETWORK = 0x0
    DEVICE = 0x1

@dataclass
class LeSetPrivacyMode(Command):
    peer_identity_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    peer_identity_address: Address = field(kw_only=True, default_factory=Address)
    privacy_mode: PrivacyMode = field(kw_only=True, default=PrivacyMode.NETWORK)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PRIVACY_MODE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPrivacyMode', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PRIVACY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['peer_identity_address_type'] = PeerAddressType(span[0])
        fields['peer_identity_address'] = Address.parse_all(span[1:7])
        fields['privacy_mode'] = PrivacyMode(span[7])
        span = span[8:]
        return LeSetPrivacyMode(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.peer_identity_address_type << 0))
        _span.extend(self.peer_identity_address.serialize())
        _span.append((self.privacy_mode << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeSetPrivacyModeComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PRIVACY_MODE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPrivacyModeComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PRIVACY_MODE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetPrivacyModeComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetPeriodicAdvertisingReceiveEnable(Command):
    sync_handle: int = field(kw_only=True, default=0)
    enable: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingReceiveEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['enable'] = span[2]
        span = span[3:]
        return LeSetPeriodicAdvertisingReceiveEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.sync_handle > 4095:
            print(f"Invalid value for field LeSetPeriodicAdvertisingReceiveEnable::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.enable > 255:
            print(f"Invalid value for field LeSetPeriodicAdvertisingReceiveEnable::enable: {self.enable} > 255; the value will be truncated")
            self.enable &= 255
        _span.append((self.enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetPeriodicAdvertisingReceiveEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingReceiveEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetPeriodicAdvertisingReceiveEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LePeriodicAdvertisingSyncTransfer(Command):
    connection_handle: int = field(kw_only=True, default=0)
    service_data: int = field(kw_only=True, default=0)
    sync_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSyncTransfer', bytes]:
        if fields['op_code'] != OpCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['service_data'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        span = span[6:]
        return LePeriodicAdvertisingSyncTransfer(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransfer::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.service_data > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransfer::service_data: {self.service_data} > 65535; the value will be truncated")
            self.service_data &= 65535
        _span.extend(int.to_bytes((self.service_data << 0), length=2, byteorder='little'))
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransfer::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LePeriodicAdvertisingSyncTransferComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSyncTransferComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LePeriodicAdvertisingSyncTransferComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LePeriodicAdvertisingSetInfoTransfer(Command):
    connection_handle: int = field(kw_only=True, default=0)
    service_data: int = field(kw_only=True, default=0)
    advertising_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSetInfoTransfer', bytes]:
        if fields['op_code'] != OpCode.LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['service_data'] = value_
        fields['advertising_handle'] = span[4]
        span = span[5:]
        return LePeriodicAdvertisingSetInfoTransfer(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSetInfoTransfer::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.service_data > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSetInfoTransfer::service_data: {self.service_data} > 65535; the value will be truncated")
            self.service_data &= 65535
        _span.extend(int.to_bytes((self.service_data << 0), length=2, byteorder='little'))
        if self.advertising_handle > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSetInfoTransfer::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class LePeriodicAdvertisingSetInfoTransferComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSetInfoTransferComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LePeriodicAdvertisingSetInfoTransferComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSetInfoTransferComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

class SyncTransferMode(enum.IntEnum):
    NO_SYNC = 0x0
    SEND_SYNC_RECEIVED_DISABLE_REPORTS = 0x1
    SEND_SYNC_RECEIVED_SEND_REPORTS = 0x2

class CteType(enum.IntEnum):
    AOA_CONSTANT_TONE_EXTENSION = 0x0
    AOD_CONSTANT_TONE_EXTENSION_ONE_US_SLOTS = 0x1
    AOD_CONSTANT_TONE_EXTENSION_TWO_US_SLOTS = 0x2
    NO_CONSTANT_TONE_EXTENSION = 0xff

@dataclass
class LeSetPeriodicAdvertisingSyncTransferParameters(Command):
    connection_handle: int = field(kw_only=True, default=0)
    mode: SyncTransferMode = field(kw_only=True, default=SyncTransferMode.NO_SYNC)
    skip: int = field(kw_only=True, default=0)
    sync_timeout: int = field(kw_only=True, default=0)
    cte_type: CteType = field(kw_only=True, default=CteType.AOA_CONSTANT_TONE_EXTENSION)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingSyncTransferParameters', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['mode'] = SyncTransferMode(span[2])
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['skip'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['sync_timeout'] = value_
        fields['cte_type'] = CteType(span[7])
        span = span[8:]
        return LeSetPeriodicAdvertisingSyncTransferParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetPeriodicAdvertisingSyncTransferParameters::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.mode << 0))
        if self.skip > 65535:
            print(f"Invalid value for field LeSetPeriodicAdvertisingSyncTransferParameters::skip: {self.skip} > 65535; the value will be truncated")
            self.skip &= 65535
        _span.extend(int.to_bytes((self.skip << 0), length=2, byteorder='little'))
        if self.sync_timeout > 65535:
            print(f"Invalid value for field LeSetPeriodicAdvertisingSyncTransferParameters::sync_timeout: {self.sync_timeout} > 65535; the value will be truncated")
            self.sync_timeout &= 65535
        _span.extend(int.to_bytes((self.sync_timeout << 0), length=2, byteorder='little'))
        _span.append((self.cte_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeSetPeriodicAdvertisingSyncTransferParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPeriodicAdvertisingSyncTransferParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeSetPeriodicAdvertisingSyncTransferParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetPeriodicAdvertisingSyncTransferParametersComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetDefaultPeriodicAdvertisingSyncTransferParameters(Command):
    mode: SyncTransferMode = field(kw_only=True, default=SyncTransferMode.NO_SYNC)
    skip: int = field(kw_only=True, default=0)
    sync_timeout: int = field(kw_only=True, default=0)
    cte_type: CteType = field(kw_only=True, default=CteType.AOA_CONSTANT_TONE_EXTENSION)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDefaultPeriodicAdvertisingSyncTransferParameters', bytes]:
        if fields['op_code'] != OpCode.LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['mode'] = SyncTransferMode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['skip'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['sync_timeout'] = value_
        fields['cte_type'] = CteType(span[5])
        span = span[6:]
        return LeSetDefaultPeriodicAdvertisingSyncTransferParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.mode << 0))
        if self.skip > 65535:
            print(f"Invalid value for field LeSetDefaultPeriodicAdvertisingSyncTransferParameters::skip: {self.skip} > 65535; the value will be truncated")
            self.skip &= 65535
        _span.extend(int.to_bytes((self.skip << 0), length=2, byteorder='little'))
        if self.sync_timeout > 65535:
            print(f"Invalid value for field LeSetDefaultPeriodicAdvertisingSyncTransferParameters::sync_timeout: {self.sync_timeout} > 65535; the value will be truncated")
            self.sync_timeout &= 65535
        _span.extend(int.to_bytes((self.sync_timeout << 0), length=2, byteorder='little'))
        _span.append((self.cte_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetDefaultPeriodicAdvertisingSyncTransferParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class UseDebugKey(enum.IntEnum):
    USE_GENERATED_KEY = 0x0
    USE_DEBUG_KEY = 0x1

@dataclass
class LeGenerateDhkeyCommand(Command):
    remote_p_256_public_key: bytearray = field(kw_only=True, default_factory=bytearray)
    key_type: UseDebugKey = field(kw_only=True, default=UseDebugKey.USE_GENERATED_KEY)

    def __post_init__(self):
        self.op_code = OpCode.LE_GENERATE_DHKEY_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGenerateDhkeyCommand', bytes]:
        if fields['op_code'] != OpCode.LE_GENERATE_DHKEY_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 64:
            raise Exception('Invalid packet size')
        fields['remote_p_256_public_key'] = list(span[:64])
        span = span[64:]
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['key_type'] = UseDebugKey(span[0])
        span = span[1:]
        return LeGenerateDhkeyCommand(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.remote_p_256_public_key)
        _span.append((self.key_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 65

@dataclass
class LeGenerateDhkeyCommandStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_GENERATE_DHKEY_V2
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGenerateDhkeyCommandStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_GENERATE_DHKEY_V2:
            raise Exception("Invalid constraint field values")
        return LeGenerateDhkeyCommandStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class ScaAction(enum.IntEnum):
    MORE_ACCURATE_CLOCK = 0x0
    LESS_ACCURATE_CLOCK = 0x1

@dataclass
class LeModifySleepClockAccuracy(Command):
    action: ScaAction = field(kw_only=True, default=ScaAction.MORE_ACCURATE_CLOCK)

    def __post_init__(self):
        self.op_code = OpCode.LE_MODIFY_SLEEP_CLOCK_ACCURACY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeModifySleepClockAccuracy', bytes]:
        if fields['op_code'] != OpCode.LE_MODIFY_SLEEP_CLOCK_ACCURACY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['action'] = ScaAction(span[0])
        span = span[1:]
        return LeModifySleepClockAccuracy(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.action << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeModifySleepClockAccuracyComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_MODIFY_SLEEP_CLOCK_ACCURACY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeModifySleepClockAccuracyComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_MODIFY_SLEEP_CLOCK_ACCURACY:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeModifySleepClockAccuracyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadBufferSizeV2(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_BUFFER_SIZE_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadBufferSizeV2', bytes]:
        if fields['op_code'] != OpCode.LE_READ_BUFFER_SIZE_V2:
            raise Exception("Invalid constraint field values")
        return LeReadBufferSizeV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeReadBufferSizeV2Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    le_buffer_size: LeBufferSize = field(kw_only=True, default_factory=LeBufferSize)
    iso_buffer_size: LeBufferSize = field(kw_only=True, default_factory=LeBufferSize)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_BUFFER_SIZE_V2
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadBufferSizeV2Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_BUFFER_SIZE_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['le_buffer_size'] = LeBufferSize.parse_all(span[1:4])
        fields['iso_buffer_size'] = LeBufferSize.parse_all(span[4:7])
        span = span[7:]
        return LeReadBufferSizeV2Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.le_buffer_size.serialize())
        _span.extend(self.iso_buffer_size.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LeReadIsoTxSync(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_ISO_TX_SYNC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadIsoTxSync', bytes]:
        if fields['op_code'] != OpCode.LE_READ_ISO_TX_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeReadIsoTxSync(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadIsoTxSync::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeReadIsoTxSyncComplete(CommandComplete):
    connection_handle: int = field(kw_only=True, default=0)
    packet_sequence_number: int = field(kw_only=True, default=0)
    timestamp: int = field(kw_only=True, default=0)
    time_offset: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_ISO_TX_SYNC
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadIsoTxSyncComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_ISO_TX_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['packet_sequence_number'] = value_
        value_ = int.from_bytes(span[4:8], byteorder='little')
        fields['timestamp'] = value_
        value_ = int.from_bytes(span[8:11], byteorder='little')
        fields['time_offset'] = value_
        span = span[11:]
        return LeReadIsoTxSyncComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadIsoTxSyncComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.packet_sequence_number > 65535:
            print(f"Invalid value for field LeReadIsoTxSyncComplete::packet_sequence_number: {self.packet_sequence_number} > 65535; the value will be truncated")
            self.packet_sequence_number &= 65535
        _span.extend(int.to_bytes((self.packet_sequence_number << 0), length=2, byteorder='little'))
        if self.timestamp > 4294967295:
            print(f"Invalid value for field LeReadIsoTxSyncComplete::timestamp: {self.timestamp} > 4294967295; the value will be truncated")
            self.timestamp &= 4294967295
        _span.extend(int.to_bytes((self.timestamp << 0), length=4, byteorder='little'))
        if self.time_offset > 16777215:
            print(f"Invalid value for field LeReadIsoTxSyncComplete::time_offset: {self.time_offset} > 16777215; the value will be truncated")
            self.time_offset &= 16777215
        _span.extend(int.to_bytes((self.time_offset << 0), length=3, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

@dataclass
class CisParametersConfig(Packet):
    cis_id: int = field(kw_only=True, default=0)
    max_sdu_c_to_p: int = field(kw_only=True, default=0)
    max_sdu_p_to_c: int = field(kw_only=True, default=0)
    phy_c_to_p: int = field(kw_only=True, default=0)
    phy_p_to_c: int = field(kw_only=True, default=0)
    rtn_c_to_p: int = field(kw_only=True, default=0)
    rtn_p_to_c: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CisParametersConfig', bytes]:
        fields = {'payload': None}
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['cis_id'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['max_sdu_c_to_p'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['max_sdu_p_to_c'] = (value_ >> 0) & 0xfff
        fields['phy_c_to_p'] = (span[5] >> 0) & 0x7
        fields['phy_p_to_c'] = (span[6] >> 0) & 0x7
        fields['rtn_c_to_p'] = (span[7] >> 0) & 0xf
        fields['rtn_p_to_c'] = (span[8] >> 0) & 0xf
        span = span[9:]
        return CisParametersConfig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.cis_id > 255:
            print(f"Invalid value for field CisParametersConfig::cis_id: {self.cis_id} > 255; the value will be truncated")
            self.cis_id &= 255
        _span.append((self.cis_id << 0))
        if self.max_sdu_c_to_p > 4095:
            print(f"Invalid value for field CisParametersConfig::max_sdu_c_to_p: {self.max_sdu_c_to_p} > 4095; the value will be truncated")
            self.max_sdu_c_to_p &= 4095
        _span.extend(int.to_bytes((self.max_sdu_c_to_p << 0), length=2, byteorder='little'))
        if self.max_sdu_p_to_c > 4095:
            print(f"Invalid value for field CisParametersConfig::max_sdu_p_to_c: {self.max_sdu_p_to_c} > 4095; the value will be truncated")
            self.max_sdu_p_to_c &= 4095
        _span.extend(int.to_bytes((self.max_sdu_p_to_c << 0), length=2, byteorder='little'))
        if self.phy_c_to_p > 7:
            print(f"Invalid value for field CisParametersConfig::phy_c_to_p: {self.phy_c_to_p} > 7; the value will be truncated")
            self.phy_c_to_p &= 7
        _span.append((self.phy_c_to_p << 0))
        if self.phy_p_to_c > 7:
            print(f"Invalid value for field CisParametersConfig::phy_p_to_c: {self.phy_p_to_c} > 7; the value will be truncated")
            self.phy_p_to_c &= 7
        _span.append((self.phy_p_to_c << 0))
        if self.rtn_c_to_p > 15:
            print(f"Invalid value for field CisParametersConfig::rtn_c_to_p: {self.rtn_c_to_p} > 15; the value will be truncated")
            self.rtn_c_to_p &= 15
        _span.append((self.rtn_c_to_p << 0))
        if self.rtn_p_to_c > 15:
            print(f"Invalid value for field CisParametersConfig::rtn_p_to_c: {self.rtn_p_to_c} > 15; the value will be truncated")
            self.rtn_p_to_c &= 15
        _span.append((self.rtn_p_to_c << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 9

class Packing(enum.IntEnum):
    SEQUENTIAL = 0x0
    INTERLEAVED = 0x1

class ClockAccuracy(enum.IntEnum):
    PPM_500 = 0x0
    PPM_250 = 0x1
    PPM_150 = 0x2
    PPM_100 = 0x3
    PPM_75 = 0x4
    PPM_50 = 0x5
    PPM_30 = 0x6
    PPM_20 = 0x7

@dataclass
class LeSetCigParameters(Command):
    cig_id: int = field(kw_only=True, default=0)
    sdu_interval_c_to_p: int = field(kw_only=True, default=0)
    sdu_interval_p_to_c: int = field(kw_only=True, default=0)
    worst_case_sca: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)
    packing: Packing = field(kw_only=True, default=Packing.SEQUENTIAL)
    framing: Enable = field(kw_only=True, default=Enable.DISABLED)
    max_transport_latency_c_to_p: int = field(kw_only=True, default=0)
    max_transport_latency_p_to_c: int = field(kw_only=True, default=0)
    cis_config: List[CisParametersConfig] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_CIG_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetCigParameters', bytes]:
        if fields['op_code'] != OpCode.LE_SET_CIG_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 15:
            raise Exception('Invalid packet size')
        fields['cig_id'] = span[0]
        value_ = int.from_bytes(span[1:4], byteorder='little')
        fields['sdu_interval_c_to_p'] = value_
        value_ = int.from_bytes(span[4:7], byteorder='little')
        fields['sdu_interval_p_to_c'] = value_
        fields['worst_case_sca'] = ClockAccuracy(span[7])
        fields['packing'] = Packing(span[8])
        fields['framing'] = Enable(span[9])
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['max_transport_latency_c_to_p'] = value_
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['max_transport_latency_p_to_c'] = value_
        cis_config_count = span[14]
        span = span[15:]
        if len(span) < cis_config_count * 9:
            raise Exception('Invalid packet size')
        cis_config = []
        for n in range(cis_config_count):
            cis_config.append(CisParametersConfig.parse_all(span[n * 9:(n + 1) * 9]))
        fields['cis_config'] = cis_config
        span = span[cis_config_count * 9:]
        return LeSetCigParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.cig_id > 255:
            print(f"Invalid value for field LeSetCigParameters::cig_id: {self.cig_id} > 255; the value will be truncated")
            self.cig_id &= 255
        _span.append((self.cig_id << 0))
        if self.sdu_interval_c_to_p > 16777215:
            print(f"Invalid value for field LeSetCigParameters::sdu_interval_c_to_p: {self.sdu_interval_c_to_p} > 16777215; the value will be truncated")
            self.sdu_interval_c_to_p &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval_c_to_p << 0), length=3, byteorder='little'))
        if self.sdu_interval_p_to_c > 16777215:
            print(f"Invalid value for field LeSetCigParameters::sdu_interval_p_to_c: {self.sdu_interval_p_to_c} > 16777215; the value will be truncated")
            self.sdu_interval_p_to_c &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval_p_to_c << 0), length=3, byteorder='little'))
        _span.append((self.worst_case_sca << 0))
        _span.append((self.packing << 0))
        _span.append((self.framing << 0))
        if self.max_transport_latency_c_to_p > 65535:
            print(f"Invalid value for field LeSetCigParameters::max_transport_latency_c_to_p: {self.max_transport_latency_c_to_p} > 65535; the value will be truncated")
            self.max_transport_latency_c_to_p &= 65535
        _span.extend(int.to_bytes((self.max_transport_latency_c_to_p << 0), length=2, byteorder='little'))
        if self.max_transport_latency_p_to_c > 65535:
            print(f"Invalid value for field LeSetCigParameters::max_transport_latency_p_to_c: {self.max_transport_latency_p_to_c} > 65535; the value will be truncated")
            self.max_transport_latency_p_to_c &= 65535
        _span.extend(int.to_bytes((self.max_transport_latency_p_to_c << 0), length=2, byteorder='little'))
        if len(self.cis_config) > 255:
            print(f"Invalid length for field LeSetCigParameters::cis_config:  {len(self.cis_config)} > 255; the array will be truncated")
            del self.cis_config[255:]
        _span.append((len(self.cis_config) << 0))
        for _elt in self.cis_config:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.cis_config]) + 15

@dataclass
class LeSetCigParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    cig_id: int = field(kw_only=True, default=0)
    connection_handle: List[int] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_CIG_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetCigParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_CIG_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['cig_id'] = span[1]
        connection_handle_count = span[2]
        span = span[3:]
        if len(span) < connection_handle_count * 2:
            raise Exception('Invalid packet size')
        connection_handle = []
        for n in range(connection_handle_count):
            connection_handle.append(int.from_bytes(span[n * 2:(n + 1) * 2], byteorder='little'))
        fields['connection_handle'] = connection_handle
        span = span[connection_handle_count * 2:]
        return LeSetCigParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.cig_id > 255:
            print(f"Invalid value for field LeSetCigParametersComplete::cig_id: {self.cig_id} > 255; the value will be truncated")
            self.cig_id &= 255
        _span.append((self.cig_id << 0))
        if len(self.connection_handle) > 255:
            print(f"Invalid length for field LeSetCigParametersComplete::connection_handle:  {len(self.connection_handle)} > 255; the array will be truncated")
            del self.connection_handle[255:]
        _span.append((len(self.connection_handle) << 0))
        for _elt in self.connection_handle:
            _span.extend(int.to_bytes(_elt, length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.connection_handle) * 2 + 3

@dataclass
class LeCisParametersTestConfig(Packet):
    cis_id: int = field(kw_only=True, default=0)
    nse: int = field(kw_only=True, default=0)
    max_sdu_c_to_p: int = field(kw_only=True, default=0)
    max_sdu_p_to_c: int = field(kw_only=True, default=0)
    max_pdu_c_to_p: int = field(kw_only=True, default=0)
    max_pdu_p_to_c: int = field(kw_only=True, default=0)
    phy_c_to_p: int = field(kw_only=True, default=0)
    phy_p_to_c: int = field(kw_only=True, default=0)
    bn_c_to_p: int = field(kw_only=True, default=0)
    bn_p_to_c: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LeCisParametersTestConfig', bytes]:
        fields = {'payload': None}
        if len(span) < 14:
            raise Exception('Invalid packet size')
        fields['cis_id'] = span[0]
        fields['nse'] = span[1]
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['max_sdu_c_to_p'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['max_sdu_p_to_c'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['max_pdu_c_to_p'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['max_pdu_p_to_c'] = value_
        fields['phy_c_to_p'] = span[10]
        fields['phy_p_to_c'] = span[11]
        fields['bn_c_to_p'] = span[12]
        fields['bn_p_to_c'] = span[13]
        span = span[14:]
        return LeCisParametersTestConfig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.cis_id > 255:
            print(f"Invalid value for field LeCisParametersTestConfig::cis_id: {self.cis_id} > 255; the value will be truncated")
            self.cis_id &= 255
        _span.append((self.cis_id << 0))
        if self.nse > 255:
            print(f"Invalid value for field LeCisParametersTestConfig::nse: {self.nse} > 255; the value will be truncated")
            self.nse &= 255
        _span.append((self.nse << 0))
        if self.max_sdu_c_to_p > 65535:
            print(f"Invalid value for field LeCisParametersTestConfig::max_sdu_c_to_p: {self.max_sdu_c_to_p} > 65535; the value will be truncated")
            self.max_sdu_c_to_p &= 65535
        _span.extend(int.to_bytes((self.max_sdu_c_to_p << 0), length=2, byteorder='little'))
        if self.max_sdu_p_to_c > 65535:
            print(f"Invalid value for field LeCisParametersTestConfig::max_sdu_p_to_c: {self.max_sdu_p_to_c} > 65535; the value will be truncated")
            self.max_sdu_p_to_c &= 65535
        _span.extend(int.to_bytes((self.max_sdu_p_to_c << 0), length=2, byteorder='little'))
        if self.max_pdu_c_to_p > 65535:
            print(f"Invalid value for field LeCisParametersTestConfig::max_pdu_c_to_p: {self.max_pdu_c_to_p} > 65535; the value will be truncated")
            self.max_pdu_c_to_p &= 65535
        _span.extend(int.to_bytes((self.max_pdu_c_to_p << 0), length=2, byteorder='little'))
        if self.max_pdu_p_to_c > 65535:
            print(f"Invalid value for field LeCisParametersTestConfig::max_pdu_p_to_c: {self.max_pdu_p_to_c} > 65535; the value will be truncated")
            self.max_pdu_p_to_c &= 65535
        _span.extend(int.to_bytes((self.max_pdu_p_to_c << 0), length=2, byteorder='little'))
        if self.phy_c_to_p > 255:
            print(f"Invalid value for field LeCisParametersTestConfig::phy_c_to_p: {self.phy_c_to_p} > 255; the value will be truncated")
            self.phy_c_to_p &= 255
        _span.append((self.phy_c_to_p << 0))
        if self.phy_p_to_c > 255:
            print(f"Invalid value for field LeCisParametersTestConfig::phy_p_to_c: {self.phy_p_to_c} > 255; the value will be truncated")
            self.phy_p_to_c &= 255
        _span.append((self.phy_p_to_c << 0))
        if self.bn_c_to_p > 255:
            print(f"Invalid value for field LeCisParametersTestConfig::bn_c_to_p: {self.bn_c_to_p} > 255; the value will be truncated")
            self.bn_c_to_p &= 255
        _span.append((self.bn_c_to_p << 0))
        if self.bn_p_to_c > 255:
            print(f"Invalid value for field LeCisParametersTestConfig::bn_p_to_c: {self.bn_p_to_c} > 255; the value will be truncated")
            self.bn_p_to_c &= 255
        _span.append((self.bn_p_to_c << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 14

@dataclass
class LeSetCigParametersTest(Command):
    cig_id: int = field(kw_only=True, default=0)
    sdu_interval_c_to_p: int = field(kw_only=True, default=0)
    sdu_interval_p_to_c: int = field(kw_only=True, default=0)
    ft_c_to_p: int = field(kw_only=True, default=0)
    ft_p_to_c: int = field(kw_only=True, default=0)
    iso_interval: int = field(kw_only=True, default=0)
    worst_case_sca: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)
    packing: Packing = field(kw_only=True, default=Packing.SEQUENTIAL)
    framing: Enable = field(kw_only=True, default=Enable.DISABLED)
    cis_config: List[LeCisParametersTestConfig] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_CIG_PARAMETERS_TEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetCigParametersTest', bytes]:
        if fields['op_code'] != OpCode.LE_SET_CIG_PARAMETERS_TEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 15:
            raise Exception('Invalid packet size')
        fields['cig_id'] = span[0]
        value_ = int.from_bytes(span[1:4], byteorder='little')
        fields['sdu_interval_c_to_p'] = value_
        value_ = int.from_bytes(span[4:7], byteorder='little')
        fields['sdu_interval_p_to_c'] = value_
        fields['ft_c_to_p'] = span[7]
        fields['ft_p_to_c'] = span[8]
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['iso_interval'] = value_
        fields['worst_case_sca'] = ClockAccuracy(span[11])
        fields['packing'] = Packing(span[12])
        fields['framing'] = Enable(span[13])
        cis_config_count = span[14]
        span = span[15:]
        if len(span) < cis_config_count * 14:
            raise Exception('Invalid packet size')
        cis_config = []
        for n in range(cis_config_count):
            cis_config.append(LeCisParametersTestConfig.parse_all(span[n * 14:(n + 1) * 14]))
        fields['cis_config'] = cis_config
        span = span[cis_config_count * 14:]
        return LeSetCigParametersTest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.cig_id > 255:
            print(f"Invalid value for field LeSetCigParametersTest::cig_id: {self.cig_id} > 255; the value will be truncated")
            self.cig_id &= 255
        _span.append((self.cig_id << 0))
        if self.sdu_interval_c_to_p > 16777215:
            print(f"Invalid value for field LeSetCigParametersTest::sdu_interval_c_to_p: {self.sdu_interval_c_to_p} > 16777215; the value will be truncated")
            self.sdu_interval_c_to_p &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval_c_to_p << 0), length=3, byteorder='little'))
        if self.sdu_interval_p_to_c > 16777215:
            print(f"Invalid value for field LeSetCigParametersTest::sdu_interval_p_to_c: {self.sdu_interval_p_to_c} > 16777215; the value will be truncated")
            self.sdu_interval_p_to_c &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval_p_to_c << 0), length=3, byteorder='little'))
        if self.ft_c_to_p > 255:
            print(f"Invalid value for field LeSetCigParametersTest::ft_c_to_p: {self.ft_c_to_p} > 255; the value will be truncated")
            self.ft_c_to_p &= 255
        _span.append((self.ft_c_to_p << 0))
        if self.ft_p_to_c > 255:
            print(f"Invalid value for field LeSetCigParametersTest::ft_p_to_c: {self.ft_p_to_c} > 255; the value will be truncated")
            self.ft_p_to_c &= 255
        _span.append((self.ft_p_to_c << 0))
        if self.iso_interval > 65535:
            print(f"Invalid value for field LeSetCigParametersTest::iso_interval: {self.iso_interval} > 65535; the value will be truncated")
            self.iso_interval &= 65535
        _span.extend(int.to_bytes((self.iso_interval << 0), length=2, byteorder='little'))
        _span.append((self.worst_case_sca << 0))
        _span.append((self.packing << 0))
        _span.append((self.framing << 0))
        if len(self.cis_config) > 255:
            print(f"Invalid length for field LeSetCigParametersTest::cis_config:  {len(self.cis_config)} > 255; the array will be truncated")
            del self.cis_config[255:]
        _span.append((len(self.cis_config) << 0))
        for _elt in self.cis_config:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.cis_config]) + 15

@dataclass
class LeSetCigParametersTestComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    cig_id: int = field(kw_only=True, default=0)
    connection_handle: List[int] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_CIG_PARAMETERS_TEST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetCigParametersTestComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_CIG_PARAMETERS_TEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['cig_id'] = span[1]
        connection_handle_count = span[2]
        span = span[3:]
        if len(span) < connection_handle_count * 2:
            raise Exception('Invalid packet size')
        connection_handle = []
        for n in range(connection_handle_count):
            connection_handle.append(int.from_bytes(span[n * 2:(n + 1) * 2], byteorder='little'))
        fields['connection_handle'] = connection_handle
        span = span[connection_handle_count * 2:]
        return LeSetCigParametersTestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.cig_id > 255:
            print(f"Invalid value for field LeSetCigParametersTestComplete::cig_id: {self.cig_id} > 255; the value will be truncated")
            self.cig_id &= 255
        _span.append((self.cig_id << 0))
        if len(self.connection_handle) > 255:
            print(f"Invalid length for field LeSetCigParametersTestComplete::connection_handle:  {len(self.connection_handle)} > 255; the array will be truncated")
            del self.connection_handle[255:]
        _span.append((len(self.connection_handle) << 0))
        for _elt in self.connection_handle:
            _span.extend(int.to_bytes(_elt, length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.connection_handle) * 2 + 3

@dataclass
class LeCreateCisConfig(Packet):
    cis_connection_handle: int = field(kw_only=True, default=0)
    acl_connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LeCreateCisConfig', bytes]:
        fields = {'payload': None}
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['cis_connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['acl_connection_handle'] = (value_ >> 0) & 0xfff
        span = span[4:]
        return LeCreateCisConfig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.cis_connection_handle > 4095:
            print(f"Invalid value for field LeCreateCisConfig::cis_connection_handle: {self.cis_connection_handle} > 4095; the value will be truncated")
            self.cis_connection_handle &= 4095
        _span.extend(int.to_bytes((self.cis_connection_handle << 0), length=2, byteorder='little'))
        if self.acl_connection_handle > 4095:
            print(f"Invalid value for field LeCreateCisConfig::acl_connection_handle: {self.acl_connection_handle} > 4095; the value will be truncated")
            self.acl_connection_handle &= 4095
        _span.extend(int.to_bytes((self.acl_connection_handle << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 4

@dataclass
class LeCreateCis(Command):
    cis_config: List[LeCreateCisConfig] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.op_code = OpCode.LE_CREATE_CIS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateCis', bytes]:
        if fields['op_code'] != OpCode.LE_CREATE_CIS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        cis_config_count = span[0]
        span = span[1:]
        if len(span) < cis_config_count * 4:
            raise Exception('Invalid packet size')
        cis_config = []
        for n in range(cis_config_count):
            cis_config.append(LeCreateCisConfig.parse_all(span[n * 4:(n + 1) * 4]))
        fields['cis_config'] = cis_config
        span = span[cis_config_count * 4:]
        return LeCreateCis(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.cis_config) > 255:
            print(f"Invalid length for field LeCreateCis::cis_config:  {len(self.cis_config)} > 255; the array will be truncated")
            del self.cis_config[255:]
        _span.append((len(self.cis_config) << 0))
        for _elt in self.cis_config:
            _span.extend(_elt.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.cis_config]) + 1

@dataclass
class LeCreateCisStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CREATE_CIS
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateCisStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CREATE_CIS:
            raise Exception("Invalid constraint field values")
        return LeCreateCisStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeRemoveCig(Command):
    cig_id: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOVE_CIG

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveCig', bytes]:
        if fields['op_code'] != OpCode.LE_REMOVE_CIG:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['cig_id'] = span[0]
        span = span[1:]
        return LeRemoveCig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.cig_id > 255:
            print(f"Invalid value for field LeRemoveCig::cig_id: {self.cig_id} > 255; the value will be truncated")
            self.cig_id &= 255
        _span.append((self.cig_id << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeRemoveCigComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    cig_id: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOVE_CIG
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveCigComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOVE_CIG:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['cig_id'] = span[1]
        span = span[2:]
        return LeRemoveCigComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.cig_id > 255:
            print(f"Invalid value for field LeRemoveCigComplete::cig_id: {self.cig_id} > 255; the value will be truncated")
            self.cig_id &= 255
        _span.append((self.cig_id << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeAcceptCisRequest(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_ACCEPT_CIS_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAcceptCisRequest', bytes]:
        if fields['op_code'] != OpCode.LE_ACCEPT_CIS_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeAcceptCisRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeAcceptCisRequest::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeAcceptCisRequestStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_ACCEPT_CIS_REQUEST
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAcceptCisRequestStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_ACCEPT_CIS_REQUEST:
            raise Exception("Invalid constraint field values")
        return LeAcceptCisRequestStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeRejectCisRequest(Command):
    connection_handle: int = field(kw_only=True, default=0)
    reason: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.op_code = OpCode.LE_REJECT_CIS_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRejectCisRequest', bytes]:
        if fields['op_code'] != OpCode.LE_REJECT_CIS_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['reason'] = ErrorCode(span[2])
        span = span[3:]
        return LeRejectCisRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRejectCisRequest::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.reason << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeRejectCisRequestComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REJECT_CIS_REQUEST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRejectCisRequestComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REJECT_CIS_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeRejectCisRequestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRejectCisRequestComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeCreateBig(Command):
    big_handle: int = field(kw_only=True, default=0)
    advertising_handle: int = field(kw_only=True, default=0)
    num_bis: int = field(kw_only=True, default=0)
    sdu_interval: int = field(kw_only=True, default=0)
    max_sdu: int = field(kw_only=True, default=0)
    max_transport_latency: int = field(kw_only=True, default=0)
    rtn: int = field(kw_only=True, default=0)
    phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    packing: Packing = field(kw_only=True, default=Packing.SEQUENTIAL)
    framing: Enable = field(kw_only=True, default=Enable.DISABLED)
    encryption: Enable = field(kw_only=True, default=Enable.DISABLED)
    broadcast_code: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_CREATE_BIG

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateBig', bytes]:
        if fields['op_code'] != OpCode.LE_CREATE_BIG:
            raise Exception("Invalid constraint field values")
        if len(span) < 15:
            raise Exception('Invalid packet size')
        fields['big_handle'] = span[0]
        fields['advertising_handle'] = span[1]
        fields['num_bis'] = span[2]
        value_ = int.from_bytes(span[3:6], byteorder='little')
        fields['sdu_interval'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['max_sdu'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['max_transport_latency'] = value_
        fields['rtn'] = (span[10] >> 0) & 0xf
        fields['phy'] = SecondaryPhyType(span[11])
        fields['packing'] = Packing(span[12])
        fields['framing'] = Enable(span[13])
        fields['encryption'] = Enable(span[14])
        span = span[15:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['broadcast_code'] = list(span[:16])
        span = span[16:]
        return LeCreateBig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.big_handle > 255:
            print(f"Invalid value for field LeCreateBig::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeCreateBig::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.num_bis > 255:
            print(f"Invalid value for field LeCreateBig::num_bis: {self.num_bis} > 255; the value will be truncated")
            self.num_bis &= 255
        _span.append((self.num_bis << 0))
        if self.sdu_interval > 16777215:
            print(f"Invalid value for field LeCreateBig::sdu_interval: {self.sdu_interval} > 16777215; the value will be truncated")
            self.sdu_interval &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval << 0), length=3, byteorder='little'))
        if self.max_sdu > 65535:
            print(f"Invalid value for field LeCreateBig::max_sdu: {self.max_sdu} > 65535; the value will be truncated")
            self.max_sdu &= 65535
        _span.extend(int.to_bytes((self.max_sdu << 0), length=2, byteorder='little'))
        if self.max_transport_latency > 65535:
            print(f"Invalid value for field LeCreateBig::max_transport_latency: {self.max_transport_latency} > 65535; the value will be truncated")
            self.max_transport_latency &= 65535
        _span.extend(int.to_bytes((self.max_transport_latency << 0), length=2, byteorder='little'))
        if self.rtn > 15:
            print(f"Invalid value for field LeCreateBig::rtn: {self.rtn} > 15; the value will be truncated")
            self.rtn &= 15
        _span.append((self.rtn << 0))
        _span.append((self.phy << 0))
        _span.append((self.packing << 0))
        _span.append((self.framing << 0))
        _span.append((self.encryption << 0))
        _span.extend(self.broadcast_code)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 31

@dataclass
class LeCreateBigStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CREATE_BIG
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateBigStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CREATE_BIG:
            raise Exception("Invalid constraint field values")
        return LeCreateBigStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeTerminateBig(Command):
    big_handle: int = field(kw_only=True, default=0)
    reason: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.op_code = OpCode.LE_TERMINATE_BIG

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTerminateBig', bytes]:
        if fields['op_code'] != OpCode.LE_TERMINATE_BIG:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['big_handle'] = span[0]
        fields['reason'] = ErrorCode(span[1])
        span = span[2:]
        return LeTerminateBig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.big_handle > 255:
            print(f"Invalid value for field LeTerminateBig::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        _span.append((self.reason << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeTerminateBigStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_TERMINATE_BIG
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTerminateBigStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_TERMINATE_BIG:
            raise Exception("Invalid constraint field values")
        return LeTerminateBigStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeBigCreateSync(Command):
    big_handle: int = field(kw_only=True, default=0)
    sync_handle: int = field(kw_only=True, default=0)
    encryption: Enable = field(kw_only=True, default=Enable.DISABLED)
    broadcast_code: bytearray = field(kw_only=True, default_factory=bytearray)
    mse: int = field(kw_only=True, default=0)
    big_sync_timeout: int = field(kw_only=True, default=0)
    bis: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_BIG_CREATE_SYNC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBigCreateSync', bytes]:
        if fields['op_code'] != OpCode.LE_BIG_CREATE_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['big_handle'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['encryption'] = Enable(span[3])
        span = span[4:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['broadcast_code'] = list(span[:16])
        span = span[16:]
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['mse'] = (span[0] >> 0) & 0x1f
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['big_sync_timeout'] = value_
        bis_count = span[3]
        span = span[4:]
        if len(span) < bis_count:
            raise Exception('Invalid packet size')
        fields['bis'] = list(span[:bis_count])
        span = span[bis_count:]
        return LeBigCreateSync(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.big_handle > 255:
            print(f"Invalid value for field LeBigCreateSync::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        if self.sync_handle > 4095:
            print(f"Invalid value for field LeBigCreateSync::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        _span.append((self.encryption << 0))
        _span.extend(self.broadcast_code)
        if self.mse > 31:
            print(f"Invalid value for field LeBigCreateSync::mse: {self.mse} > 31; the value will be truncated")
            self.mse &= 31
        _span.append((self.mse << 0))
        if self.big_sync_timeout > 65535:
            print(f"Invalid value for field LeBigCreateSync::big_sync_timeout: {self.big_sync_timeout} > 65535; the value will be truncated")
            self.big_sync_timeout &= 65535
        _span.extend(int.to_bytes((self.big_sync_timeout << 0), length=2, byteorder='little'))
        if len(self.bis) > 255:
            print(f"Invalid length for field LeBigCreateSync::bis:  {len(self.bis)} > 255; the array will be truncated")
            del self.bis[255:]
        _span.append((len(self.bis) << 0))
        _span.extend(self.bis)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.bis) * 1 + 24

@dataclass
class LeBigCreateSyncStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_BIG_CREATE_SYNC
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBigCreateSyncStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_BIG_CREATE_SYNC:
            raise Exception("Invalid constraint field values")
        return LeBigCreateSyncStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeBigTerminateSync(Command):
    big_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_BIG_TERMINATE_SYNC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBigTerminateSync', bytes]:
        if fields['op_code'] != OpCode.LE_BIG_TERMINATE_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['big_handle'] = span[0]
        span = span[1:]
        return LeBigTerminateSync(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.big_handle > 255:
            print(f"Invalid value for field LeBigTerminateSync::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeBigTerminateSyncComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    big_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_BIG_TERMINATE_SYNC
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBigTerminateSyncComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_BIG_TERMINATE_SYNC:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['big_handle'] = span[1]
        span = span[2:]
        return LeBigTerminateSyncComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.big_handle > 255:
            print(f"Invalid value for field LeBigTerminateSyncComplete::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeRequestPeerSca(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_REQUEST_PEER_SCA

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRequestPeerSca', bytes]:
        if fields['op_code'] != OpCode.LE_REQUEST_PEER_SCA:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeRequestPeerSca(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRequestPeerSca::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeRequestPeerScaStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REQUEST_PEER_SCA
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRequestPeerScaStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_REQUEST_PEER_SCA:
            raise Exception("Invalid constraint field values")
        return LeRequestPeerScaStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeSetupIsoDataPath(Command):
    connection_handle: int = field(kw_only=True, default=0)
    data_path_direction: DataPathDirection = field(kw_only=True, default=DataPathDirection.INPUT)
    data_path_id: int = field(kw_only=True, default=0)
    codec_id: int = field(kw_only=True, default=0)
    controller_delay: int = field(kw_only=True, default=0)
    codec_configuration: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_SETUP_ISO_DATA_PATH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetupIsoDataPath', bytes]:
        if fields['op_code'] != OpCode.LE_SETUP_ISO_DATA_PATH:
            raise Exception("Invalid constraint field values")
        if len(span) < 13:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['data_path_direction'] = DataPathDirection(span[2])
        fields['data_path_id'] = span[3]
        value_ = int.from_bytes(span[4:9], byteorder='little')
        fields['codec_id'] = value_
        value_ = int.from_bytes(span[9:12], byteorder='little')
        fields['controller_delay'] = value_
        codec_configuration_count = span[12]
        span = span[13:]
        if len(span) < codec_configuration_count:
            raise Exception('Invalid packet size')
        fields['codec_configuration'] = list(span[:codec_configuration_count])
        span = span[codec_configuration_count:]
        return LeSetupIsoDataPath(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetupIsoDataPath::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.data_path_direction << 0))
        if self.data_path_id > 255:
            print(f"Invalid value for field LeSetupIsoDataPath::data_path_id: {self.data_path_id} > 255; the value will be truncated")
            self.data_path_id &= 255
        _span.append((self.data_path_id << 0))
        if self.codec_id > 1099511627775:
            print(f"Invalid value for field LeSetupIsoDataPath::codec_id: {self.codec_id} > 1099511627775; the value will be truncated")
            self.codec_id &= 1099511627775
        _span.extend(int.to_bytes((self.codec_id << 0), length=5, byteorder='little'))
        if self.controller_delay > 16777215:
            print(f"Invalid value for field LeSetupIsoDataPath::controller_delay: {self.controller_delay} > 16777215; the value will be truncated")
            self.controller_delay &= 16777215
        _span.extend(int.to_bytes((self.controller_delay << 0), length=3, byteorder='little'))
        if len(self.codec_configuration) > 255:
            print(f"Invalid length for field LeSetupIsoDataPath::codec_configuration:  {len(self.codec_configuration)} > 255; the array will be truncated")
            del self.codec_configuration[255:]
        _span.append((len(self.codec_configuration) << 0))
        _span.extend(self.codec_configuration)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.codec_configuration) * 1 + 13

@dataclass
class LeSetupIsoDataPathComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SETUP_ISO_DATA_PATH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetupIsoDataPathComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SETUP_ISO_DATA_PATH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeSetupIsoDataPathComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetupIsoDataPathComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

class RemoveDataPathDirection(enum.IntEnum):
    INPUT = 0x1
    OUTPUT = 0x2
    INPUT_AND_OUTPUT = 0x3

@dataclass
class LeRemoveIsoDataPath(Command):
    connection_handle: int = field(kw_only=True, default=0)
    remove_data_path_direction: RemoveDataPathDirection = field(kw_only=True, default=RemoveDataPathDirection.INPUT)

    def __post_init__(self):
        self.op_code = OpCode.LE_REMOVE_ISO_DATA_PATH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveIsoDataPath', bytes]:
        if fields['op_code'] != OpCode.LE_REMOVE_ISO_DATA_PATH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['remove_data_path_direction'] = RemoveDataPathDirection(span[2])
        span = span[3:]
        return LeRemoveIsoDataPath(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRemoveIsoDataPath::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.remove_data_path_direction << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeRemoveIsoDataPathComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_REMOVE_ISO_DATA_PATH
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoveIsoDataPathComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_REMOVE_ISO_DATA_PATH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeRemoveIsoDataPathComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRemoveIsoDataPathComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

class LeHostFeatureBits(enum.IntEnum):
    CONNECTED_ISO_STREAM_HOST_SUPPORT = 0x20
    CONNECTION_SUBRATING_HOST_SUPPORT = 0x26

@dataclass
class LeSetHostFeatureV1(Command):
    bit_number: LeHostFeatureBits = field(kw_only=True, default=LeHostFeatureBits.CONNECTED_ISO_STREAM_HOST_SUPPORT)
    bit_value: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_HOST_FEATURE_V1

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetHostFeatureV1', bytes]:
        if fields['op_code'] != OpCode.LE_SET_HOST_FEATURE_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['bit_number'] = LeHostFeatureBits(span[0])
        fields['bit_value'] = Enable(span[1])
        span = span[2:]
        return LeSetHostFeatureV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.bit_number << 0))
        _span.append((self.bit_value << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetHostFeatureV1Complete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_HOST_FEATURE_V1
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetHostFeatureV1Complete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_HOST_FEATURE_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetHostFeatureV1Complete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeReadIsoLinkQuality(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_ISO_LINK_QUALITY

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadIsoLinkQuality', bytes]:
        if fields['op_code'] != OpCode.LE_READ_ISO_LINK_QUALITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeReadIsoLinkQuality(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadIsoLinkQuality::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeReadIsoLinkQualityComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    tx_unacked_packets: int = field(kw_only=True, default=0)
    tx_flushed_packets: int = field(kw_only=True, default=0)
    tx_last_subevent_packets: int = field(kw_only=True, default=0)
    retransmitted_packets: int = field(kw_only=True, default=0)
    crc_error_packets: int = field(kw_only=True, default=0)
    rx_unreceived_packets: int = field(kw_only=True, default=0)
    duplicate_packets: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_ISO_LINK_QUALITY
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadIsoLinkQualityComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_ISO_LINK_QUALITY:
            raise Exception("Invalid constraint field values")
        if len(span) < 31:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:7], byteorder='little')
        fields['tx_unacked_packets'] = value_
        value_ = int.from_bytes(span[7:11], byteorder='little')
        fields['tx_flushed_packets'] = value_
        value_ = int.from_bytes(span[11:15], byteorder='little')
        fields['tx_last_subevent_packets'] = value_
        value_ = int.from_bytes(span[15:19], byteorder='little')
        fields['retransmitted_packets'] = value_
        value_ = int.from_bytes(span[19:23], byteorder='little')
        fields['crc_error_packets'] = value_
        value_ = int.from_bytes(span[23:27], byteorder='little')
        fields['rx_unreceived_packets'] = value_
        value_ = int.from_bytes(span[27:31], byteorder='little')
        fields['duplicate_packets'] = value_
        span = span[31:]
        return LeReadIsoLinkQualityComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.tx_unacked_packets > 4294967295:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::tx_unacked_packets: {self.tx_unacked_packets} > 4294967295; the value will be truncated")
            self.tx_unacked_packets &= 4294967295
        _span.extend(int.to_bytes((self.tx_unacked_packets << 0), length=4, byteorder='little'))
        if self.tx_flushed_packets > 4294967295:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::tx_flushed_packets: {self.tx_flushed_packets} > 4294967295; the value will be truncated")
            self.tx_flushed_packets &= 4294967295
        _span.extend(int.to_bytes((self.tx_flushed_packets << 0), length=4, byteorder='little'))
        if self.tx_last_subevent_packets > 4294967295:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::tx_last_subevent_packets: {self.tx_last_subevent_packets} > 4294967295; the value will be truncated")
            self.tx_last_subevent_packets &= 4294967295
        _span.extend(int.to_bytes((self.tx_last_subevent_packets << 0), length=4, byteorder='little'))
        if self.retransmitted_packets > 4294967295:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::retransmitted_packets: {self.retransmitted_packets} > 4294967295; the value will be truncated")
            self.retransmitted_packets &= 4294967295
        _span.extend(int.to_bytes((self.retransmitted_packets << 0), length=4, byteorder='little'))
        if self.crc_error_packets > 4294967295:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::crc_error_packets: {self.crc_error_packets} > 4294967295; the value will be truncated")
            self.crc_error_packets &= 4294967295
        _span.extend(int.to_bytes((self.crc_error_packets << 0), length=4, byteorder='little'))
        if self.rx_unreceived_packets > 4294967295:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::rx_unreceived_packets: {self.rx_unreceived_packets} > 4294967295; the value will be truncated")
            self.rx_unreceived_packets &= 4294967295
        _span.extend(int.to_bytes((self.rx_unreceived_packets << 0), length=4, byteorder='little'))
        if self.duplicate_packets > 4294967295:
            print(f"Invalid value for field LeReadIsoLinkQualityComplete::duplicate_packets: {self.duplicate_packets} > 4294967295; the value will be truncated")
            self.duplicate_packets &= 4294967295
        _span.extend(int.to_bytes((self.duplicate_packets << 0), length=4, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 31

@dataclass
class LeEnhancedReadTransmitPowerLevel(Command):
    connection_handle: int = field(kw_only=True, default=0)
    phy: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedReadTransmitPowerLevel', bytes]:
        if fields['op_code'] != OpCode.LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['phy'] = span[2]
        span = span[3:]
        return LeEnhancedReadTransmitPowerLevel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeEnhancedReadTransmitPowerLevel::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.phy > 255:
            print(f"Invalid value for field LeEnhancedReadTransmitPowerLevel::phy: {self.phy} > 255; the value will be truncated")
            self.phy &= 255
        _span.append((self.phy << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

class PhyWithCodedSpecified(enum.IntEnum):
    LE_1M = 0x1
    LE_2M = 0x2
    LE_CODED_S_8 = 0x3
    LE_CODED_S_2 = 0x4

@dataclass
class LeEnhancedReadTransmitPowerLevelComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    phy: PhyWithCodedSpecified = field(kw_only=True, default=PhyWithCodedSpecified.LE_1M)
    current_transmit_power_level: int = field(kw_only=True, default=0)
    max_transmit_power_level: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedReadTransmitPowerLevelComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['phy'] = PhyWithCodedSpecified(span[3])
        fields['current_transmit_power_level'] = span[4]
        fields['max_transmit_power_level'] = span[5]
        span = span[6:]
        return LeEnhancedReadTransmitPowerLevelComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeEnhancedReadTransmitPowerLevelComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.phy << 0))
        if self.current_transmit_power_level > 255:
            print(f"Invalid value for field LeEnhancedReadTransmitPowerLevelComplete::current_transmit_power_level: {self.current_transmit_power_level} > 255; the value will be truncated")
            self.current_transmit_power_level &= 255
        _span.append((self.current_transmit_power_level << 0))
        if self.max_transmit_power_level > 255:
            print(f"Invalid value for field LeEnhancedReadTransmitPowerLevelComplete::max_transmit_power_level: {self.max_transmit_power_level} > 255; the value will be truncated")
            self.max_transmit_power_level &= 255
        _span.append((self.max_transmit_power_level << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LeReadRemoteTransmitPowerLevel(Command):
    connection_handle: int = field(kw_only=True, default=0)
    phy: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_READ_REMOTE_TRANSMIT_POWER_LEVEL

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadRemoteTransmitPowerLevel', bytes]:
        if fields['op_code'] != OpCode.LE_READ_REMOTE_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['phy'] = span[2]
        span = span[3:]
        return LeReadRemoteTransmitPowerLevel(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeReadRemoteTransmitPowerLevel::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.phy > 255:
            print(f"Invalid value for field LeReadRemoteTransmitPowerLevel::phy: {self.phy} > 255; the value will be truncated")
            self.phy &= 255
        _span.append((self.phy << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeReadRemoteTransmitPowerLevelStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_READ_REMOTE_TRANSMIT_POWER_LEVEL
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadRemoteTransmitPowerLevelStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_READ_REMOTE_TRANSMIT_POWER_LEVEL:
            raise Exception("Invalid constraint field values")
        return LeReadRemoteTransmitPowerLevelStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeSetPathLossReportingParameters(Command):
    connection_handle: int = field(kw_only=True, default=0)
    high_threshold: int = field(kw_only=True, default=0)
    high_hysteresis: int = field(kw_only=True, default=0)
    low_threshold: int = field(kw_only=True, default=0)
    low_hysteresis: int = field(kw_only=True, default=0)
    min_time_spent: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PATH_LOSS_REPORTING_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPathLossReportingParameters', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PATH_LOSS_REPORTING_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['high_threshold'] = span[2]
        fields['high_hysteresis'] = span[3]
        fields['low_threshold'] = span[4]
        fields['low_hysteresis'] = span[5]
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['min_time_spent'] = value_
        span = span[8:]
        return LeSetPathLossReportingParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetPathLossReportingParameters::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.high_threshold > 255:
            print(f"Invalid value for field LeSetPathLossReportingParameters::high_threshold: {self.high_threshold} > 255; the value will be truncated")
            self.high_threshold &= 255
        _span.append((self.high_threshold << 0))
        if self.high_hysteresis > 255:
            print(f"Invalid value for field LeSetPathLossReportingParameters::high_hysteresis: {self.high_hysteresis} > 255; the value will be truncated")
            self.high_hysteresis &= 255
        _span.append((self.high_hysteresis << 0))
        if self.low_threshold > 255:
            print(f"Invalid value for field LeSetPathLossReportingParameters::low_threshold: {self.low_threshold} > 255; the value will be truncated")
            self.low_threshold &= 255
        _span.append((self.low_threshold << 0))
        if self.low_hysteresis > 255:
            print(f"Invalid value for field LeSetPathLossReportingParameters::low_hysteresis: {self.low_hysteresis} > 255; the value will be truncated")
            self.low_hysteresis &= 255
        _span.append((self.low_hysteresis << 0))
        if self.min_time_spent > 65535:
            print(f"Invalid value for field LeSetPathLossReportingParameters::min_time_spent: {self.min_time_spent} > 65535; the value will be truncated")
            self.min_time_spent &= 65535
        _span.extend(int.to_bytes((self.min_time_spent << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeSetPathLossReportingParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PATH_LOSS_REPORTING_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPathLossReportingParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PATH_LOSS_REPORTING_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeSetPathLossReportingParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetPathLossReportingParametersComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetPathLossReportingEnable(Command):
    connection_handle: int = field(kw_only=True, default=0)
    enable: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_PATH_LOSS_REPORTING_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPathLossReportingEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_PATH_LOSS_REPORTING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['enable'] = span[2]
        span = span[3:]
        return LeSetPathLossReportingEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetPathLossReportingEnable::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.enable > 255:
            print(f"Invalid value for field LeSetPathLossReportingEnable::enable: {self.enable} > 255; the value will be truncated")
            self.enable &= 255
        _span.append((self.enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetPathLossReportingEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_PATH_LOSS_REPORTING_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetPathLossReportingEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_PATH_LOSS_REPORTING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeSetPathLossReportingEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetPathLossReportingEnableComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetTransmitPowerReportingEnable(Command):
    connection_handle: int = field(kw_only=True, default=0)
    local_enable: int = field(kw_only=True, default=0)
    remote_enable: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_TRANSMIT_POWER_REPORTING_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetTransmitPowerReportingEnable', bytes]:
        if fields['op_code'] != OpCode.LE_SET_TRANSMIT_POWER_REPORTING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['local_enable'] = span[2]
        fields['remote_enable'] = span[3]
        span = span[4:]
        return LeSetTransmitPowerReportingEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetTransmitPowerReportingEnable::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.local_enable > 255:
            print(f"Invalid value for field LeSetTransmitPowerReportingEnable::local_enable: {self.local_enable} > 255; the value will be truncated")
            self.local_enable &= 255
        _span.append((self.local_enable << 0))
        if self.remote_enable > 255:
            print(f"Invalid value for field LeSetTransmitPowerReportingEnable::remote_enable: {self.remote_enable} > 255; the value will be truncated")
            self.remote_enable &= 255
        _span.append((self.remote_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class LeSetTransmitPowerReportingEnableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_TRANSMIT_POWER_REPORTING_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetTransmitPowerReportingEnableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_TRANSMIT_POWER_REPORTING_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeSetTransmitPowerReportingEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSetTransmitPowerReportingEnableComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeSetDataRelatedAddressChanges(Command):
    advertising_handle: int = field(kw_only=True, default=0)
    change_reasons: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_DATA_RELATED_ADDRESS_CHANGES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDataRelatedAddressChanges', bytes]:
        if fields['op_code'] != OpCode.LE_SET_DATA_RELATED_ADDRESS_CHANGES:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['change_reasons'] = span[1]
        span = span[2:]
        return LeSetDataRelatedAddressChanges(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeSetDataRelatedAddressChanges::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.change_reasons > 255:
            print(f"Invalid value for field LeSetDataRelatedAddressChanges::change_reasons: {self.change_reasons} > 255; the value will be truncated")
            self.change_reasons &= 255
        _span.append((self.change_reasons << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeSetDataRelatedAddressChangesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_DATA_RELATED_ADDRESS_CHANGES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDataRelatedAddressChangesComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_DATA_RELATED_ADDRESS_CHANGES:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetDataRelatedAddressChangesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSetDefaultSubrate(Command):
    subrate_min: int = field(kw_only=True, default=0)
    subrate_max: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    continuation_number: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SET_DEFAULT_SUBRATE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDefaultSubrate', bytes]:
        if fields['op_code'] != OpCode.LE_SET_DEFAULT_SUBRATE:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['subrate_min'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['subrate_max'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['max_latency'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['continuation_number'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['supervision_timeout'] = (value_ >> 0) & 0xfff
        span = span[10:]
        return LeSetDefaultSubrate(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.subrate_min > 511:
            print(f"Invalid value for field LeSetDefaultSubrate::subrate_min: {self.subrate_min} > 511; the value will be truncated")
            self.subrate_min &= 511
        _span.extend(int.to_bytes((self.subrate_min << 0), length=2, byteorder='little'))
        if self.subrate_max > 511:
            print(f"Invalid value for field LeSetDefaultSubrate::subrate_max: {self.subrate_max} > 511; the value will be truncated")
            self.subrate_max &= 511
        _span.extend(int.to_bytes((self.subrate_max << 0), length=2, byteorder='little'))
        if self.max_latency > 511:
            print(f"Invalid value for field LeSetDefaultSubrate::max_latency: {self.max_latency} > 511; the value will be truncated")
            self.max_latency &= 511
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.continuation_number > 511:
            print(f"Invalid value for field LeSetDefaultSubrate::continuation_number: {self.continuation_number} > 511; the value will be truncated")
            self.continuation_number &= 511
        _span.extend(int.to_bytes((self.continuation_number << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 4095:
            print(f"Invalid value for field LeSetDefaultSubrate::supervision_timeout: {self.supervision_timeout} > 4095; the value will be truncated")
            self.supervision_timeout &= 4095
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class LeSetDefaultSubrateComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SET_DEFAULT_SUBRATE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSetDefaultSubrateComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_SET_DEFAULT_SUBRATE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeSetDefaultSubrateComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeSubrateRequest(Command):
    connection_handle: int = field(kw_only=True, default=0)
    subrate_min: int = field(kw_only=True, default=0)
    subrate_max: int = field(kw_only=True, default=0)
    max_latency: int = field(kw_only=True, default=0)
    continuation_number: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_SUBRATE_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSubrateRequest', bytes]:
        if fields['op_code'] != OpCode.LE_SUBRATE_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 12:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['subrate_min'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['subrate_max'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['max_latency'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['continuation_number'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['supervision_timeout'] = (value_ >> 0) & 0xfff
        span = span[12:]
        return LeSubrateRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSubrateRequest::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.subrate_min > 511:
            print(f"Invalid value for field LeSubrateRequest::subrate_min: {self.subrate_min} > 511; the value will be truncated")
            self.subrate_min &= 511
        _span.extend(int.to_bytes((self.subrate_min << 0), length=2, byteorder='little'))
        if self.subrate_max > 511:
            print(f"Invalid value for field LeSubrateRequest::subrate_max: {self.subrate_max} > 511; the value will be truncated")
            self.subrate_max &= 511
        _span.extend(int.to_bytes((self.subrate_max << 0), length=2, byteorder='little'))
        if self.max_latency > 511:
            print(f"Invalid value for field LeSubrateRequest::max_latency: {self.max_latency} > 511; the value will be truncated")
            self.max_latency &= 511
        _span.extend(int.to_bytes((self.max_latency << 0), length=2, byteorder='little'))
        if self.continuation_number > 511:
            print(f"Invalid value for field LeSubrateRequest::continuation_number: {self.continuation_number} > 511; the value will be truncated")
            self.continuation_number &= 511
        _span.extend(int.to_bytes((self.continuation_number << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 4095:
            print(f"Invalid value for field LeSubrateRequest::supervision_timeout: {self.supervision_timeout} > 4095; the value will be truncated")
            self.supervision_timeout &= 4095
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 12

@dataclass
class LeSubrateRequestStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_SUBRATE_REQUEST
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSubrateRequestStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_SUBRATE_REQUEST:
            raise Exception("Invalid constraint field values")
        return LeSubrateRequestStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsReadLocalSupportedCapabilities(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadLocalSupportedCapabilities', bytes]:
        if fields['op_code'] != OpCode.LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        return LeCsReadLocalSupportedCapabilities(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class CsRolesSupported(Packet):
    initiator: int = field(kw_only=True, default=0)
    reflector: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsRolesSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['initiator'] = (span[0] >> 0) & 0x1
        fields['reflector'] = (span[0] >> 1) & 0x1
        span = span[1:]
        return CsRolesSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.initiator > 1:
            print(f"Invalid value for field CsRolesSupported::initiator: {self.initiator} > 1; the value will be truncated")
            self.initiator &= 1
        if self.reflector > 1:
            print(f"Invalid value for field CsRolesSupported::reflector: {self.reflector} > 1; the value will be truncated")
            self.reflector &= 1
        _value = (
            (self.initiator << 0) |
            (self.reflector << 1)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

@dataclass
class CsModesSupported(Packet):
    mode_3: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsModesSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['mode_3'] = (span[0] >> 0) & 0x1
        span = span[1:]
        return CsModesSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.mode_3 > 1:
            print(f"Invalid value for field CsModesSupported::mode_3: {self.mode_3} > 1; the value will be truncated")
            self.mode_3 &= 1
        _span.append((self.mode_3 << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

@dataclass
class CsRttCapability(Packet):
    rtt_aa_only_n: int = field(kw_only=True, default=0)
    rtt_sounding_n: int = field(kw_only=True, default=0)
    rtt_random_payload_n: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsRttCapability', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['rtt_aa_only_n'] = (span[0] >> 0) & 0x1
        fields['rtt_sounding_n'] = (span[0] >> 1) & 0x1
        fields['rtt_random_payload_n'] = (span[0] >> 2) & 0x1
        span = span[1:]
        return CsRttCapability(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.rtt_aa_only_n > 1:
            print(f"Invalid value for field CsRttCapability::rtt_aa_only_n: {self.rtt_aa_only_n} > 1; the value will be truncated")
            self.rtt_aa_only_n &= 1
        if self.rtt_sounding_n > 1:
            print(f"Invalid value for field CsRttCapability::rtt_sounding_n: {self.rtt_sounding_n} > 1; the value will be truncated")
            self.rtt_sounding_n &= 1
        if self.rtt_random_payload_n > 1:
            print(f"Invalid value for field CsRttCapability::rtt_random_payload_n: {self.rtt_random_payload_n} > 1; the value will be truncated")
            self.rtt_random_payload_n &= 1
        _value = (
            (self.rtt_aa_only_n << 0) |
            (self.rtt_sounding_n << 1) |
            (self.rtt_random_payload_n << 2)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

@dataclass
class CsNadmSoundingCapability(Packet):
    normalized_attack_detector_metric: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsNadmSoundingCapability', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['normalized_attack_detector_metric'] = (value_ >> 0) & 0x1
        span = span[2:]
        return CsNadmSoundingCapability(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.normalized_attack_detector_metric > 1:
            print(f"Invalid value for field CsNadmSoundingCapability::normalized_attack_detector_metric: {self.normalized_attack_detector_metric} > 1; the value will be truncated")
            self.normalized_attack_detector_metric &= 1
        _span.extend(int.to_bytes((self.normalized_attack_detector_metric << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class CsNadmRandomCapability(Packet):
    normalized_attack_detector_metric: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsNadmRandomCapability', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['normalized_attack_detector_metric'] = (value_ >> 0) & 0x1
        span = span[2:]
        return CsNadmRandomCapability(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.normalized_attack_detector_metric > 1:
            print(f"Invalid value for field CsNadmRandomCapability::normalized_attack_detector_metric: {self.normalized_attack_detector_metric} > 1; the value will be truncated")
            self.normalized_attack_detector_metric &= 1
        _span.extend(int.to_bytes((self.normalized_attack_detector_metric << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class CsSyncPhysSupported(Packet):
    le_2m_phy: int = field(kw_only=True, default=0)
    le_2m_2bt_phy: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsSyncPhysSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['le_2m_phy'] = (span[0] >> 0) & 0x1
        fields['le_2m_2bt_phy'] = (span[0] >> 1) & 0x1
        span = span[1:]
        return CsSyncPhysSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.le_2m_phy > 1:
            print(f"Invalid value for field CsSyncPhysSupported::le_2m_phy: {self.le_2m_phy} > 1; the value will be truncated")
            self.le_2m_phy &= 1
        if self.le_2m_2bt_phy > 1:
            print(f"Invalid value for field CsSyncPhysSupported::le_2m_2bt_phy: {self.le_2m_2bt_phy} > 1; the value will be truncated")
            self.le_2m_2bt_phy &= 1
        _value = (
            (self.le_2m_phy << 0) |
            (self.le_2m_2bt_phy << 1)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

@dataclass
class CsSubfeaturesSupported(Packet):
    companion_signal: int = field(kw_only=True, default=0)
    frequency_actuation_error: int = field(kw_only=True, default=0)
    channel_selection_algorithm: int = field(kw_only=True, default=0)
    phase_based_ranging: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsSubfeaturesSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['companion_signal'] = (value_ >> 0) & 0x1
        fields['frequency_actuation_error'] = (value_ >> 1) & 0x1
        fields['channel_selection_algorithm'] = (value_ >> 2) & 0x1
        fields['phase_based_ranging'] = (value_ >> 3) & 0x1
        span = span[2:]
        return CsSubfeaturesSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.companion_signal > 1:
            print(f"Invalid value for field CsSubfeaturesSupported::companion_signal: {self.companion_signal} > 1; the value will be truncated")
            self.companion_signal &= 1
        if self.frequency_actuation_error > 1:
            print(f"Invalid value for field CsSubfeaturesSupported::frequency_actuation_error: {self.frequency_actuation_error} > 1; the value will be truncated")
            self.frequency_actuation_error &= 1
        if self.channel_selection_algorithm > 1:
            print(f"Invalid value for field CsSubfeaturesSupported::channel_selection_algorithm: {self.channel_selection_algorithm} > 1; the value will be truncated")
            self.channel_selection_algorithm &= 1
        if self.phase_based_ranging > 1:
            print(f"Invalid value for field CsSubfeaturesSupported::phase_based_ranging: {self.phase_based_ranging} > 1; the value will be truncated")
            self.phase_based_ranging &= 1
        _value = (
            (self.companion_signal << 0) |
            (self.frequency_actuation_error << 1) |
            (self.channel_selection_algorithm << 2) |
            (self.phase_based_ranging << 3)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class CsTIp1TimesSupported(Packet):
    support_10_microsecond: int = field(kw_only=True, default=0)
    support_20_microsecond: int = field(kw_only=True, default=0)
    support_30_microsecond: int = field(kw_only=True, default=0)
    support_40_microsecond: int = field(kw_only=True, default=0)
    support_50_microsecond: int = field(kw_only=True, default=0)
    support_60_microsecond: int = field(kw_only=True, default=0)
    support_80_microsecond: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsTIp1TimesSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['support_10_microsecond'] = (value_ >> 0) & 0x1
        fields['support_20_microsecond'] = (value_ >> 1) & 0x1
        fields['support_30_microsecond'] = (value_ >> 2) & 0x1
        fields['support_40_microsecond'] = (value_ >> 3) & 0x1
        fields['support_50_microsecond'] = (value_ >> 4) & 0x1
        fields['support_60_microsecond'] = (value_ >> 5) & 0x1
        fields['support_80_microsecond'] = (value_ >> 6) & 0x1
        span = span[2:]
        return CsTIp1TimesSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.support_10_microsecond > 1:
            print(f"Invalid value for field CsTIp1TimesSupported::support_10_microsecond: {self.support_10_microsecond} > 1; the value will be truncated")
            self.support_10_microsecond &= 1
        if self.support_20_microsecond > 1:
            print(f"Invalid value for field CsTIp1TimesSupported::support_20_microsecond: {self.support_20_microsecond} > 1; the value will be truncated")
            self.support_20_microsecond &= 1
        if self.support_30_microsecond > 1:
            print(f"Invalid value for field CsTIp1TimesSupported::support_30_microsecond: {self.support_30_microsecond} > 1; the value will be truncated")
            self.support_30_microsecond &= 1
        if self.support_40_microsecond > 1:
            print(f"Invalid value for field CsTIp1TimesSupported::support_40_microsecond: {self.support_40_microsecond} > 1; the value will be truncated")
            self.support_40_microsecond &= 1
        if self.support_50_microsecond > 1:
            print(f"Invalid value for field CsTIp1TimesSupported::support_50_microsecond: {self.support_50_microsecond} > 1; the value will be truncated")
            self.support_50_microsecond &= 1
        if self.support_60_microsecond > 1:
            print(f"Invalid value for field CsTIp1TimesSupported::support_60_microsecond: {self.support_60_microsecond} > 1; the value will be truncated")
            self.support_60_microsecond &= 1
        if self.support_80_microsecond > 1:
            print(f"Invalid value for field CsTIp1TimesSupported::support_80_microsecond: {self.support_80_microsecond} > 1; the value will be truncated")
            self.support_80_microsecond &= 1
        _value = (
            (self.support_10_microsecond << 0) |
            (self.support_20_microsecond << 1) |
            (self.support_30_microsecond << 2) |
            (self.support_40_microsecond << 3) |
            (self.support_50_microsecond << 4) |
            (self.support_60_microsecond << 5) |
            (self.support_80_microsecond << 6)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class CsTIp2TimesSupported(Packet):
    support_10_microsecond: int = field(kw_only=True, default=0)
    support_20_microsecond: int = field(kw_only=True, default=0)
    support_30_microsecond: int = field(kw_only=True, default=0)
    support_40_microsecond: int = field(kw_only=True, default=0)
    support_50_microsecond: int = field(kw_only=True, default=0)
    support_60_microsecond: int = field(kw_only=True, default=0)
    support_80_microsecond: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsTIp2TimesSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['support_10_microsecond'] = (value_ >> 0) & 0x1
        fields['support_20_microsecond'] = (value_ >> 1) & 0x1
        fields['support_30_microsecond'] = (value_ >> 2) & 0x1
        fields['support_40_microsecond'] = (value_ >> 3) & 0x1
        fields['support_50_microsecond'] = (value_ >> 4) & 0x1
        fields['support_60_microsecond'] = (value_ >> 5) & 0x1
        fields['support_80_microsecond'] = (value_ >> 6) & 0x1
        span = span[2:]
        return CsTIp2TimesSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.support_10_microsecond > 1:
            print(f"Invalid value for field CsTIp2TimesSupported::support_10_microsecond: {self.support_10_microsecond} > 1; the value will be truncated")
            self.support_10_microsecond &= 1
        if self.support_20_microsecond > 1:
            print(f"Invalid value for field CsTIp2TimesSupported::support_20_microsecond: {self.support_20_microsecond} > 1; the value will be truncated")
            self.support_20_microsecond &= 1
        if self.support_30_microsecond > 1:
            print(f"Invalid value for field CsTIp2TimesSupported::support_30_microsecond: {self.support_30_microsecond} > 1; the value will be truncated")
            self.support_30_microsecond &= 1
        if self.support_40_microsecond > 1:
            print(f"Invalid value for field CsTIp2TimesSupported::support_40_microsecond: {self.support_40_microsecond} > 1; the value will be truncated")
            self.support_40_microsecond &= 1
        if self.support_50_microsecond > 1:
            print(f"Invalid value for field CsTIp2TimesSupported::support_50_microsecond: {self.support_50_microsecond} > 1; the value will be truncated")
            self.support_50_microsecond &= 1
        if self.support_60_microsecond > 1:
            print(f"Invalid value for field CsTIp2TimesSupported::support_60_microsecond: {self.support_60_microsecond} > 1; the value will be truncated")
            self.support_60_microsecond &= 1
        if self.support_80_microsecond > 1:
            print(f"Invalid value for field CsTIp2TimesSupported::support_80_microsecond: {self.support_80_microsecond} > 1; the value will be truncated")
            self.support_80_microsecond &= 1
        _value = (
            (self.support_10_microsecond << 0) |
            (self.support_20_microsecond << 1) |
            (self.support_30_microsecond << 2) |
            (self.support_40_microsecond << 3) |
            (self.support_50_microsecond << 4) |
            (self.support_60_microsecond << 5) |
            (self.support_80_microsecond << 6)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class CsTFcsTimesSupported(Packet):
    support_15_microsecond: int = field(kw_only=True, default=0)
    support_20_microsecond: int = field(kw_only=True, default=0)
    support_30_microsecond: int = field(kw_only=True, default=0)
    support_40_microsecond: int = field(kw_only=True, default=0)
    support_50_microsecond: int = field(kw_only=True, default=0)
    support_60_microsecond: int = field(kw_only=True, default=0)
    support_80_microsecond: int = field(kw_only=True, default=0)
    support_100_microsecond: int = field(kw_only=True, default=0)
    support_120_microsecond: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsTFcsTimesSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['support_15_microsecond'] = (span[0] >> 0) & 0x1
        fields['support_20_microsecond'] = (span[0] >> 1) & 0x1
        fields['support_30_microsecond'] = (span[0] >> 2) & 0x1
        fields['support_40_microsecond'] = (span[0] >> 3) & 0x1
        fields['support_50_microsecond'] = (span[0] >> 4) & 0x1
        fields['support_60_microsecond'] = (span[0] >> 5) & 0x1
        fields['support_80_microsecond'] = (span[0] >> 6) & 0x1
        fields['support_100_microsecond'] = (span[0] >> 7) & 0x1
        fields['support_120_microsecond'] = (span[1] >> 0) & 0x1
        span = span[2:]
        return CsTFcsTimesSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.support_15_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_15_microsecond: {self.support_15_microsecond} > 1; the value will be truncated")
            self.support_15_microsecond &= 1
        if self.support_20_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_20_microsecond: {self.support_20_microsecond} > 1; the value will be truncated")
            self.support_20_microsecond &= 1
        if self.support_30_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_30_microsecond: {self.support_30_microsecond} > 1; the value will be truncated")
            self.support_30_microsecond &= 1
        if self.support_40_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_40_microsecond: {self.support_40_microsecond} > 1; the value will be truncated")
            self.support_40_microsecond &= 1
        if self.support_50_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_50_microsecond: {self.support_50_microsecond} > 1; the value will be truncated")
            self.support_50_microsecond &= 1
        if self.support_60_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_60_microsecond: {self.support_60_microsecond} > 1; the value will be truncated")
            self.support_60_microsecond &= 1
        if self.support_80_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_80_microsecond: {self.support_80_microsecond} > 1; the value will be truncated")
            self.support_80_microsecond &= 1
        if self.support_100_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_100_microsecond: {self.support_100_microsecond} > 1; the value will be truncated")
            self.support_100_microsecond &= 1
        _value = (
            (self.support_15_microsecond << 0) |
            (self.support_20_microsecond << 1) |
            (self.support_30_microsecond << 2) |
            (self.support_40_microsecond << 3) |
            (self.support_50_microsecond << 4) |
            (self.support_60_microsecond << 5) |
            (self.support_80_microsecond << 6) |
            (self.support_100_microsecond << 7)
        )
        _span.append(_value)
        if self.support_120_microsecond > 1:
            print(f"Invalid value for field CsTFcsTimesSupported::support_120_microsecond: {self.support_120_microsecond} > 1; the value will be truncated")
            self.support_120_microsecond &= 1
        _span.append((self.support_120_microsecond << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class CsTPmTimesSupported(Packet):
    support_10_microsecond: int = field(kw_only=True, default=0)
    support_20_microsecond: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsTPmTimesSupported', bytes]:
        fields = {'payload': None}
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['support_10_microsecond'] = (value_ >> 0) & 0x1
        fields['support_20_microsecond'] = (value_ >> 1) & 0x1
        span = span[2:]
        return CsTPmTimesSupported(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.support_10_microsecond > 1:
            print(f"Invalid value for field CsTPmTimesSupported::support_10_microsecond: {self.support_10_microsecond} > 1; the value will be truncated")
            self.support_10_microsecond &= 1
        if self.support_20_microsecond > 1:
            print(f"Invalid value for field CsTPmTimesSupported::support_20_microsecond: {self.support_20_microsecond} > 1; the value will be truncated")
            self.support_20_microsecond &= 1
        _value = (
            (self.support_10_microsecond << 0) |
            (self.support_20_microsecond << 1)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 2

@dataclass
class CsTxSnrCapability(Packet):
    support_18db: int = field(kw_only=True, default=0)
    support_21db: int = field(kw_only=True, default=0)
    support_24db: int = field(kw_only=True, default=0)
    support_27db: int = field(kw_only=True, default=0)
    support_30db: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsTxSnrCapability', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['support_18db'] = (span[0] >> 0) & 0x1
        fields['support_21db'] = (span[0] >> 1) & 0x1
        fields['support_24db'] = (span[0] >> 2) & 0x1
        fields['support_27db'] = (span[0] >> 3) & 0x1
        fields['support_30db'] = (span[0] >> 4) & 0x1
        span = span[1:]
        return CsTxSnrCapability(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.support_18db > 1:
            print(f"Invalid value for field CsTxSnrCapability::support_18db: {self.support_18db} > 1; the value will be truncated")
            self.support_18db &= 1
        if self.support_21db > 1:
            print(f"Invalid value for field CsTxSnrCapability::support_21db: {self.support_21db} > 1; the value will be truncated")
            self.support_21db &= 1
        if self.support_24db > 1:
            print(f"Invalid value for field CsTxSnrCapability::support_24db: {self.support_24db} > 1; the value will be truncated")
            self.support_24db &= 1
        if self.support_27db > 1:
            print(f"Invalid value for field CsTxSnrCapability::support_27db: {self.support_27db} > 1; the value will be truncated")
            self.support_27db &= 1
        if self.support_30db > 1:
            print(f"Invalid value for field CsTxSnrCapability::support_30db: {self.support_30db} > 1; the value will be truncated")
            self.support_30db &= 1
        _value = (
            (self.support_18db << 0) |
            (self.support_21db << 1) |
            (self.support_24db << 2) |
            (self.support_27db << 3) |
            (self.support_30db << 4)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeCsReadLocalSupportedCapabilitiesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    num_config_supported: int = field(kw_only=True, default=0)
    max_consecutive_procedures_supported: int = field(kw_only=True, default=0)
    num_antennas_supported: int = field(kw_only=True, default=0)
    max_antenna_paths_supported: int = field(kw_only=True, default=0)
    roles_supported: CsRolesSupported = field(kw_only=True, default_factory=CsRolesSupported)
    modes_supported: CsModesSupported = field(kw_only=True, default_factory=CsModesSupported)
    rtt_capability: CsRttCapability = field(kw_only=True, default_factory=CsRttCapability)
    rtt_aa_only_n: int = field(kw_only=True, default=0)
    rtt_sounding_n: int = field(kw_only=True, default=0)
    rtt_random_payload_n: int = field(kw_only=True, default=0)
    nadm_sounding_capability: CsNadmSoundingCapability = field(kw_only=True, default_factory=CsNadmSoundingCapability)
    nadm_random_capability: CsNadmRandomCapability = field(kw_only=True, default_factory=CsNadmRandomCapability)
    cs_sync_phys_supported: CsSyncPhysSupported = field(kw_only=True, default_factory=CsSyncPhysSupported)
    subfeatures_supported: CsSubfeaturesSupported = field(kw_only=True, default_factory=CsSubfeaturesSupported)
    t_ip1_times_supported: CsTIp1TimesSupported = field(kw_only=True, default_factory=CsTIp1TimesSupported)
    t_ip2_times_supported: CsTIp2TimesSupported = field(kw_only=True, default_factory=CsTIp2TimesSupported)
    t_fcs_times_supported: CsTFcsTimesSupported = field(kw_only=True, default_factory=CsTFcsTimesSupported)
    t_pm_times_supported: CsTPmTimesSupported = field(kw_only=True, default_factory=CsTPmTimesSupported)
    t_sw_time_supported: int = field(kw_only=True, default=0)
    tx_snr_capability: CsTxSnrCapability = field(kw_only=True, default_factory=CsTxSnrCapability)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadLocalSupportedCapabilitiesComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_READ_LOCAL_SUPPORTED_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        if len(span) < 29:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['num_config_supported'] = span[1]
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['max_consecutive_procedures_supported'] = value_
        fields['num_antennas_supported'] = span[4]
        fields['max_antenna_paths_supported'] = span[5]
        fields['roles_supported'] = CsRolesSupported.parse_all(span[6:7])
        fields['modes_supported'] = CsModesSupported.parse_all(span[7:8])
        fields['rtt_capability'] = CsRttCapability.parse_all(span[8:9])
        fields['rtt_aa_only_n'] = span[9]
        fields['rtt_sounding_n'] = span[10]
        fields['rtt_random_payload_n'] = span[11]
        fields['nadm_sounding_capability'] = CsNadmSoundingCapability.parse_all(span[12:14])
        fields['nadm_random_capability'] = CsNadmRandomCapability.parse_all(span[14:16])
        fields['cs_sync_phys_supported'] = CsSyncPhysSupported.parse_all(span[16:17])
        fields['subfeatures_supported'] = CsSubfeaturesSupported.parse_all(span[17:19])
        fields['t_ip1_times_supported'] = CsTIp1TimesSupported.parse_all(span[19:21])
        fields['t_ip2_times_supported'] = CsTIp2TimesSupported.parse_all(span[21:23])
        fields['t_fcs_times_supported'] = CsTFcsTimesSupported.parse_all(span[23:25])
        fields['t_pm_times_supported'] = CsTPmTimesSupported.parse_all(span[25:27])
        fields['t_sw_time_supported'] = span[27]
        fields['tx_snr_capability'] = CsTxSnrCapability.parse_all(span[28:29])
        span = span[29:]
        return LeCsReadLocalSupportedCapabilitiesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.num_config_supported > 255:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::num_config_supported: {self.num_config_supported} > 255; the value will be truncated")
            self.num_config_supported &= 255
        _span.append((self.num_config_supported << 0))
        if self.max_consecutive_procedures_supported > 65535:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::max_consecutive_procedures_supported: {self.max_consecutive_procedures_supported} > 65535; the value will be truncated")
            self.max_consecutive_procedures_supported &= 65535
        _span.extend(int.to_bytes((self.max_consecutive_procedures_supported << 0), length=2, byteorder='little'))
        if self.num_antennas_supported > 255:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::num_antennas_supported: {self.num_antennas_supported} > 255; the value will be truncated")
            self.num_antennas_supported &= 255
        _span.append((self.num_antennas_supported << 0))
        if self.max_antenna_paths_supported > 255:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::max_antenna_paths_supported: {self.max_antenna_paths_supported} > 255; the value will be truncated")
            self.max_antenna_paths_supported &= 255
        _span.append((self.max_antenna_paths_supported << 0))
        _span.extend(self.roles_supported.serialize())
        _span.extend(self.modes_supported.serialize())
        _span.extend(self.rtt_capability.serialize())
        if self.rtt_aa_only_n > 255:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::rtt_aa_only_n: {self.rtt_aa_only_n} > 255; the value will be truncated")
            self.rtt_aa_only_n &= 255
        _span.append((self.rtt_aa_only_n << 0))
        if self.rtt_sounding_n > 255:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::rtt_sounding_n: {self.rtt_sounding_n} > 255; the value will be truncated")
            self.rtt_sounding_n &= 255
        _span.append((self.rtt_sounding_n << 0))
        if self.rtt_random_payload_n > 255:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::rtt_random_payload_n: {self.rtt_random_payload_n} > 255; the value will be truncated")
            self.rtt_random_payload_n &= 255
        _span.append((self.rtt_random_payload_n << 0))
        _span.extend(self.nadm_sounding_capability.serialize())
        _span.extend(self.nadm_random_capability.serialize())
        _span.extend(self.cs_sync_phys_supported.serialize())
        _span.extend(self.subfeatures_supported.serialize())
        _span.extend(self.t_ip1_times_supported.serialize())
        _span.extend(self.t_ip2_times_supported.serialize())
        _span.extend(self.t_fcs_times_supported.serialize())
        _span.extend(self.t_pm_times_supported.serialize())
        if self.t_sw_time_supported > 255:
            print(f"Invalid value for field LeCsReadLocalSupportedCapabilitiesComplete::t_sw_time_supported: {self.t_sw_time_supported} > 255; the value will be truncated")
            self.t_sw_time_supported &= 255
        _span.append((self.t_sw_time_supported << 0))
        _span.extend(self.tx_snr_capability.serialize())
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 29

@dataclass
class LeCsReadRemoteSupportedCapabilities(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadRemoteSupportedCapabilities', bytes]:
        if fields['op_code'] != OpCode.LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeCsReadRemoteSupportedCapabilities(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilities::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeCsReadRemoteSupportedCapabilitiesStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadRemoteSupportedCapabilitiesStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        return LeCsReadRemoteSupportedCapabilitiesStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsReadRemoteSupportedCapabilitiesComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    num_config_supported: int = field(kw_only=True, default=0)
    max_consecutive_procedures_supported: int = field(kw_only=True, default=0)
    num_antennas_supported: int = field(kw_only=True, default=0)
    max_antenna_paths_supported: int = field(kw_only=True, default=0)
    roles_supported: CsRolesSupported = field(kw_only=True, default_factory=CsRolesSupported)
    modes_supported: CsModesSupported = field(kw_only=True, default_factory=CsModesSupported)
    rtt_capability: CsRttCapability = field(kw_only=True, default_factory=CsRttCapability)
    rtt_aa_only_n: int = field(kw_only=True, default=0)
    rtt_sounding_n: int = field(kw_only=True, default=0)
    rtt_random_payload_n: int = field(kw_only=True, default=0)
    nadm_sounding_capability: CsNadmSoundingCapability = field(kw_only=True, default_factory=CsNadmSoundingCapability)
    nadm_random_capability: CsNadmRandomCapability = field(kw_only=True, default_factory=CsNadmRandomCapability)
    cs_sync_phys_supported: CsSyncPhysSupported = field(kw_only=True, default_factory=CsSyncPhysSupported)
    subfeatures_supported: CsSubfeaturesSupported = field(kw_only=True, default_factory=CsSubfeaturesSupported)
    t_ip1_times_supported: CsTIp1TimesSupported = field(kw_only=True, default_factory=CsTIp1TimesSupported)
    t_ip2_times_supported: CsTIp2TimesSupported = field(kw_only=True, default_factory=CsTIp2TimesSupported)
    t_fcs_times_supported: CsTFcsTimesSupported = field(kw_only=True, default_factory=CsTFcsTimesSupported)
    t_pm_times_supported: CsTPmTimesSupported = field(kw_only=True, default_factory=CsTPmTimesSupported)
    t_sw_time_supported: int = field(kw_only=True, default=0)
    tx_snr_capability: CsTxSnrCapability = field(kw_only=True, default_factory=CsTxSnrCapability)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadRemoteSupportedCapabilitiesComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CS_READ_REMOTE_SUPPORTED_CAPABILITIES_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 31:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['num_config_supported'] = span[3]
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['max_consecutive_procedures_supported'] = value_
        fields['num_antennas_supported'] = span[6]
        fields['max_antenna_paths_supported'] = span[7]
        fields['roles_supported'] = CsRolesSupported.parse_all(span[8:9])
        fields['modes_supported'] = CsModesSupported.parse_all(span[9:10])
        fields['rtt_capability'] = CsRttCapability.parse_all(span[10:11])
        fields['rtt_aa_only_n'] = span[11]
        fields['rtt_sounding_n'] = span[12]
        fields['rtt_random_payload_n'] = span[13]
        fields['nadm_sounding_capability'] = CsNadmSoundingCapability.parse_all(span[14:16])
        fields['nadm_random_capability'] = CsNadmRandomCapability.parse_all(span[16:18])
        fields['cs_sync_phys_supported'] = CsSyncPhysSupported.parse_all(span[18:19])
        fields['subfeatures_supported'] = CsSubfeaturesSupported.parse_all(span[19:21])
        fields['t_ip1_times_supported'] = CsTIp1TimesSupported.parse_all(span[21:23])
        fields['t_ip2_times_supported'] = CsTIp2TimesSupported.parse_all(span[23:25])
        fields['t_fcs_times_supported'] = CsTFcsTimesSupported.parse_all(span[25:27])
        fields['t_pm_times_supported'] = CsTPmTimesSupported.parse_all(span[27:29])
        fields['t_sw_time_supported'] = span[29]
        fields['tx_snr_capability'] = CsTxSnrCapability.parse_all(span[30:31])
        span = span[31:]
        return LeCsReadRemoteSupportedCapabilitiesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.num_config_supported > 255:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::num_config_supported: {self.num_config_supported} > 255; the value will be truncated")
            self.num_config_supported &= 255
        _span.append((self.num_config_supported << 0))
        if self.max_consecutive_procedures_supported > 65535:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::max_consecutive_procedures_supported: {self.max_consecutive_procedures_supported} > 65535; the value will be truncated")
            self.max_consecutive_procedures_supported &= 65535
        _span.extend(int.to_bytes((self.max_consecutive_procedures_supported << 0), length=2, byteorder='little'))
        if self.num_antennas_supported > 255:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::num_antennas_supported: {self.num_antennas_supported} > 255; the value will be truncated")
            self.num_antennas_supported &= 255
        _span.append((self.num_antennas_supported << 0))
        if self.max_antenna_paths_supported > 255:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::max_antenna_paths_supported: {self.max_antenna_paths_supported} > 255; the value will be truncated")
            self.max_antenna_paths_supported &= 255
        _span.append((self.max_antenna_paths_supported << 0))
        _span.extend(self.roles_supported.serialize())
        _span.extend(self.modes_supported.serialize())
        _span.extend(self.rtt_capability.serialize())
        if self.rtt_aa_only_n > 255:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::rtt_aa_only_n: {self.rtt_aa_only_n} > 255; the value will be truncated")
            self.rtt_aa_only_n &= 255
        _span.append((self.rtt_aa_only_n << 0))
        if self.rtt_sounding_n > 255:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::rtt_sounding_n: {self.rtt_sounding_n} > 255; the value will be truncated")
            self.rtt_sounding_n &= 255
        _span.append((self.rtt_sounding_n << 0))
        if self.rtt_random_payload_n > 255:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::rtt_random_payload_n: {self.rtt_random_payload_n} > 255; the value will be truncated")
            self.rtt_random_payload_n &= 255
        _span.append((self.rtt_random_payload_n << 0))
        _span.extend(self.nadm_sounding_capability.serialize())
        _span.extend(self.nadm_random_capability.serialize())
        _span.extend(self.cs_sync_phys_supported.serialize())
        _span.extend(self.subfeatures_supported.serialize())
        _span.extend(self.t_ip1_times_supported.serialize())
        _span.extend(self.t_ip2_times_supported.serialize())
        _span.extend(self.t_fcs_times_supported.serialize())
        _span.extend(self.t_pm_times_supported.serialize())
        if self.t_sw_time_supported > 255:
            print(f"Invalid value for field LeCsReadRemoteSupportedCapabilitiesComplete::t_sw_time_supported: {self.t_sw_time_supported} > 255; the value will be truncated")
            self.t_sw_time_supported &= 255
        _span.append((self.t_sw_time_supported << 0))
        _span.extend(self.tx_snr_capability.serialize())
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 31

@dataclass
class LeCsWriteCachedRemoteSupportedCapabilities(Command):
    connection_handle: int = field(kw_only=True, default=0)
    num_config_supported: int = field(kw_only=True, default=0)
    max_consecutive_procedures_supported: int = field(kw_only=True, default=0)
    num_antennas_supported: int = field(kw_only=True, default=0)
    max_antenna_paths_supported: int = field(kw_only=True, default=0)
    roles_supported: CsRolesSupported = field(kw_only=True, default_factory=CsRolesSupported)
    modes_supported: CsModesSupported = field(kw_only=True, default_factory=CsModesSupported)
    rtt_capability: CsRttCapability = field(kw_only=True, default_factory=CsRttCapability)
    rtt_aa_only_n: int = field(kw_only=True, default=0)
    rtt_sounding_n: int = field(kw_only=True, default=0)
    rtt_random_payload_n: int = field(kw_only=True, default=0)
    nadm_sounding_capability: CsNadmSoundingCapability = field(kw_only=True, default_factory=CsNadmSoundingCapability)
    nadm_random_capability: CsNadmRandomCapability = field(kw_only=True, default_factory=CsNadmRandomCapability)
    cs_sync_phys_supported: CsSyncPhysSupported = field(kw_only=True, default_factory=CsSyncPhysSupported)
    subfeatures_supported: CsSubfeaturesSupported = field(kw_only=True, default_factory=CsSubfeaturesSupported)
    t_ip1_times_supported: CsTIp1TimesSupported = field(kw_only=True, default_factory=CsTIp1TimesSupported)
    t_ip2_times_supported: CsTIp2TimesSupported = field(kw_only=True, default_factory=CsTIp2TimesSupported)
    t_fcs_times_supported: CsTFcsTimesSupported = field(kw_only=True, default_factory=CsTFcsTimesSupported)
    t_pm_times_supported: CsTPmTimesSupported = field(kw_only=True, default_factory=CsTPmTimesSupported)
    t_sw_time_supported: int = field(kw_only=True, default=0)
    tx_snr_capability: CsTxSnrCapability = field(kw_only=True, default_factory=CsTxSnrCapability)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsWriteCachedRemoteSupportedCapabilities', bytes]:
        if fields['op_code'] != OpCode.LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        if len(span) < 30:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['num_config_supported'] = span[2]
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['max_consecutive_procedures_supported'] = value_
        fields['num_antennas_supported'] = span[5]
        fields['max_antenna_paths_supported'] = span[6]
        fields['roles_supported'] = CsRolesSupported.parse_all(span[7:8])
        fields['modes_supported'] = CsModesSupported.parse_all(span[8:9])
        fields['rtt_capability'] = CsRttCapability.parse_all(span[9:10])
        fields['rtt_aa_only_n'] = span[10]
        fields['rtt_sounding_n'] = span[11]
        fields['rtt_random_payload_n'] = span[12]
        fields['nadm_sounding_capability'] = CsNadmSoundingCapability.parse_all(span[13:15])
        fields['nadm_random_capability'] = CsNadmRandomCapability.parse_all(span[15:17])
        fields['cs_sync_phys_supported'] = CsSyncPhysSupported.parse_all(span[17:18])
        fields['subfeatures_supported'] = CsSubfeaturesSupported.parse_all(span[18:20])
        fields['t_ip1_times_supported'] = CsTIp1TimesSupported.parse_all(span[20:22])
        fields['t_ip2_times_supported'] = CsTIp2TimesSupported.parse_all(span[22:24])
        fields['t_fcs_times_supported'] = CsTFcsTimesSupported.parse_all(span[24:26])
        fields['t_pm_times_supported'] = CsTPmTimesSupported.parse_all(span[26:28])
        fields['t_sw_time_supported'] = span[28]
        fields['tx_snr_capability'] = CsTxSnrCapability.parse_all(span[29:30])
        span = span[30:]
        return LeCsWriteCachedRemoteSupportedCapabilities(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.num_config_supported > 255:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::num_config_supported: {self.num_config_supported} > 255; the value will be truncated")
            self.num_config_supported &= 255
        _span.append((self.num_config_supported << 0))
        if self.max_consecutive_procedures_supported > 65535:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::max_consecutive_procedures_supported: {self.max_consecutive_procedures_supported} > 65535; the value will be truncated")
            self.max_consecutive_procedures_supported &= 65535
        _span.extend(int.to_bytes((self.max_consecutive_procedures_supported << 0), length=2, byteorder='little'))
        if self.num_antennas_supported > 255:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::num_antennas_supported: {self.num_antennas_supported} > 255; the value will be truncated")
            self.num_antennas_supported &= 255
        _span.append((self.num_antennas_supported << 0))
        if self.max_antenna_paths_supported > 255:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::max_antenna_paths_supported: {self.max_antenna_paths_supported} > 255; the value will be truncated")
            self.max_antenna_paths_supported &= 255
        _span.append((self.max_antenna_paths_supported << 0))
        _span.extend(self.roles_supported.serialize())
        _span.extend(self.modes_supported.serialize())
        _span.extend(self.rtt_capability.serialize())
        if self.rtt_aa_only_n > 255:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::rtt_aa_only_n: {self.rtt_aa_only_n} > 255; the value will be truncated")
            self.rtt_aa_only_n &= 255
        _span.append((self.rtt_aa_only_n << 0))
        if self.rtt_sounding_n > 255:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::rtt_sounding_n: {self.rtt_sounding_n} > 255; the value will be truncated")
            self.rtt_sounding_n &= 255
        _span.append((self.rtt_sounding_n << 0))
        if self.rtt_random_payload_n > 255:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::rtt_random_payload_n: {self.rtt_random_payload_n} > 255; the value will be truncated")
            self.rtt_random_payload_n &= 255
        _span.append((self.rtt_random_payload_n << 0))
        _span.extend(self.nadm_sounding_capability.serialize())
        _span.extend(self.nadm_random_capability.serialize())
        _span.extend(self.cs_sync_phys_supported.serialize())
        _span.extend(self.subfeatures_supported.serialize())
        _span.extend(self.t_ip1_times_supported.serialize())
        _span.extend(self.t_ip2_times_supported.serialize())
        _span.extend(self.t_fcs_times_supported.serialize())
        _span.extend(self.t_pm_times_supported.serialize())
        if self.t_sw_time_supported > 255:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilities::t_sw_time_supported: {self.t_sw_time_supported} > 255; the value will be truncated")
            self.t_sw_time_supported &= 255
        _span.append((self.t_sw_time_supported << 0))
        _span.extend(self.tx_snr_capability.serialize())
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 30

@dataclass
class LeCsWriteCachedRemoteSupportedCapabilitiesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsWriteCachedRemoteSupportedCapabilitiesComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_WRITE_CACHED_REMOTE_SUPPORTED_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeCsWriteCachedRemoteSupportedCapabilitiesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsWriteCachedRemoteSupportedCapabilitiesComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeCsSecurityEnable(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_SECURITY_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSecurityEnable', bytes]:
        if fields['op_code'] != OpCode.LE_CS_SECURITY_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeCsSecurityEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsSecurityEnable::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeCsSecurityEnableStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_SECURITY_ENABLE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSecurityEnableStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_SECURITY_ENABLE:
            raise Exception("Invalid constraint field values")
        return LeCsSecurityEnableStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsSecurityEnableComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CS_SECURITY_ENABLE_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSecurityEnableComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CS_SECURITY_ENABLE_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeCsSecurityEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsSecurityEnableComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class CsRoleEnable(Packet):
    initiator: int = field(kw_only=True, default=0)
    reflector: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsRoleEnable', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['initiator'] = (span[0] >> 0) & 0x1
        fields['reflector'] = (span[0] >> 1) & 0x1
        span = span[1:]
        return CsRoleEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.initiator > 1:
            print(f"Invalid value for field CsRoleEnable::initiator: {self.initiator} > 1; the value will be truncated")
            self.initiator &= 1
        if self.reflector > 1:
            print(f"Invalid value for field CsRoleEnable::reflector: {self.reflector} > 1; the value will be truncated")
            self.reflector &= 1
        _value = (
            (self.initiator << 0) |
            (self.reflector << 1)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

class CsSyncAntennaSelection(enum.IntEnum):
    ANTENNA_1 = 0x1
    ANTENNA_2 = 0x2
    ANTENNA_3 = 0x3
    ANTENNA_4 = 0x4
    ANTENNAS_IN_ORDER = 0xfe
    NO_RECOMMENDATION = 0xff

@dataclass
class LeCsSetDefaultSettings(Command):
    connection_handle: int = field(kw_only=True, default=0)
    role_enable: CsRoleEnable = field(kw_only=True, default_factory=CsRoleEnable)
    cs_sync_antenna_selection: CsSyncAntennaSelection = field(kw_only=True, default=CsSyncAntennaSelection.ANTENNA_1)
    max_tx_power: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_SET_DEFAULT_SETTINGS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSetDefaultSettings', bytes]:
        if fields['op_code'] != OpCode.LE_CS_SET_DEFAULT_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['role_enable'] = CsRoleEnable.parse_all(span[2:3])
        fields['cs_sync_antenna_selection'] = CsSyncAntennaSelection(span[3])
        fields['max_tx_power'] = span[4]
        span = span[5:]
        return LeCsSetDefaultSettings(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsSetDefaultSettings::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.role_enable.serialize())
        _span.append((self.cs_sync_antenna_selection << 0))
        if self.max_tx_power > 255:
            print(f"Invalid value for field LeCsSetDefaultSettings::max_tx_power: {self.max_tx_power} > 255; the value will be truncated")
            self.max_tx_power &= 255
        _span.append((self.max_tx_power << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class LeCsSetDefaultSettingsComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_SET_DEFAULT_SETTINGS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSetDefaultSettingsComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_SET_DEFAULT_SETTINGS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeCsSetDefaultSettingsComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsSetDefaultSettingsComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeCsReadRemoteFaeTable(Command):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_READ_REMOTE_FAE_TABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadRemoteFaeTable', bytes]:
        if fields['op_code'] != OpCode.LE_CS_READ_REMOTE_FAE_TABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LeCsReadRemoteFaeTable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsReadRemoteFaeTable::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeCsReadRemoteFaeTableStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_READ_REMOTE_FAE_TABLE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadRemoteFaeTableStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_READ_REMOTE_FAE_TABLE:
            raise Exception("Invalid constraint field values")
        return LeCsReadRemoteFaeTableStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsReadRemoteFaeTableComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    remote_fae_table: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CS_READ_REMOTE_FAE_TABLE_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsReadRemoteFaeTableComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CS_READ_REMOTE_FAE_TABLE_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        if len(span) < 72:
            raise Exception('Invalid packet size')
        fields['remote_fae_table'] = list(span[:72])
        span = span[72:]
        return LeCsReadRemoteFaeTableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsReadRemoteFaeTableComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.remote_fae_table)
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 75

@dataclass
class LeCsWriteCachedRemoteFaeTable(Command):
    connection_handle: int = field(kw_only=True, default=0)
    remote_fae_table: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsWriteCachedRemoteFaeTable', bytes]:
        if fields['op_code'] != OpCode.LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        if len(span) < 72:
            raise Exception('Invalid packet size')
        fields['remote_fae_table'] = list(span[:72])
        span = span[72:]
        return LeCsWriteCachedRemoteFaeTable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsWriteCachedRemoteFaeTable::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.remote_fae_table)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 74

@dataclass
class LeCsWriteCachedRemoteFaeTableComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsWriteCachedRemoteFaeTableComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_WRITE_CACHED_REMOTE_FAE_TABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeCsWriteCachedRemoteFaeTableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsWriteCachedRemoteFaeTableComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

class CsCreateContext(enum.IntEnum):
    LOCAL_CONTROLLER_ONLY = 0x0
    BOTH_LOCAL_AND_REMOTE_CONTROLLER = 0x1

class CsMainModeType(enum.IntEnum):
    MODE_1 = 0x1
    MODE_2 = 0x2
    MODE_3 = 0x3

class CsSubModeType(enum.IntEnum):
    MODE_1 = 0x1
    MODE_2 = 0x2
    MODE_3 = 0x3
    UNUSED = 0xff

class CsRole(enum.IntEnum):
    INITIATOR = 0x0
    REFLECTOR = 0x1

class CsRttType(enum.IntEnum):
    RTT_AA_ONLY = 0x0
    RTT_WITH_32_BIT_SOUNDING_SEQUENCE = 0x1
    RTT_WITH_96_BIT_SOUNDING_SEQUENCE = 0x2
    RTT_WITH_32_BIT_RANDOM_SEQUENCE = 0x3
    RTT_WITH_64_BIT_RANDOM_SEQUENCE = 0x4
    RTT_WITH_96_BIT_RANDOM_SEQUENCE = 0x5
    RTT_WITH_128_BIT_RANDOM_SEQUENCE = 0x6

class CsSyncPhy(enum.IntEnum):
    LE_1M_PHY = 0x1
    LE_2M_PHY = 0x2
    LE_2M_2BT_PHY = 0x3

class CsChannelSelectionType(enum.IntEnum):
    TYPE_3B = 0x0
    TYPE_3C = 0x1

class CsCh3cShape(enum.IntEnum):
    HAT_SHAPE = 0x0
    X_SHAPE = 0x1

class CsAction(enum.IntEnum):
    CONFIG_REMOVED = 0x0
    CONFIG_CREATED = 0x1

@dataclass
class LeCsConfigComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    config_id: int = field(kw_only=True, default=0)
    action: CsAction = field(kw_only=True, default=CsAction.CONFIG_REMOVED)
    main_mode_type: CsMainModeType = field(kw_only=True, default=CsMainModeType.MODE_1)
    sub_mode_type: CsSubModeType = field(kw_only=True, default=CsSubModeType.MODE_1)
    min_main_mode_steps: int = field(kw_only=True, default=0)
    max_main_mode_steps: int = field(kw_only=True, default=0)
    main_mode_repetition: int = field(kw_only=True, default=0)
    mode_0_steps: int = field(kw_only=True, default=0)
    role: CsRole = field(kw_only=True, default=CsRole.INITIATOR)
    rtt_type: CsRttType = field(kw_only=True, default=CsRttType.RTT_AA_ONLY)
    cs_sync_phy: CsSyncPhy = field(kw_only=True, default=CsSyncPhy.LE_1M_PHY)
    channel_map: bytearray = field(kw_only=True, default_factory=bytearray)
    channel_map_repetition: int = field(kw_only=True, default=0)
    channel_selection_type: CsChannelSelectionType = field(kw_only=True, default=CsChannelSelectionType.TYPE_3B)
    ch3c_shape: CsCh3cShape = field(kw_only=True, default=CsCh3cShape.HAT_SHAPE)
    ch3c_jump: int = field(kw_only=True, default=0)
    t_ip1_time: int = field(kw_only=True, default=0)
    t_ip2_time: int = field(kw_only=True, default=0)
    t_fcs_time: int = field(kw_only=True, default=0)
    t_pm_time: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CS_CONFIG_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsConfigComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CS_CONFIG_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 14:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['config_id'] = span[3]
        fields['action'] = CsAction(span[4])
        fields['main_mode_type'] = CsMainModeType(span[5])
        fields['sub_mode_type'] = CsSubModeType(span[6])
        fields['min_main_mode_steps'] = span[7]
        fields['max_main_mode_steps'] = span[8]
        fields['main_mode_repetition'] = span[9]
        fields['mode_0_steps'] = span[10]
        fields['role'] = CsRole(span[11])
        fields['rtt_type'] = CsRttType(span[12])
        fields['cs_sync_phy'] = CsSyncPhy(span[13])
        span = span[14:]
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['channel_map'] = list(span[:10])
        span = span[10:]
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['channel_map_repetition'] = span[0]
        fields['channel_selection_type'] = CsChannelSelectionType(span[1])
        fields['ch3c_shape'] = CsCh3cShape(span[2])
        fields['ch3c_jump'] = span[3]
        fields['t_ip1_time'] = span[5]
        fields['t_ip2_time'] = span[6]
        fields['t_fcs_time'] = span[7]
        fields['t_pm_time'] = span[8]
        span = span[9:]
        return LeCsConfigComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsConfigComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.config_id > 255:
            print(f"Invalid value for field LeCsConfigComplete::config_id: {self.config_id} > 255; the value will be truncated")
            self.config_id &= 255
        _span.append((self.config_id << 0))
        _span.append((self.action << 0))
        _span.append((self.main_mode_type << 0))
        _span.append((self.sub_mode_type << 0))
        if self.min_main_mode_steps > 255:
            print(f"Invalid value for field LeCsConfigComplete::min_main_mode_steps: {self.min_main_mode_steps} > 255; the value will be truncated")
            self.min_main_mode_steps &= 255
        _span.append((self.min_main_mode_steps << 0))
        if self.max_main_mode_steps > 255:
            print(f"Invalid value for field LeCsConfigComplete::max_main_mode_steps: {self.max_main_mode_steps} > 255; the value will be truncated")
            self.max_main_mode_steps &= 255
        _span.append((self.max_main_mode_steps << 0))
        if self.main_mode_repetition > 255:
            print(f"Invalid value for field LeCsConfigComplete::main_mode_repetition: {self.main_mode_repetition} > 255; the value will be truncated")
            self.main_mode_repetition &= 255
        _span.append((self.main_mode_repetition << 0))
        if self.mode_0_steps > 255:
            print(f"Invalid value for field LeCsConfigComplete::mode_0_steps: {self.mode_0_steps} > 255; the value will be truncated")
            self.mode_0_steps &= 255
        _span.append((self.mode_0_steps << 0))
        _span.append((self.role << 0))
        _span.append((self.rtt_type << 0))
        _span.append((self.cs_sync_phy << 0))
        _span.extend(self.channel_map)
        if self.channel_map_repetition > 255:
            print(f"Invalid value for field LeCsConfigComplete::channel_map_repetition: {self.channel_map_repetition} > 255; the value will be truncated")
            self.channel_map_repetition &= 255
        _span.append((self.channel_map_repetition << 0))
        _span.append((self.channel_selection_type << 0))
        _span.append((self.ch3c_shape << 0))
        if self.ch3c_jump > 255:
            print(f"Invalid value for field LeCsConfigComplete::ch3c_jump: {self.ch3c_jump} > 255; the value will be truncated")
            self.ch3c_jump &= 255
        _span.append((self.ch3c_jump << 0))
        _span.extend([0] * 1)
        if self.t_ip1_time > 255:
            print(f"Invalid value for field LeCsConfigComplete::t_ip1_time: {self.t_ip1_time} > 255; the value will be truncated")
            self.t_ip1_time &= 255
        _span.append((self.t_ip1_time << 0))
        if self.t_ip2_time > 255:
            print(f"Invalid value for field LeCsConfigComplete::t_ip2_time: {self.t_ip2_time} > 255; the value will be truncated")
            self.t_ip2_time &= 255
        _span.append((self.t_ip2_time << 0))
        if self.t_fcs_time > 255:
            print(f"Invalid value for field LeCsConfigComplete::t_fcs_time: {self.t_fcs_time} > 255; the value will be truncated")
            self.t_fcs_time &= 255
        _span.append((self.t_fcs_time << 0))
        if self.t_pm_time > 255:
            print(f"Invalid value for field LeCsConfigComplete::t_pm_time: {self.t_pm_time} > 255; the value will be truncated")
            self.t_pm_time &= 255
        _span.append((self.t_pm_time << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 33

@dataclass
class LeCsCreateConfig(Command):
    connection_handle: int = field(kw_only=True, default=0)
    config_id: int = field(kw_only=True, default=0)
    create_context: CsCreateContext = field(kw_only=True, default=CsCreateContext.LOCAL_CONTROLLER_ONLY)
    main_mode_type: CsMainModeType = field(kw_only=True, default=CsMainModeType.MODE_1)
    sub_mode_type: CsSubModeType = field(kw_only=True, default=CsSubModeType.MODE_1)
    min_main_mode_steps: int = field(kw_only=True, default=0)
    max_main_mode_steps: int = field(kw_only=True, default=0)
    main_mode_repetition: int = field(kw_only=True, default=0)
    mode_0_steps: int = field(kw_only=True, default=0)
    role: CsRole = field(kw_only=True, default=CsRole.INITIATOR)
    rtt_type: CsRttType = field(kw_only=True, default=CsRttType.RTT_AA_ONLY)
    cs_sync_phy: CsSyncPhy = field(kw_only=True, default=CsSyncPhy.LE_1M_PHY)
    channel_map: bytearray = field(kw_only=True, default_factory=bytearray)
    channel_map_repetition: int = field(kw_only=True, default=0)
    channel_selection_type: CsChannelSelectionType = field(kw_only=True, default=CsChannelSelectionType.TYPE_3B)
    ch3c_shape: CsCh3cShape = field(kw_only=True, default=CsCh3cShape.HAT_SHAPE)
    ch3c_jump: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_CREATE_CONFIG

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsCreateConfig', bytes]:
        if fields['op_code'] != OpCode.LE_CS_CREATE_CONFIG:
            raise Exception("Invalid constraint field values")
        if len(span) < 13:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['config_id'] = span[2]
        fields['create_context'] = CsCreateContext(span[3])
        fields['main_mode_type'] = CsMainModeType(span[4])
        fields['sub_mode_type'] = CsSubModeType(span[5])
        fields['min_main_mode_steps'] = span[6]
        fields['max_main_mode_steps'] = span[7]
        fields['main_mode_repetition'] = span[8]
        fields['mode_0_steps'] = span[9]
        fields['role'] = CsRole(span[10])
        fields['rtt_type'] = CsRttType(span[11])
        fields['cs_sync_phy'] = CsSyncPhy(span[12])
        span = span[13:]
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['channel_map'] = list(span[:10])
        span = span[10:]
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['channel_map_repetition'] = span[0]
        fields['channel_selection_type'] = CsChannelSelectionType(span[1])
        fields['ch3c_shape'] = CsCh3cShape(span[2])
        fields['ch3c_jump'] = span[3]
        span = span[5:]
        return LeCsCreateConfig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsCreateConfig::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.config_id > 255:
            print(f"Invalid value for field LeCsCreateConfig::config_id: {self.config_id} > 255; the value will be truncated")
            self.config_id &= 255
        _span.append((self.config_id << 0))
        _span.append((self.create_context << 0))
        _span.append((self.main_mode_type << 0))
        _span.append((self.sub_mode_type << 0))
        if self.min_main_mode_steps > 255:
            print(f"Invalid value for field LeCsCreateConfig::min_main_mode_steps: {self.min_main_mode_steps} > 255; the value will be truncated")
            self.min_main_mode_steps &= 255
        _span.append((self.min_main_mode_steps << 0))
        if self.max_main_mode_steps > 255:
            print(f"Invalid value for field LeCsCreateConfig::max_main_mode_steps: {self.max_main_mode_steps} > 255; the value will be truncated")
            self.max_main_mode_steps &= 255
        _span.append((self.max_main_mode_steps << 0))
        if self.main_mode_repetition > 255:
            print(f"Invalid value for field LeCsCreateConfig::main_mode_repetition: {self.main_mode_repetition} > 255; the value will be truncated")
            self.main_mode_repetition &= 255
        _span.append((self.main_mode_repetition << 0))
        if self.mode_0_steps > 255:
            print(f"Invalid value for field LeCsCreateConfig::mode_0_steps: {self.mode_0_steps} > 255; the value will be truncated")
            self.mode_0_steps &= 255
        _span.append((self.mode_0_steps << 0))
        _span.append((self.role << 0))
        _span.append((self.rtt_type << 0))
        _span.append((self.cs_sync_phy << 0))
        _span.extend(self.channel_map)
        if self.channel_map_repetition > 255:
            print(f"Invalid value for field LeCsCreateConfig::channel_map_repetition: {self.channel_map_repetition} > 255; the value will be truncated")
            self.channel_map_repetition &= 255
        _span.append((self.channel_map_repetition << 0))
        _span.append((self.channel_selection_type << 0))
        _span.append((self.ch3c_shape << 0))
        if self.ch3c_jump > 255:
            print(f"Invalid value for field LeCsCreateConfig::ch3c_jump: {self.ch3c_jump} > 255; the value will be truncated")
            self.ch3c_jump &= 255
        _span.append((self.ch3c_jump << 0))
        _span.extend([0] * 1)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 28

@dataclass
class LeCsCreateConfigStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_CREATE_CONFIG
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsCreateConfigStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_CREATE_CONFIG:
            raise Exception("Invalid constraint field values")
        return LeCsCreateConfigStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsRemoveConfig(Command):
    connection_handle: int = field(kw_only=True, default=0)
    config_id: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_REMOVE_CONFIG

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsRemoveConfig', bytes]:
        if fields['op_code'] != OpCode.LE_CS_REMOVE_CONFIG:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['config_id'] = span[2]
        span = span[3:]
        return LeCsRemoveConfig(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsRemoveConfig::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.config_id > 255:
            print(f"Invalid value for field LeCsRemoveConfig::config_id: {self.config_id} > 255; the value will be truncated")
            self.config_id &= 255
        _span.append((self.config_id << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeCsRemoveConfigStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_REMOVE_CONFIG
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsRemoveConfigStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_REMOVE_CONFIG:
            raise Exception("Invalid constraint field values")
        return LeCsRemoveConfigStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsSetChannelClassification(Command):
    channel_classification: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_SET_CHANNEL_CLASSIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSetChannelClassification', bytes]:
        if fields['op_code'] != OpCode.LE_CS_SET_CHANNEL_CLASSIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['channel_classification'] = list(span[:10])
        span = span[10:]
        return LeCsSetChannelClassification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.channel_classification)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class LeCsSetChannelClassificationComplete(CommandComplete):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_SET_CHANNEL_CLASSIFICATION
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSetChannelClassificationComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_SET_CHANNEL_CLASSIFICATION:
            raise Exception("Invalid constraint field values")
        return LeCsSetChannelClassificationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class CsPhy(enum.IntEnum):
    LE_1M_PHY = 0x1
    LE_2M_PHY = 0x2
    LE_CODED_PHY_S2 = 0x3
    LE_CODED_PHY_S8 = 0x4

@dataclass
class CsPreferredPeerAntenna(Packet):
    use_first_ordered_antenna_element: int = field(kw_only=True, default=0)
    use_second_ordered_antenna_element: int = field(kw_only=True, default=0)
    use_third_ordered_antenna_element: int = field(kw_only=True, default=0)
    use_fourth_ordered_antenna_element: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['CsPreferredPeerAntenna', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['use_first_ordered_antenna_element'] = (span[0] >> 0) & 0x1
        fields['use_second_ordered_antenna_element'] = (span[0] >> 1) & 0x1
        fields['use_third_ordered_antenna_element'] = (span[0] >> 2) & 0x1
        fields['use_fourth_ordered_antenna_element'] = (span[0] >> 3) & 0x1
        span = span[1:]
        return CsPreferredPeerAntenna(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.use_first_ordered_antenna_element > 1:
            print(f"Invalid value for field CsPreferredPeerAntenna::use_first_ordered_antenna_element: {self.use_first_ordered_antenna_element} > 1; the value will be truncated")
            self.use_first_ordered_antenna_element &= 1
        if self.use_second_ordered_antenna_element > 1:
            print(f"Invalid value for field CsPreferredPeerAntenna::use_second_ordered_antenna_element: {self.use_second_ordered_antenna_element} > 1; the value will be truncated")
            self.use_second_ordered_antenna_element &= 1
        if self.use_third_ordered_antenna_element > 1:
            print(f"Invalid value for field CsPreferredPeerAntenna::use_third_ordered_antenna_element: {self.use_third_ordered_antenna_element} > 1; the value will be truncated")
            self.use_third_ordered_antenna_element &= 1
        if self.use_fourth_ordered_antenna_element > 1:
            print(f"Invalid value for field CsPreferredPeerAntenna::use_fourth_ordered_antenna_element: {self.use_fourth_ordered_antenna_element} > 1; the value will be truncated")
            self.use_fourth_ordered_antenna_element &= 1
        _value = (
            (self.use_first_ordered_antenna_element << 0) |
            (self.use_second_ordered_antenna_element << 1) |
            (self.use_third_ordered_antenna_element << 2) |
            (self.use_fourth_ordered_antenna_element << 3)
        )
        _span.append(_value)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 1

class CsSnrControl(enum.IntEnum):
    ADJUST_18_DB = 0x0
    ADJUST_21_DB = 0x1
    ADJUST_24_DB = 0x2
    ADJUST_27_DB = 0x3
    ADJUST_30_DB = 0x4
    NOT_APPLIED = 0xff

@dataclass
class LeCsSetProcedureParameters(Command):
    connection_handle: int = field(kw_only=True, default=0)
    config_id: int = field(kw_only=True, default=0)
    max_procedure_len: int = field(kw_only=True, default=0)
    min_procedure_interval: int = field(kw_only=True, default=0)
    max_procedure_interval: int = field(kw_only=True, default=0)
    max_procedure_count: int = field(kw_only=True, default=0)
    min_subevent_len: int = field(kw_only=True, default=0)
    max_subevent_len: int = field(kw_only=True, default=0)
    tone_antenna_config_selection: int = field(kw_only=True, default=0)
    phy: CsPhy = field(kw_only=True, default=CsPhy.LE_1M_PHY)
    tx_power_delta: int = field(kw_only=True, default=0)
    preferred_peer_antenna: CsPreferredPeerAntenna = field(kw_only=True, default_factory=CsPreferredPeerAntenna)
    snr_control_initiator: CsSnrControl = field(kw_only=True, default=CsSnrControl.ADJUST_18_DB)
    snr_control_reflector: CsSnrControl = field(kw_only=True, default=CsSnrControl.ADJUST_18_DB)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_SET_PROCEDURE_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSetProcedureParameters', bytes]:
        if fields['op_code'] != OpCode.LE_CS_SET_PROCEDURE_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 23:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['config_id'] = span[2]
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['max_procedure_len'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['min_procedure_interval'] = value_
        value_ = int.from_bytes(span[7:9], byteorder='little')
        fields['max_procedure_interval'] = value_
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['max_procedure_count'] = value_
        value_ = int.from_bytes(span[11:14], byteorder='little')
        fields['min_subevent_len'] = value_
        value_ = int.from_bytes(span[14:17], byteorder='little')
        fields['max_subevent_len'] = value_
        fields['tone_antenna_config_selection'] = span[17]
        fields['phy'] = CsPhy(span[18])
        fields['tx_power_delta'] = span[19]
        fields['preferred_peer_antenna'] = CsPreferredPeerAntenna.parse_all(span[20:21])
        fields['snr_control_initiator'] = CsSnrControl(span[21])
        fields['snr_control_reflector'] = CsSnrControl(span[22])
        span = span[23:]
        return LeCsSetProcedureParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsSetProcedureParameters::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.config_id > 255:
            print(f"Invalid value for field LeCsSetProcedureParameters::config_id: {self.config_id} > 255; the value will be truncated")
            self.config_id &= 255
        _span.append((self.config_id << 0))
        if self.max_procedure_len > 65535:
            print(f"Invalid value for field LeCsSetProcedureParameters::max_procedure_len: {self.max_procedure_len} > 65535; the value will be truncated")
            self.max_procedure_len &= 65535
        _span.extend(int.to_bytes((self.max_procedure_len << 0), length=2, byteorder='little'))
        if self.min_procedure_interval > 65535:
            print(f"Invalid value for field LeCsSetProcedureParameters::min_procedure_interval: {self.min_procedure_interval} > 65535; the value will be truncated")
            self.min_procedure_interval &= 65535
        _span.extend(int.to_bytes((self.min_procedure_interval << 0), length=2, byteorder='little'))
        if self.max_procedure_interval > 65535:
            print(f"Invalid value for field LeCsSetProcedureParameters::max_procedure_interval: {self.max_procedure_interval} > 65535; the value will be truncated")
            self.max_procedure_interval &= 65535
        _span.extend(int.to_bytes((self.max_procedure_interval << 0), length=2, byteorder='little'))
        if self.max_procedure_count > 65535:
            print(f"Invalid value for field LeCsSetProcedureParameters::max_procedure_count: {self.max_procedure_count} > 65535; the value will be truncated")
            self.max_procedure_count &= 65535
        _span.extend(int.to_bytes((self.max_procedure_count << 0), length=2, byteorder='little'))
        if self.min_subevent_len > 16777215:
            print(f"Invalid value for field LeCsSetProcedureParameters::min_subevent_len: {self.min_subevent_len} > 16777215; the value will be truncated")
            self.min_subevent_len &= 16777215
        _span.extend(int.to_bytes((self.min_subevent_len << 0), length=3, byteorder='little'))
        if self.max_subevent_len > 16777215:
            print(f"Invalid value for field LeCsSetProcedureParameters::max_subevent_len: {self.max_subevent_len} > 16777215; the value will be truncated")
            self.max_subevent_len &= 16777215
        _span.extend(int.to_bytes((self.max_subevent_len << 0), length=3, byteorder='little'))
        if self.tone_antenna_config_selection > 255:
            print(f"Invalid value for field LeCsSetProcedureParameters::tone_antenna_config_selection: {self.tone_antenna_config_selection} > 255; the value will be truncated")
            self.tone_antenna_config_selection &= 255
        _span.append((self.tone_antenna_config_selection << 0))
        _span.append((self.phy << 0))
        if self.tx_power_delta > 255:
            print(f"Invalid value for field LeCsSetProcedureParameters::tx_power_delta: {self.tx_power_delta} > 255; the value will be truncated")
            self.tx_power_delta &= 255
        _span.append((self.tx_power_delta << 0))
        _span.extend(self.preferred_peer_antenna.serialize())
        _span.append((self.snr_control_initiator << 0))
        _span.append((self.snr_control_reflector << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 23

@dataclass
class LeCsSetProcedureParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_SET_PROCEDURE_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsSetProcedureParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_SET_PROCEDURE_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return LeCsSetProcedureParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsSetProcedureParametersComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeCsProcedureEnable(Command):
    connection_handle: int = field(kw_only=True, default=0)
    config_id: int = field(kw_only=True, default=0)
    procedure_enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_PROCEDURE_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsProcedureEnable', bytes]:
        if fields['op_code'] != OpCode.LE_CS_PROCEDURE_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['config_id'] = span[2]
        fields['procedure_enable'] = Enable(span[3])
        span = span[4:]
        return LeCsProcedureEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsProcedureEnable::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.config_id > 255:
            print(f"Invalid value for field LeCsProcedureEnable::config_id: {self.config_id} > 255; the value will be truncated")
            self.config_id &= 255
        _span.append((self.config_id << 0))
        _span.append((self.procedure_enable << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class LeCsProcedureEnableStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_PROCEDURE_ENABLE
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsProcedureEnableStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_PROCEDURE_ENABLE:
            raise Exception("Invalid constraint field values")
        return LeCsProcedureEnableStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsProcedureEnableComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    config_id: int = field(kw_only=True, default=0)
    state: Enable = field(kw_only=True, default=Enable.DISABLED)
    tone_antenna_config_selection: int = field(kw_only=True, default=0)
    selected_tx_power: int = field(kw_only=True, default=0)
    subevent_len: int = field(kw_only=True, default=0)
    subevents_per_event: int = field(kw_only=True, default=0)
    subevent_interval: int = field(kw_only=True, default=0)
    event_interval: int = field(kw_only=True, default=0)
    procedure_interval: int = field(kw_only=True, default=0)
    procedure_count: int = field(kw_only=True, default=0)
    max_procedure_len: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CS_PROCEDURE_ENABLE_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsProcedureEnableComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CS_PROCEDURE_ENABLE_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 21:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['config_id'] = span[3]
        fields['state'] = Enable(span[4])
        fields['tone_antenna_config_selection'] = span[5]
        fields['selected_tx_power'] = span[6]
        value_ = int.from_bytes(span[7:10], byteorder='little')
        fields['subevent_len'] = value_
        fields['subevents_per_event'] = span[10]
        value_ = int.from_bytes(span[11:13], byteorder='little')
        fields['subevent_interval'] = value_
        value_ = int.from_bytes(span[13:15], byteorder='little')
        fields['event_interval'] = value_
        value_ = int.from_bytes(span[15:17], byteorder='little')
        fields['procedure_interval'] = value_
        value_ = int.from_bytes(span[17:19], byteorder='little')
        fields['procedure_count'] = value_
        value_ = int.from_bytes(span[19:21], byteorder='little')
        fields['max_procedure_len'] = value_
        span = span[21:]
        return LeCsProcedureEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCsProcedureEnableComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.config_id > 255:
            print(f"Invalid value for field LeCsProcedureEnableComplete::config_id: {self.config_id} > 255; the value will be truncated")
            self.config_id &= 255
        _span.append((self.config_id << 0))
        _span.append((self.state << 0))
        if self.tone_antenna_config_selection > 255:
            print(f"Invalid value for field LeCsProcedureEnableComplete::tone_antenna_config_selection: {self.tone_antenna_config_selection} > 255; the value will be truncated")
            self.tone_antenna_config_selection &= 255
        _span.append((self.tone_antenna_config_selection << 0))
        if self.selected_tx_power > 255:
            print(f"Invalid value for field LeCsProcedureEnableComplete::selected_tx_power: {self.selected_tx_power} > 255; the value will be truncated")
            self.selected_tx_power &= 255
        _span.append((self.selected_tx_power << 0))
        if self.subevent_len > 16777215:
            print(f"Invalid value for field LeCsProcedureEnableComplete::subevent_len: {self.subevent_len} > 16777215; the value will be truncated")
            self.subevent_len &= 16777215
        _span.extend(int.to_bytes((self.subevent_len << 0), length=3, byteorder='little'))
        if self.subevents_per_event > 255:
            print(f"Invalid value for field LeCsProcedureEnableComplete::subevents_per_event: {self.subevents_per_event} > 255; the value will be truncated")
            self.subevents_per_event &= 255
        _span.append((self.subevents_per_event << 0))
        if self.subevent_interval > 65535:
            print(f"Invalid value for field LeCsProcedureEnableComplete::subevent_interval: {self.subevent_interval} > 65535; the value will be truncated")
            self.subevent_interval &= 65535
        _span.extend(int.to_bytes((self.subevent_interval << 0), length=2, byteorder='little'))
        if self.event_interval > 65535:
            print(f"Invalid value for field LeCsProcedureEnableComplete::event_interval: {self.event_interval} > 65535; the value will be truncated")
            self.event_interval &= 65535
        _span.extend(int.to_bytes((self.event_interval << 0), length=2, byteorder='little'))
        if self.procedure_interval > 65535:
            print(f"Invalid value for field LeCsProcedureEnableComplete::procedure_interval: {self.procedure_interval} > 65535; the value will be truncated")
            self.procedure_interval &= 65535
        _span.extend(int.to_bytes((self.procedure_interval << 0), length=2, byteorder='little'))
        if self.procedure_count > 65535:
            print(f"Invalid value for field LeCsProcedureEnableComplete::procedure_count: {self.procedure_count} > 65535; the value will be truncated")
            self.procedure_count &= 65535
        _span.extend(int.to_bytes((self.procedure_count << 0), length=2, byteorder='little'))
        if self.max_procedure_len > 65535:
            print(f"Invalid value for field LeCsProcedureEnableComplete::max_procedure_len: {self.max_procedure_len} > 65535; the value will be truncated")
            self.max_procedure_len &= 65535
        _span.extend(int.to_bytes((self.max_procedure_len << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 21

@dataclass
class LeCsTest(Command):
    main_mode_type: CsMainModeType = field(kw_only=True, default=CsMainModeType.MODE_1)
    sub_mode_type: CsSubModeType = field(kw_only=True, default=CsSubModeType.MODE_1)
    main_mode_repetition: int = field(kw_only=True, default=0)
    mode_0_steps: int = field(kw_only=True, default=0)
    role: CsRole = field(kw_only=True, default=CsRole.INITIATOR)
    rtt_type: CsRttType = field(kw_only=True, default=CsRttType.RTT_AA_ONLY)
    cs_sync_phy: CsSyncPhy = field(kw_only=True, default=CsSyncPhy.LE_1M_PHY)
    cs_sync_antenna_selection: int = field(kw_only=True, default=0)
    subevent_len: int = field(kw_only=True, default=0)
    subevent_interval: int = field(kw_only=True, default=0)
    max_num_subevents: int = field(kw_only=True, default=0)
    transmit_power_level: int = field(kw_only=True, default=0)
    t_ip1_time: int = field(kw_only=True, default=0)
    t_ip2_time: int = field(kw_only=True, default=0)
    t_fcs_time: int = field(kw_only=True, default=0)
    t_pm_time: int = field(kw_only=True, default=0)
    t_sw_time: int = field(kw_only=True, default=0)
    tone_antenna_config_selection: int = field(kw_only=True, default=0)
    snr_control_initiator: CsSnrControl = field(kw_only=True, default=CsSnrControl.ADJUST_18_DB)
    snr_control_reflector: CsSnrControl = field(kw_only=True, default=CsSnrControl.ADJUST_18_DB)
    drbg_nonce: int = field(kw_only=True, default=0)
    channel_map_repetition: int = field(kw_only=True, default=0)
    override_config: int = field(kw_only=True, default=0)
    override_parameters_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_TEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsTest', bytes]:
        if fields['op_code'] != OpCode.LE_CS_TEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 30:
            raise Exception('Invalid packet size')
        fields['main_mode_type'] = CsMainModeType(span[0])
        fields['sub_mode_type'] = CsSubModeType(span[1])
        fields['main_mode_repetition'] = span[2]
        fields['mode_0_steps'] = span[3]
        fields['role'] = CsRole(span[4])
        fields['rtt_type'] = CsRttType(span[5])
        fields['cs_sync_phy'] = CsSyncPhy(span[6])
        fields['cs_sync_antenna_selection'] = span[7]
        value_ = int.from_bytes(span[8:11], byteorder='little')
        fields['subevent_len'] = value_
        value_ = int.from_bytes(span[11:13], byteorder='little')
        fields['subevent_interval'] = value_
        fields['max_num_subevents'] = span[13]
        fields['transmit_power_level'] = span[14]
        fields['t_ip1_time'] = span[15]
        fields['t_ip2_time'] = span[16]
        fields['t_fcs_time'] = span[17]
        fields['t_pm_time'] = span[18]
        fields['t_sw_time'] = span[19]
        fields['tone_antenna_config_selection'] = span[20]
        fields['snr_control_initiator'] = CsSnrControl(span[22])
        fields['snr_control_reflector'] = CsSnrControl(span[23])
        value_ = int.from_bytes(span[24:26], byteorder='little')
        fields['drbg_nonce'] = value_
        fields['channel_map_repetition'] = span[26]
        value_ = int.from_bytes(span[27:29], byteorder='little')
        fields['override_config'] = value_
        override_parameters_data_size = span[29]
        span = span[30:]
        if len(span) < override_parameters_data_size:
            raise Exception('Invalid packet size')
        fields['override_parameters_data'] = list(span[:override_parameters_data_size])
        span = span[override_parameters_data_size:]
        return LeCsTest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.main_mode_type << 0))
        _span.append((self.sub_mode_type << 0))
        if self.main_mode_repetition > 255:
            print(f"Invalid value for field LeCsTest::main_mode_repetition: {self.main_mode_repetition} > 255; the value will be truncated")
            self.main_mode_repetition &= 255
        _span.append((self.main_mode_repetition << 0))
        if self.mode_0_steps > 255:
            print(f"Invalid value for field LeCsTest::mode_0_steps: {self.mode_0_steps} > 255; the value will be truncated")
            self.mode_0_steps &= 255
        _span.append((self.mode_0_steps << 0))
        _span.append((self.role << 0))
        _span.append((self.rtt_type << 0))
        _span.append((self.cs_sync_phy << 0))
        if self.cs_sync_antenna_selection > 255:
            print(f"Invalid value for field LeCsTest::cs_sync_antenna_selection: {self.cs_sync_antenna_selection} > 255; the value will be truncated")
            self.cs_sync_antenna_selection &= 255
        _span.append((self.cs_sync_antenna_selection << 0))
        if self.subevent_len > 16777215:
            print(f"Invalid value for field LeCsTest::subevent_len: {self.subevent_len} > 16777215; the value will be truncated")
            self.subevent_len &= 16777215
        _span.extend(int.to_bytes((self.subevent_len << 0), length=3, byteorder='little'))
        if self.subevent_interval > 65535:
            print(f"Invalid value for field LeCsTest::subevent_interval: {self.subevent_interval} > 65535; the value will be truncated")
            self.subevent_interval &= 65535
        _span.extend(int.to_bytes((self.subevent_interval << 0), length=2, byteorder='little'))
        if self.max_num_subevents > 255:
            print(f"Invalid value for field LeCsTest::max_num_subevents: {self.max_num_subevents} > 255; the value will be truncated")
            self.max_num_subevents &= 255
        _span.append((self.max_num_subevents << 0))
        if self.transmit_power_level > 255:
            print(f"Invalid value for field LeCsTest::transmit_power_level: {self.transmit_power_level} > 255; the value will be truncated")
            self.transmit_power_level &= 255
        _span.append((self.transmit_power_level << 0))
        if self.t_ip1_time > 255:
            print(f"Invalid value for field LeCsTest::t_ip1_time: {self.t_ip1_time} > 255; the value will be truncated")
            self.t_ip1_time &= 255
        _span.append((self.t_ip1_time << 0))
        if self.t_ip2_time > 255:
            print(f"Invalid value for field LeCsTest::t_ip2_time: {self.t_ip2_time} > 255; the value will be truncated")
            self.t_ip2_time &= 255
        _span.append((self.t_ip2_time << 0))
        if self.t_fcs_time > 255:
            print(f"Invalid value for field LeCsTest::t_fcs_time: {self.t_fcs_time} > 255; the value will be truncated")
            self.t_fcs_time &= 255
        _span.append((self.t_fcs_time << 0))
        if self.t_pm_time > 255:
            print(f"Invalid value for field LeCsTest::t_pm_time: {self.t_pm_time} > 255; the value will be truncated")
            self.t_pm_time &= 255
        _span.append((self.t_pm_time << 0))
        if self.t_sw_time > 255:
            print(f"Invalid value for field LeCsTest::t_sw_time: {self.t_sw_time} > 255; the value will be truncated")
            self.t_sw_time &= 255
        _span.append((self.t_sw_time << 0))
        if self.tone_antenna_config_selection > 255:
            print(f"Invalid value for field LeCsTest::tone_antenna_config_selection: {self.tone_antenna_config_selection} > 255; the value will be truncated")
            self.tone_antenna_config_selection &= 255
        _span.append((self.tone_antenna_config_selection << 0))
        _span.extend([0] * 1)
        _span.append((self.snr_control_initiator << 0))
        _span.append((self.snr_control_reflector << 0))
        if self.drbg_nonce > 65535:
            print(f"Invalid value for field LeCsTest::drbg_nonce: {self.drbg_nonce} > 65535; the value will be truncated")
            self.drbg_nonce &= 65535
        _span.extend(int.to_bytes((self.drbg_nonce << 0), length=2, byteorder='little'))
        if self.channel_map_repetition > 255:
            print(f"Invalid value for field LeCsTest::channel_map_repetition: {self.channel_map_repetition} > 255; the value will be truncated")
            self.channel_map_repetition &= 255
        _span.append((self.channel_map_repetition << 0))
        if self.override_config > 65535:
            print(f"Invalid value for field LeCsTest::override_config: {self.override_config} > 65535; the value will be truncated")
            self.override_config &= 65535
        _span.extend(int.to_bytes((self.override_config << 0), length=2, byteorder='little'))
        _span.append(((len(self.override_parameters_data) * 1) << 0))
        _span.extend(self.override_parameters_data)
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.override_parameters_data) * 1 + 30

@dataclass
class LeCsTestComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_TEST
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsTestComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_TEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeCsTestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeCsTestEnd(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_CS_TEST_END

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsTestEnd', bytes]:
        if fields['op_code'] != OpCode.LE_CS_TEST_END:
            raise Exception("Invalid constraint field values")
        return LeCsTestEnd(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsTestEndStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.LE_CS_TEST_END
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsTestEndStatus', bytes]:
        if fields['command_op_code'] != OpCode.LE_CS_TEST_END:
            raise Exception("Invalid constraint field values")
        return LeCsTestEndStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeCsTestEndComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CS_TEST_END_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCsTestEndComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CS_TEST_END_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeCsTestEndComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class InquiryComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.event_code = EventCode.INQUIRY_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['InquiryComplete', bytes]:
        if fields['event_code'] != EventCode.INQUIRY_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return InquiryComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class InquiryResponse(Packet):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    page_scan_repetition_mode: PageScanRepetitionMode = field(kw_only=True, default=PageScanRepetitionMode.R0)
    class_of_device: int = field(kw_only=True, default=0)
    clock_offset: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['InquiryResponse', bytes]:
        fields = {'payload': None}
        if len(span) < 14:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['page_scan_repetition_mode'] = PageScanRepetitionMode(span[6])
        value_ = int.from_bytes(span[9:12], byteorder='little')
        fields['class_of_device'] = value_
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['clock_offset'] = (value_ >> 0) & 0x7fff
        span = span[14:]
        return InquiryResponse(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.page_scan_repetition_mode << 0))
        _span.extend([0] * 1)
        _span.extend([0] * 1)
        if self.class_of_device > 16777215:
            print(f"Invalid value for field InquiryResponse::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        if self.clock_offset > 32767:
            print(f"Invalid value for field InquiryResponse::clock_offset: {self.clock_offset} > 32767; the value will be truncated")
            self.clock_offset &= 32767
        _span.extend(int.to_bytes((self.clock_offset << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 14

@dataclass
class InquiryResult(Event):
    responses: List[InquiryResponse] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.event_code = EventCode.INQUIRY_RESULT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['InquiryResult', bytes]:
        if fields['event_code'] != EventCode.INQUIRY_RESULT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        responses_count = span[0]
        span = span[1:]
        if len(span) < responses_count * 14:
            raise Exception('Invalid packet size')
        responses = []
        for n in range(responses_count):
            responses.append(InquiryResponse.parse_all(span[n * 14:(n + 1) * 14]))
        fields['responses'] = responses
        span = span[responses_count * 14:]
        return InquiryResult(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.responses) > 255:
            print(f"Invalid length for field InquiryResult::responses:  {len(self.responses)} > 255; the array will be truncated")
            del self.responses[255:]
        _span.append((len(self.responses) << 0))
        for _elt in self.responses:
            _span.extend(_elt.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.responses]) + 1

class LinkType(enum.IntEnum):
    SCO = 0x0
    ACL = 0x1

@dataclass
class ConnectionComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    link_type: LinkType = field(kw_only=True, default=LinkType.SCO)
    encryption_enabled: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.event_code = EventCode.CONNECTION_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ConnectionComplete', bytes]:
        if fields['event_code'] != EventCode.CONNECTION_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['bd_addr'] = Address.parse_all(span[3:9])
        fields['link_type'] = LinkType(span[9])
        fields['encryption_enabled'] = Enable(span[10])
        span = span[11:]
        return ConnectionComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ConnectionComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.bd_addr.serialize())
        _span.append((self.link_type << 0))
        _span.append((self.encryption_enabled << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

class ConnectionRequestLinkType(enum.IntEnum):
    UNKNOWN = 0xff
    SCO = 0x0
    ACL = 0x1
    ESCO = 0x2

@dataclass
class ConnectionRequest(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    class_of_device: int = field(kw_only=True, default=0)
    link_type: ConnectionRequestLinkType = field(kw_only=True, default=ConnectionRequestLinkType.UNKNOWN)

    def __post_init__(self):
        self.event_code = EventCode.CONNECTION_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ConnectionRequest', bytes]:
        if fields['event_code'] != EventCode.CONNECTION_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:9], byteorder='little')
        fields['class_of_device'] = value_
        fields['link_type'] = ConnectionRequestLinkType(span[9])
        span = span[10:]
        return ConnectionRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.class_of_device > 16777215:
            print(f"Invalid value for field ConnectionRequest::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        _span.append((self.link_type << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class DisconnectionComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    reason: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.event_code = EventCode.DISCONNECTION_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['DisconnectionComplete', bytes]:
        if fields['event_code'] != EventCode.DISCONNECTION_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['reason'] = ErrorCode(span[3])
        span = span[4:]
        return DisconnectionComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field DisconnectionComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.reason << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class AuthenticationComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.AUTHENTICATION_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AuthenticationComplete', bytes]:
        if fields['event_code'] != EventCode.AUTHENTICATION_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return AuthenticationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field AuthenticationComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class RemoteNameRequestComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    remote_name: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.event_code = EventCode.REMOTE_NAME_REQUEST_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteNameRequestComplete', bytes]:
        if fields['event_code'] != EventCode.REMOTE_NAME_REQUEST_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        if len(span) < 248:
            raise Exception('Invalid packet size')
        fields['remote_name'] = list(span[:248])
        span = span[248:]
        return RemoteNameRequestComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        _span.extend(self.remote_name)
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 255

class EncryptionEnabled(enum.IntEnum):
    OFF = 0x0
    ON = 0x1
    BR_EDR_AES_CCM = 0x2

@dataclass
class EncryptionChange(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    encryption_enabled: EncryptionEnabled = field(kw_only=True, default=EncryptionEnabled.OFF)

    def __post_init__(self):
        self.event_code = EventCode.ENCRYPTION_CHANGE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EncryptionChange', bytes]:
        if fields['event_code'] != EventCode.ENCRYPTION_CHANGE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['encryption_enabled'] = EncryptionEnabled(span[3])
        span = span[4:]
        return EncryptionChange(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field EncryptionChange::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.encryption_enabled << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class EncryptionChangeV2(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    encryption_enabled: EncryptionEnabled = field(kw_only=True, default=EncryptionEnabled.OFF)
    key_size: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.ENCRYPTION_CHANGE_V2

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EncryptionChangeV2', bytes]:
        if fields['event_code'] != EventCode.ENCRYPTION_CHANGE_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['encryption_enabled'] = EncryptionEnabled(span[3])
        fields['key_size'] = span[4]
        span = span[5:]
        return EncryptionChangeV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field EncryptionChangeV2::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.encryption_enabled << 0))
        if self.key_size > 255:
            print(f"Invalid value for field EncryptionChangeV2::key_size: {self.key_size} > 255; the value will be truncated")
            self.key_size &= 255
        _span.append((self.key_size << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class ChangeConnectionLinkKeyComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.CHANGE_CONNECTION_LINK_KEY_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ChangeConnectionLinkKeyComplete', bytes]:
        if fields['event_code'] != EventCode.CHANGE_CONNECTION_LINK_KEY_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return ChangeConnectionLinkKeyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ChangeConnectionLinkKeyComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class CentralLinkKeyComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    key_flag: KeyFlag = field(kw_only=True, default=KeyFlag.SEMI_PERMANENT)

    def __post_init__(self):
        self.event_code = EventCode.CENTRAL_LINK_KEY_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['CentralLinkKeyComplete', bytes]:
        if fields['event_code'] != EventCode.CENTRAL_LINK_KEY_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['key_flag'] = KeyFlag(span[3])
        span = span[4:]
        return CentralLinkKeyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field CentralLinkKeyComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.key_flag << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class ReadRemoteSupportedFeaturesComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    lmp_features: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.READ_REMOTE_SUPPORTED_FEATURES_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteSupportedFeaturesComplete', bytes]:
        if fields['event_code'] != EventCode.READ_REMOTE_SUPPORTED_FEATURES_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:11], byteorder='little')
        fields['lmp_features'] = value_
        span = span[11:]
        return ReadRemoteSupportedFeaturesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRemoteSupportedFeaturesComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.lmp_features > 18446744073709551615:
            print(f"Invalid value for field ReadRemoteSupportedFeaturesComplete::lmp_features: {self.lmp_features} > 18446744073709551615; the value will be truncated")
            self.lmp_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.lmp_features << 0), length=8, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

@dataclass
class ReadRemoteVersionInformationComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    version: int = field(kw_only=True, default=0)
    manufacturer_name: int = field(kw_only=True, default=0)
    sub_version: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.READ_REMOTE_VERSION_INFORMATION_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteVersionInformationComplete', bytes]:
        if fields['event_code'] != EventCode.READ_REMOTE_VERSION_INFORMATION_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['version'] = span[3]
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['manufacturer_name'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['sub_version'] = value_
        span = span[8:]
        return ReadRemoteVersionInformationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRemoteVersionInformationComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.version > 255:
            print(f"Invalid value for field ReadRemoteVersionInformationComplete::version: {self.version} > 255; the value will be truncated")
            self.version &= 255
        _span.append((self.version << 0))
        if self.manufacturer_name > 65535:
            print(f"Invalid value for field ReadRemoteVersionInformationComplete::manufacturer_name: {self.manufacturer_name} > 65535; the value will be truncated")
            self.manufacturer_name &= 65535
        _span.extend(int.to_bytes((self.manufacturer_name << 0), length=2, byteorder='little'))
        if self.sub_version > 65535:
            print(f"Invalid value for field ReadRemoteVersionInformationComplete::sub_version: {self.sub_version} > 65535; the value will be truncated")
            self.sub_version &= 65535
        _span.extend(int.to_bytes((self.sub_version << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class QosSetupComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    service_type: ServiceType = field(kw_only=True, default=ServiceType.NO_TRAFFIC)
    token_rate: int = field(kw_only=True, default=0)
    peak_bandwidth: int = field(kw_only=True, default=0)
    latency: int = field(kw_only=True, default=0)
    delay_variation: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.QOS_SETUP_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['QosSetupComplete', bytes]:
        if fields['event_code'] != EventCode.QOS_SETUP_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 21:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['service_type'] = ServiceType(span[4])
        value_ = int.from_bytes(span[5:9], byteorder='little')
        fields['token_rate'] = value_
        value_ = int.from_bytes(span[9:13], byteorder='little')
        fields['peak_bandwidth'] = value_
        value_ = int.from_bytes(span[13:17], byteorder='little')
        fields['latency'] = value_
        value_ = int.from_bytes(span[17:21], byteorder='little')
        fields['delay_variation'] = value_
        span = span[21:]
        return QosSetupComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field QosSetupComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend([0] * 1)
        _span.append((self.service_type << 0))
        if self.token_rate > 4294967295:
            print(f"Invalid value for field QosSetupComplete::token_rate: {self.token_rate} > 4294967295; the value will be truncated")
            self.token_rate &= 4294967295
        _span.extend(int.to_bytes((self.token_rate << 0), length=4, byteorder='little'))
        if self.peak_bandwidth > 4294967295:
            print(f"Invalid value for field QosSetupComplete::peak_bandwidth: {self.peak_bandwidth} > 4294967295; the value will be truncated")
            self.peak_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.peak_bandwidth << 0), length=4, byteorder='little'))
        if self.latency > 4294967295:
            print(f"Invalid value for field QosSetupComplete::latency: {self.latency} > 4294967295; the value will be truncated")
            self.latency &= 4294967295
        _span.extend(int.to_bytes((self.latency << 0), length=4, byteorder='little'))
        if self.delay_variation > 4294967295:
            print(f"Invalid value for field QosSetupComplete::delay_variation: {self.delay_variation} > 4294967295; the value will be truncated")
            self.delay_variation &= 4294967295
        _span.extend(int.to_bytes((self.delay_variation << 0), length=4, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 21

@dataclass
class HardwareError(Event):
    hardware_code: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.HARDWARE_ERROR

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['HardwareError', bytes]:
        if fields['event_code'] != EventCode.HARDWARE_ERROR:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['hardware_code'] = span[0]
        span = span[1:]
        return HardwareError(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.hardware_code > 255:
            print(f"Invalid value for field HardwareError::hardware_code: {self.hardware_code} > 255; the value will be truncated")
            self.hardware_code &= 255
        _span.append((self.hardware_code << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class FlushOccurred(Event):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.FLUSH_OCCURRED

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['FlushOccurred', bytes]:
        if fields['event_code'] != EventCode.FLUSH_OCCURRED:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return FlushOccurred(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field FlushOccurred::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class RoleChange(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    new_role: Role = field(kw_only=True, default=Role.CENTRAL)

    def __post_init__(self):
        self.event_code = EventCode.ROLE_CHANGE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RoleChange', bytes]:
        if fields['event_code'] != EventCode.ROLE_CHANGE:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        fields['new_role'] = Role(span[7])
        span = span[8:]
        return RoleChange(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        _span.append((self.new_role << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class NumberOfCompletedPackets(Event):
    completed_packets: List[CompletedPackets] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.event_code = EventCode.NUMBER_OF_COMPLETED_PACKETS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['NumberOfCompletedPackets', bytes]:
        if fields['event_code'] != EventCode.NUMBER_OF_COMPLETED_PACKETS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        completed_packets_count = span[0]
        span = span[1:]
        if len(span) < completed_packets_count * 4:
            raise Exception('Invalid packet size')
        completed_packets = []
        for n in range(completed_packets_count):
            completed_packets.append(CompletedPackets.parse_all(span[n * 4:(n + 1) * 4]))
        fields['completed_packets'] = completed_packets
        span = span[completed_packets_count * 4:]
        return NumberOfCompletedPackets(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.completed_packets) > 255:
            print(f"Invalid length for field NumberOfCompletedPackets::completed_packets:  {len(self.completed_packets)} > 255; the array will be truncated")
            del self.completed_packets[255:]
        _span.append((len(self.completed_packets) << 0))
        for _elt in self.completed_packets:
            _span.extend(_elt.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.completed_packets]) + 1

class Mode(enum.IntEnum):
    ACTIVE = 0x0
    HOLD = 0x1
    SNIFF = 0x2

@dataclass
class ModeChange(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    current_mode: Mode = field(kw_only=True, default=Mode.ACTIVE)
    interval: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.MODE_CHANGE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ModeChange', bytes]:
        if fields['event_code'] != EventCode.MODE_CHANGE:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['current_mode'] = Mode(span[3])
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['interval'] = value_
        span = span[6:]
        return ModeChange(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ModeChange::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.current_mode << 0))
        if self.interval > 65535:
            print(f"Invalid value for field ModeChange::interval: {self.interval} > 65535; the value will be truncated")
            self.interval &= 65535
        _span.extend(int.to_bytes((self.interval << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class ZeroKeyAndAddress(Packet):
    address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['ZeroKeyAndAddress', bytes]:
        fields = {'payload': None}
        if len(span) < 22:
            raise Exception('Invalid packet size')
        fields['address'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:14], byteorder='little')
        if value_ != 0x0:
            raise Exception('Unexpected fixed field value')
        value_ = int.from_bytes(span[14:22], byteorder='little')
        if value_ != 0x0:
            raise Exception('Unexpected fixed field value')
        span = span[22:]
        return ZeroKeyAndAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.address.serialize())
        _span.extend(int.to_bytes((0 << 0), length=8, byteorder='little'))
        _span.extend(int.to_bytes((0 << 0), length=8, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 22

@dataclass
class ReturnLinkKeys(Event):
    keys: List[ZeroKeyAndAddress] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.event_code = EventCode.RETURN_LINK_KEYS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReturnLinkKeys', bytes]:
        if fields['event_code'] != EventCode.RETURN_LINK_KEYS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        keys_count = span[0]
        span = span[1:]
        if len(span) < keys_count * 22:
            raise Exception('Invalid packet size')
        keys = []
        for n in range(keys_count):
            keys.append(ZeroKeyAndAddress.parse_all(span[n * 22:(n + 1) * 22]))
        fields['keys'] = keys
        span = span[keys_count * 22:]
        return ReturnLinkKeys(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.keys) > 255:
            print(f"Invalid length for field ReturnLinkKeys::keys:  {len(self.keys)} > 255; the array will be truncated")
            del self.keys[255:]
        _span.append((len(self.keys) << 0))
        for _elt in self.keys:
            _span.extend(_elt.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.keys]) + 1

@dataclass
class PinCodeRequest(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.event_code = EventCode.PIN_CODE_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PinCodeRequest', bytes]:
        if fields['event_code'] != EventCode.PIN_CODE_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return PinCodeRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LinkKeyRequest(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.event_code = EventCode.LINK_KEY_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LinkKeyRequest', bytes]:
        if fields['event_code'] != EventCode.LINK_KEY_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return LinkKeyRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

class KeyType(enum.IntEnum):
    COMBINATION = 0x0
    DEBUG_COMBINATION = 0x3
    UNAUTHENTICATED_P192 = 0x4
    AUTHENTICATED_P192 = 0x5
    CHANGED = 0x6
    UNAUTHENTICATED_P256 = 0x7
    AUTHENTICATED_P256 = 0x8

@dataclass
class LinkKeyNotification(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    link_key: bytearray = field(kw_only=True, default_factory=bytearray)
    key_type: KeyType = field(kw_only=True, default=KeyType.COMBINATION)

    def __post_init__(self):
        self.event_code = EventCode.LINK_KEY_NOTIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LinkKeyNotification', bytes]:
        if fields['event_code'] != EventCode.LINK_KEY_NOTIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['link_key'] = list(span[:16])
        span = span[16:]
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['key_type'] = KeyType(span[0])
        span = span[1:]
        return LinkKeyNotification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.extend(self.link_key)
        _span.append((self.key_type << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 23

@dataclass
class LoopbackCommand(Event):
    

    def __post_init__(self):
        self.event_code = EventCode.LOOPBACK_COMMAND

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LoopbackCommand', bytes]:
        if fields['event_code'] != EventCode.LOOPBACK_COMMAND:
            raise Exception("Invalid constraint field values")
        payload = span
        span = bytes([])
        fields['payload'] = payload
        return LoopbackCommand(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(payload or self.payload or [])
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload)

@dataclass
class DataBufferOverflow(Event):
    link_type: LinkType = field(kw_only=True, default=LinkType.SCO)

    def __post_init__(self):
        self.event_code = EventCode.DATA_BUFFER_OVERFLOW

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['DataBufferOverflow', bytes]:
        if fields['event_code'] != EventCode.DATA_BUFFER_OVERFLOW:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['link_type'] = LinkType(span[0])
        span = span[1:]
        return DataBufferOverflow(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.link_type << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class MaxSlotsChange(Event):
    connection_handle: int = field(kw_only=True, default=0)
    lmp_max_slots: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.MAX_SLOTS_CHANGE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MaxSlotsChange', bytes]:
        if fields['event_code'] != EventCode.MAX_SLOTS_CHANGE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['lmp_max_slots'] = span[2]
        span = span[3:]
        return MaxSlotsChange(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field MaxSlotsChange::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.lmp_max_slots > 255:
            print(f"Invalid value for field MaxSlotsChange::lmp_max_slots: {self.lmp_max_slots} > 255; the value will be truncated")
            self.lmp_max_slots &= 255
        _span.append((self.lmp_max_slots << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class ReadClockOffsetComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    clock_offset: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.READ_CLOCK_OFFSET_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadClockOffsetComplete', bytes]:
        if fields['event_code'] != EventCode.READ_CLOCK_OFFSET_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['clock_offset'] = (value_ >> 0) & 0x7fff
        span = span[5:]
        return ReadClockOffsetComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadClockOffsetComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.clock_offset > 32767:
            print(f"Invalid value for field ReadClockOffsetComplete::clock_offset: {self.clock_offset} > 32767; the value will be truncated")
            self.clock_offset &= 32767
        _span.extend(int.to_bytes((self.clock_offset << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class ConnectionPacketTypeChanged(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    packet_type: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.CONNECTION_PACKET_TYPE_CHANGED

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ConnectionPacketTypeChanged', bytes]:
        if fields['event_code'] != EventCode.CONNECTION_PACKET_TYPE_CHANGED:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['packet_type'] = value_
        span = span[5:]
        return ConnectionPacketTypeChanged(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ConnectionPacketTypeChanged::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.packet_type > 65535:
            print(f"Invalid value for field ConnectionPacketTypeChanged::packet_type: {self.packet_type} > 65535; the value will be truncated")
            self.packet_type &= 65535
        _span.extend(int.to_bytes((self.packet_type << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class QosViolation(Event):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.QOS_VIOLATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['QosViolation', bytes]:
        if fields['event_code'] != EventCode.QOS_VIOLATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return QosViolation(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field QosViolation::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class PageScanRepetitionModeChange(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    page_scan_repetition_mode: PageScanRepetitionMode = field(kw_only=True, default=PageScanRepetitionMode.R0)

    def __post_init__(self):
        self.event_code = EventCode.PAGE_SCAN_REPETITION_MODE_CHANGE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['PageScanRepetitionModeChange', bytes]:
        if fields['event_code'] != EventCode.PAGE_SCAN_REPETITION_MODE_CHANGE:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['page_scan_repetition_mode'] = PageScanRepetitionMode(span[6])
        span = span[7:]
        return PageScanRepetitionModeChange(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.page_scan_repetition_mode << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class FlowSpecificationComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    flow_direction: FlowDirection = field(kw_only=True, default=FlowDirection.OUTGOING_FLOW)
    service_type: ServiceType = field(kw_only=True, default=ServiceType.NO_TRAFFIC)
    token_rate: int = field(kw_only=True, default=0)
    token_bucket_size: int = field(kw_only=True, default=0)
    peak_bandwidth: int = field(kw_only=True, default=0)
    access_latency: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.FLOW_SPECIFICATION_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['FlowSpecificationComplete', bytes]:
        if fields['event_code'] != EventCode.FLOW_SPECIFICATION_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 22:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['flow_direction'] = FlowDirection(span[4])
        fields['service_type'] = ServiceType(span[5])
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['token_rate'] = value_
        value_ = int.from_bytes(span[10:14], byteorder='little')
        fields['token_bucket_size'] = value_
        value_ = int.from_bytes(span[14:18], byteorder='little')
        fields['peak_bandwidth'] = value_
        value_ = int.from_bytes(span[18:22], byteorder='little')
        fields['access_latency'] = value_
        span = span[22:]
        return FlowSpecificationComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field FlowSpecificationComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend([0] * 1)
        _span.append((self.flow_direction << 0))
        _span.append((self.service_type << 0))
        if self.token_rate > 4294967295:
            print(f"Invalid value for field FlowSpecificationComplete::token_rate: {self.token_rate} > 4294967295; the value will be truncated")
            self.token_rate &= 4294967295
        _span.extend(int.to_bytes((self.token_rate << 0), length=4, byteorder='little'))
        if self.token_bucket_size > 4294967295:
            print(f"Invalid value for field FlowSpecificationComplete::token_bucket_size: {self.token_bucket_size} > 4294967295; the value will be truncated")
            self.token_bucket_size &= 4294967295
        _span.extend(int.to_bytes((self.token_bucket_size << 0), length=4, byteorder='little'))
        if self.peak_bandwidth > 4294967295:
            print(f"Invalid value for field FlowSpecificationComplete::peak_bandwidth: {self.peak_bandwidth} > 4294967295; the value will be truncated")
            self.peak_bandwidth &= 4294967295
        _span.extend(int.to_bytes((self.peak_bandwidth << 0), length=4, byteorder='little'))
        if self.access_latency > 4294967295:
            print(f"Invalid value for field FlowSpecificationComplete::access_latency: {self.access_latency} > 4294967295; the value will be truncated")
            self.access_latency &= 4294967295
        _span.extend(int.to_bytes((self.access_latency << 0), length=4, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 22

@dataclass
class InquiryResponseWithRssi(Packet):
    address: Address = field(kw_only=True, default_factory=Address)
    page_scan_repetition_mode: PageScanRepetitionMode = field(kw_only=True, default=PageScanRepetitionMode.R0)
    class_of_device: int = field(kw_only=True, default=0)
    clock_offset: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['InquiryResponseWithRssi', bytes]:
        fields = {'payload': None}
        if len(span) < 14:
            raise Exception('Invalid packet size')
        fields['address'] = Address.parse_all(span[0:6])
        fields['page_scan_repetition_mode'] = PageScanRepetitionMode(span[6])
        value_ = int.from_bytes(span[8:11], byteorder='little')
        fields['class_of_device'] = value_
        value_ = int.from_bytes(span[11:13], byteorder='little')
        fields['clock_offset'] = (value_ >> 0) & 0x7fff
        fields['rssi'] = span[13]
        span = span[14:]
        return InquiryResponseWithRssi(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.address.serialize())
        _span.append((self.page_scan_repetition_mode << 0))
        _span.extend([0] * 1)
        if self.class_of_device > 16777215:
            print(f"Invalid value for field InquiryResponseWithRssi::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        if self.clock_offset > 32767:
            print(f"Invalid value for field InquiryResponseWithRssi::clock_offset: {self.clock_offset} > 32767; the value will be truncated")
            self.clock_offset &= 32767
        _span.extend(int.to_bytes((self.clock_offset << 0), length=2, byteorder='little'))
        if self.rssi > 255:
            print(f"Invalid value for field InquiryResponseWithRssi::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 14

@dataclass
class InquiryResultWithRssi(Event):
    responses: List[InquiryResponseWithRssi] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.event_code = EventCode.INQUIRY_RESULT_WITH_RSSI

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['InquiryResultWithRssi', bytes]:
        if fields['event_code'] != EventCode.INQUIRY_RESULT_WITH_RSSI:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        responses_count = span[0]
        span = span[1:]
        if len(span) < responses_count * 14:
            raise Exception('Invalid packet size')
        responses = []
        for n in range(responses_count):
            responses.append(InquiryResponseWithRssi.parse_all(span[n * 14:(n + 1) * 14]))
        fields['responses'] = responses
        span = span[responses_count * 14:]
        return InquiryResultWithRssi(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.responses) > 255:
            print(f"Invalid length for field InquiryResultWithRssi::responses:  {len(self.responses)} > 255; the array will be truncated")
            del self.responses[255:]
        _span.append((len(self.responses) << 0))
        for _elt in self.responses:
            _span.extend(_elt.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.responses]) + 1

@dataclass
class ReadRemoteExtendedFeaturesComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    page_number: int = field(kw_only=True, default=0)
    maximum_page_number: int = field(kw_only=True, default=0)
    extended_lmp_features: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.READ_REMOTE_EXTENDED_FEATURES_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ReadRemoteExtendedFeaturesComplete', bytes]:
        if fields['event_code'] != EventCode.READ_REMOTE_EXTENDED_FEATURES_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 13:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['page_number'] = span[3]
        fields['maximum_page_number'] = span[4]
        value_ = int.from_bytes(span[5:13], byteorder='little')
        fields['extended_lmp_features'] = value_
        span = span[13:]
        return ReadRemoteExtendedFeaturesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field ReadRemoteExtendedFeaturesComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.page_number > 255:
            print(f"Invalid value for field ReadRemoteExtendedFeaturesComplete::page_number: {self.page_number} > 255; the value will be truncated")
            self.page_number &= 255
        _span.append((self.page_number << 0))
        if self.maximum_page_number > 255:
            print(f"Invalid value for field ReadRemoteExtendedFeaturesComplete::maximum_page_number: {self.maximum_page_number} > 255; the value will be truncated")
            self.maximum_page_number &= 255
        _span.append((self.maximum_page_number << 0))
        if self.extended_lmp_features > 18446744073709551615:
            print(f"Invalid value for field ReadRemoteExtendedFeaturesComplete::extended_lmp_features: {self.extended_lmp_features} > 18446744073709551615; the value will be truncated")
            self.extended_lmp_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.extended_lmp_features << 0), length=8, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 13

class ScoLinkType(enum.IntEnum):
    SCO = 0x0
    ESCO = 0x2

class ScoAirMode(enum.IntEnum):
    ULAW_LOG = 0x0
    ALAW_LOG = 0x1
    CVSD = 0x2
    TRANSPARENT = 0x3

@dataclass
class SynchronousConnectionComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    link_type: ScoLinkType = field(kw_only=True, default=ScoLinkType.SCO)
    transmission_interval_slots: int = field(kw_only=True, default=0)
    retransmission_window_slots: int = field(kw_only=True, default=0)
    rx_packet_length: int = field(kw_only=True, default=0)
    tx_packet_length: int = field(kw_only=True, default=0)
    air_mode: ScoAirMode = field(kw_only=True, default=ScoAirMode.ULAW_LOG)

    def __post_init__(self):
        self.event_code = EventCode.SYNCHRONOUS_CONNECTION_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SynchronousConnectionComplete', bytes]:
        if fields['event_code'] != EventCode.SYNCHRONOUS_CONNECTION_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 17:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['bd_addr'] = Address.parse_all(span[3:9])
        fields['link_type'] = ScoLinkType(span[9])
        fields['transmission_interval_slots'] = span[10]
        fields['retransmission_window_slots'] = span[11]
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['rx_packet_length'] = value_
        value_ = int.from_bytes(span[14:16], byteorder='little')
        fields['tx_packet_length'] = value_
        fields['air_mode'] = ScoAirMode(span[16])
        span = span[17:]
        return SynchronousConnectionComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field SynchronousConnectionComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.bd_addr.serialize())
        _span.append((self.link_type << 0))
        if self.transmission_interval_slots > 255:
            print(f"Invalid value for field SynchronousConnectionComplete::transmission_interval_slots: {self.transmission_interval_slots} > 255; the value will be truncated")
            self.transmission_interval_slots &= 255
        _span.append((self.transmission_interval_slots << 0))
        if self.retransmission_window_slots > 255:
            print(f"Invalid value for field SynchronousConnectionComplete::retransmission_window_slots: {self.retransmission_window_slots} > 255; the value will be truncated")
            self.retransmission_window_slots &= 255
        _span.append((self.retransmission_window_slots << 0))
        if self.rx_packet_length > 65535:
            print(f"Invalid value for field SynchronousConnectionComplete::rx_packet_length: {self.rx_packet_length} > 65535; the value will be truncated")
            self.rx_packet_length &= 65535
        _span.extend(int.to_bytes((self.rx_packet_length << 0), length=2, byteorder='little'))
        if self.tx_packet_length > 65535:
            print(f"Invalid value for field SynchronousConnectionComplete::tx_packet_length: {self.tx_packet_length} > 65535; the value will be truncated")
            self.tx_packet_length &= 65535
        _span.extend(int.to_bytes((self.tx_packet_length << 0), length=2, byteorder='little'))
        _span.append((self.air_mode << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 17

@dataclass
class SynchronousConnectionChanged(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    transmission_interval_slots: int = field(kw_only=True, default=0)
    retransmission_window_slots: int = field(kw_only=True, default=0)
    rx_packet_length: int = field(kw_only=True, default=0)
    tx_packet_length: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.SYNCHRONOUS_CONNECTION_CHANGED

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SynchronousConnectionChanged', bytes]:
        if fields['event_code'] != EventCode.SYNCHRONOUS_CONNECTION_CHANGED:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['transmission_interval_slots'] = span[3]
        fields['retransmission_window_slots'] = span[4]
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['rx_packet_length'] = value_
        value_ = int.from_bytes(span[7:9], byteorder='little')
        fields['tx_packet_length'] = value_
        span = span[9:]
        return SynchronousConnectionChanged(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field SynchronousConnectionChanged::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.transmission_interval_slots > 255:
            print(f"Invalid value for field SynchronousConnectionChanged::transmission_interval_slots: {self.transmission_interval_slots} > 255; the value will be truncated")
            self.transmission_interval_slots &= 255
        _span.append((self.transmission_interval_slots << 0))
        if self.retransmission_window_slots > 255:
            print(f"Invalid value for field SynchronousConnectionChanged::retransmission_window_slots: {self.retransmission_window_slots} > 255; the value will be truncated")
            self.retransmission_window_slots &= 255
        _span.append((self.retransmission_window_slots << 0))
        if self.rx_packet_length > 65535:
            print(f"Invalid value for field SynchronousConnectionChanged::rx_packet_length: {self.rx_packet_length} > 65535; the value will be truncated")
            self.rx_packet_length &= 65535
        _span.extend(int.to_bytes((self.rx_packet_length << 0), length=2, byteorder='little'))
        if self.tx_packet_length > 65535:
            print(f"Invalid value for field SynchronousConnectionChanged::tx_packet_length: {self.tx_packet_length} > 65535; the value will be truncated")
            self.tx_packet_length &= 65535
        _span.extend(int.to_bytes((self.tx_packet_length << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class SniffSubratingEvent(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    maximum_transmit_latency: int = field(kw_only=True, default=0)
    maximum_receive_latency: int = field(kw_only=True, default=0)
    minimum_remote_timeout: int = field(kw_only=True, default=0)
    minimum_local_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.SNIFF_SUBRATING

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SniffSubratingEvent', bytes]:
        if fields['event_code'] != EventCode.SNIFF_SUBRATING:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['maximum_transmit_latency'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['maximum_receive_latency'] = value_
        value_ = int.from_bytes(span[7:9], byteorder='little')
        fields['minimum_remote_timeout'] = value_
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['minimum_local_timeout'] = value_
        span = span[11:]
        return SniffSubratingEvent(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field SniffSubratingEvent::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.maximum_transmit_latency > 65535:
            print(f"Invalid value for field SniffSubratingEvent::maximum_transmit_latency: {self.maximum_transmit_latency} > 65535; the value will be truncated")
            self.maximum_transmit_latency &= 65535
        _span.extend(int.to_bytes((self.maximum_transmit_latency << 0), length=2, byteorder='little'))
        if self.maximum_receive_latency > 65535:
            print(f"Invalid value for field SniffSubratingEvent::maximum_receive_latency: {self.maximum_receive_latency} > 65535; the value will be truncated")
            self.maximum_receive_latency &= 65535
        _span.extend(int.to_bytes((self.maximum_receive_latency << 0), length=2, byteorder='little'))
        if self.minimum_remote_timeout > 65535:
            print(f"Invalid value for field SniffSubratingEvent::minimum_remote_timeout: {self.minimum_remote_timeout} > 65535; the value will be truncated")
            self.minimum_remote_timeout &= 65535
        _span.extend(int.to_bytes((self.minimum_remote_timeout << 0), length=2, byteorder='little'))
        if self.minimum_local_timeout > 65535:
            print(f"Invalid value for field SniffSubratingEvent::minimum_local_timeout: {self.minimum_local_timeout} > 65535; the value will be truncated")
            self.minimum_local_timeout &= 65535
        _span.extend(int.to_bytes((self.minimum_local_timeout << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

@dataclass
class ExtendedInquiryResult(Event):
    address: Address = field(kw_only=True, default_factory=Address)
    page_scan_repetition_mode: PageScanRepetitionMode = field(kw_only=True, default=PageScanRepetitionMode.R0)
    class_of_device: int = field(kw_only=True, default=0)
    clock_offset: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)
    extended_inquiry_response: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.event_code = EventCode.EXTENDED_INQUIRY_RESULT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ExtendedInquiryResult', bytes]:
        if fields['event_code'] != EventCode.EXTENDED_INQUIRY_RESULT:
            raise Exception("Invalid constraint field values")
        if len(span) < 15:
            raise Exception('Invalid packet size')
        if span[0] != 0x1:
            raise Exception('Unexpected fixed field value')
        fields['address'] = Address.parse_all(span[1:7])
        fields['page_scan_repetition_mode'] = PageScanRepetitionMode(span[7])
        value_ = int.from_bytes(span[9:12], byteorder='little')
        fields['class_of_device'] = value_
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['clock_offset'] = (value_ >> 0) & 0x7fff
        fields['rssi'] = span[14]
        span = span[15:]
        if len(span) < 240:
            raise Exception('Invalid packet size')
        fields['extended_inquiry_response'] = list(span[:240])
        span = span[240:]
        return ExtendedInquiryResult(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((1 << 0))
        _span.extend(self.address.serialize())
        _span.append((self.page_scan_repetition_mode << 0))
        _span.extend([0] * 1)
        if self.class_of_device > 16777215:
            print(f"Invalid value for field ExtendedInquiryResult::class_of_device: {self.class_of_device} > 16777215; the value will be truncated")
            self.class_of_device &= 16777215
        _span.extend(int.to_bytes((self.class_of_device << 0), length=3, byteorder='little'))
        if self.clock_offset > 32767:
            print(f"Invalid value for field ExtendedInquiryResult::clock_offset: {self.clock_offset} > 32767; the value will be truncated")
            self.clock_offset &= 32767
        _span.extend(int.to_bytes((self.clock_offset << 0), length=2, byteorder='little'))
        if self.rssi > 255:
            print(f"Invalid value for field ExtendedInquiryResult::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        _span.extend(self.extended_inquiry_response)
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 255

@dataclass
class EncryptionKeyRefreshComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.ENCRYPTION_KEY_REFRESH_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EncryptionKeyRefreshComplete', bytes]:
        if fields['event_code'] != EventCode.ENCRYPTION_KEY_REFRESH_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[3:]
        return EncryptionKeyRefreshComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field EncryptionKeyRefreshComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class IoCapabilityRequest(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.event_code = EventCode.IO_CAPABILITY_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IoCapabilityRequest', bytes]:
        if fields['event_code'] != EventCode.IO_CAPABILITY_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return IoCapabilityRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class IoCapabilityResponse(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    io_capability: IoCapability = field(kw_only=True, default=IoCapability.DISPLAY_ONLY)
    oob_data_present: OobDataPresent = field(kw_only=True, default=OobDataPresent.NOT_PRESENT)
    authentication_requirements: AuthenticationRequirements = field(kw_only=True, default=AuthenticationRequirements.NO_BONDING)

    def __post_init__(self):
        self.event_code = EventCode.IO_CAPABILITY_RESPONSE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IoCapabilityResponse', bytes]:
        if fields['event_code'] != EventCode.IO_CAPABILITY_RESPONSE:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['io_capability'] = IoCapability(span[6])
        fields['oob_data_present'] = OobDataPresent(span[7])
        fields['authentication_requirements'] = AuthenticationRequirements(span[8])
        span = span[9:]
        return IoCapabilityResponse(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.io_capability << 0))
        _span.append((self.oob_data_present << 0))
        _span.append((self.authentication_requirements << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class UserConfirmationRequest(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    numeric_value: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.USER_CONFIRMATION_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserConfirmationRequest', bytes]:
        if fields['event_code'] != EventCode.USER_CONFIRMATION_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['numeric_value'] = (value_ >> 0) & 0xfffff
        span = span[10:]
        return UserConfirmationRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.numeric_value > 1048575:
            print(f"Invalid value for field UserConfirmationRequest::numeric_value: {self.numeric_value} > 1048575; the value will be truncated")
            self.numeric_value &= 1048575
        _span.extend(int.to_bytes((self.numeric_value << 0), length=4, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class UserPasskeyRequest(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.event_code = EventCode.USER_PASSKEY_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserPasskeyRequest', bytes]:
        if fields['event_code'] != EventCode.USER_PASSKEY_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return UserPasskeyRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class RemoteOobDataRequest(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.event_code = EventCode.REMOTE_OOB_DATA_REQUEST

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteOobDataRequest', bytes]:
        if fields['event_code'] != EventCode.REMOTE_OOB_DATA_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        span = span[6:]
        return RemoteOobDataRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class SimplePairingComplete(Event):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    bd_addr: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.event_code = EventCode.SIMPLE_PAIRING_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['SimplePairingComplete', bytes]:
        if fields['event_code'] != EventCode.SIMPLE_PAIRING_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['bd_addr'] = Address.parse_all(span[1:7])
        span = span[7:]
        return SimplePairingComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.bd_addr.serialize())
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class LinkSupervisionTimeoutChanged(Event):
    connection_handle: int = field(kw_only=True, default=0)
    link_supervision_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.LINK_SUPERVISION_TIMEOUT_CHANGED

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LinkSupervisionTimeoutChanged', bytes]:
        if fields['event_code'] != EventCode.LINK_SUPERVISION_TIMEOUT_CHANGED:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['link_supervision_timeout'] = value_
        span = span[4:]
        return LinkSupervisionTimeoutChanged(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LinkSupervisionTimeoutChanged::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.link_supervision_timeout > 65535:
            print(f"Invalid value for field LinkSupervisionTimeoutChanged::link_supervision_timeout: {self.link_supervision_timeout} > 65535; the value will be truncated")
            self.link_supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.link_supervision_timeout << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

class FlushablePacketType(enum.IntEnum):
    AUTOMATICALLY_FLUSHABLE_ONLY = 0x0

@dataclass
class EnhancedFlush(Command):
    connection_handle: int = field(kw_only=True, default=0)
    packet_type: FlushablePacketType = field(kw_only=True, default=FlushablePacketType.AUTOMATICALLY_FLUSHABLE_ONLY)

    def __post_init__(self):
        self.op_code = OpCode.ENHANCED_FLUSH

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnhancedFlush', bytes]:
        if fields['op_code'] != OpCode.ENHANCED_FLUSH:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['packet_type'] = FlushablePacketType(span[2])
        span = span[3:]
        return EnhancedFlush(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field EnhancedFlush::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.packet_type << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class EnhancedFlushStatus(CommandStatus):
    

    def __post_init__(self):
        self.command_op_code = OpCode.ENHANCED_FLUSH
        self.event_code = EventCode.COMMAND_STATUS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnhancedFlushStatus', bytes]:
        if fields['command_op_code'] != OpCode.ENHANCED_FLUSH:
            raise Exception("Invalid constraint field values")
        return EnhancedFlushStatus(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return CommandStatus.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class EnhancedFlushComplete(Event):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.ENHANCED_FLUSH_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['EnhancedFlushComplete', bytes]:
        if fields['event_code'] != EventCode.ENHANCED_FLUSH_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return EnhancedFlushComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field EnhancedFlushComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class UserPasskeyNotification(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    passkey: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.USER_PASSKEY_NOTIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['UserPasskeyNotification', bytes]:
        if fields['event_code'] != EventCode.USER_PASSKEY_NOTIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:10], byteorder='little')
        fields['passkey'] = (value_ >> 0) & 0xfffff
        span = span[10:]
        return UserPasskeyNotification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.passkey > 1048575:
            print(f"Invalid value for field UserPasskeyNotification::passkey: {self.passkey} > 1048575; the value will be truncated")
            self.passkey &= 1048575
        _span.extend(int.to_bytes((self.passkey << 0), length=4, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class KeypressNotification(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    notification_type: KeypressNotificationType = field(kw_only=True, default=KeypressNotificationType.ENTRY_STARTED)

    def __post_init__(self):
        self.event_code = EventCode.KEYPRESS_NOTIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['KeypressNotification', bytes]:
        if fields['event_code'] != EventCode.KEYPRESS_NOTIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['notification_type'] = KeypressNotificationType(span[6])
        span = span[7:]
        return KeypressNotification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.notification_type << 0))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 7

@dataclass
class RemoteHostSupportedFeaturesNotification(Event):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    host_supported_features: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.REMOTE_HOST_SUPPORTED_FEATURES_NOTIFICATION

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['RemoteHostSupportedFeaturesNotification', bytes]:
        if fields['event_code'] != EventCode.REMOTE_HOST_SUPPORTED_FEATURES_NOTIFICATION:
            raise Exception("Invalid constraint field values")
        if len(span) < 14:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        value_ = int.from_bytes(span[6:14], byteorder='little')
        fields['host_supported_features'] = value_
        span = span[14:]
        return RemoteHostSupportedFeaturesNotification(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        if self.host_supported_features > 18446744073709551615:
            print(f"Invalid value for field RemoteHostSupportedFeaturesNotification::host_supported_features: {self.host_supported_features} > 18446744073709551615; the value will be truncated")
            self.host_supported_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.host_supported_features << 0), length=8, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 14

@dataclass
class NumberOfCompletedDataBlocks(Event):
    total_num_data_blocks: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.NUMBER_OF_COMPLETED_DATA_BLOCKS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['NumberOfCompletedDataBlocks', bytes]:
        if fields['event_code'] != EventCode.NUMBER_OF_COMPLETED_DATA_BLOCKS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['total_num_data_blocks'] = value_
        span = span[2:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        return NumberOfCompletedDataBlocks(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.total_num_data_blocks > 65535:
            print(f"Invalid value for field NumberOfCompletedDataBlocks::total_num_data_blocks: {self.total_num_data_blocks} > 65535; the value will be truncated")
            self.total_num_data_blocks &= 65535
        _span.extend(int.to_bytes((self.total_num_data_blocks << 0), length=2, byteorder='little'))
        _span.extend(payload or self.payload or [])
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 2

@dataclass
class AuthenticatedPayloadTimeoutExpired(Event):
    connection_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.event_code = EventCode.AUTHENTICATED_PAYLOAD_TIMEOUT_EXPIRED

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['AuthenticatedPayloadTimeoutExpired', bytes]:
        if fields['event_code'] != EventCode.AUTHENTICATED_PAYLOAD_TIMEOUT_EXPIRED:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return AuthenticatedPayloadTimeoutExpired(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field AuthenticatedPayloadTimeoutExpired::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        return Event.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeConnectionComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    role: Role = field(kw_only=True, default=Role.CENTRAL)
    peer_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    connection_interval: int = field(kw_only=True, default=0)
    peripheral_latency: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)
    central_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CONNECTION_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeConnectionComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CONNECTION_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 18:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['role'] = Role(span[3])
        fields['peer_address_type'] = AddressType(span[4])
        fields['peer_address'] = Address.parse_all(span[5:11])
        value_ = int.from_bytes(span[11:13], byteorder='little')
        fields['connection_interval'] = value_
        value_ = int.from_bytes(span[13:15], byteorder='little')
        fields['peripheral_latency'] = value_
        value_ = int.from_bytes(span[15:17], byteorder='little')
        fields['supervision_timeout'] = value_
        fields['central_clock_accuracy'] = ClockAccuracy(span[17])
        span = span[18:]
        return LeConnectionComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeConnectionComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.role << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        if self.connection_interval > 65535:
            print(f"Invalid value for field LeConnectionComplete::connection_interval: {self.connection_interval} > 65535; the value will be truncated")
            self.connection_interval &= 65535
        _span.extend(int.to_bytes((self.connection_interval << 0), length=2, byteorder='little'))
        if self.peripheral_latency > 65535:
            print(f"Invalid value for field LeConnectionComplete::peripheral_latency: {self.peripheral_latency} > 65535; the value will be truncated")
            self.peripheral_latency &= 65535
        _span.extend(int.to_bytes((self.peripheral_latency << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 65535:
            print(f"Invalid value for field LeConnectionComplete::supervision_timeout: {self.supervision_timeout} > 65535; the value will be truncated")
            self.supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        _span.append((self.central_clock_accuracy << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 18

class AdvertisingEventType(enum.IntEnum):
    ADV_IND = 0x0
    ADV_DIRECT_IND = 0x1
    ADV_SCAN_IND = 0x2
    ADV_NONCONN_IND = 0x3
    SCAN_RESPONSE = 0x4

@dataclass
class LeAdvertisingResponse(Packet):
    event_type: AdvertisingEventType = field(kw_only=True, default=AdvertisingEventType.ADV_IND)
    address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    address: Address = field(kw_only=True, default_factory=Address)
    advertising_data: bytearray = field(kw_only=True, default_factory=bytearray)
    rssi: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LeAdvertisingResponse', bytes]:
        fields = {'payload': None}
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['event_type'] = AdvertisingEventType(span[0])
        fields['address_type'] = AddressType(span[1])
        fields['address'] = Address.parse_all(span[2:8])
        advertising_data_size = span[8]
        span = span[9:]
        if len(span) < advertising_data_size:
            raise Exception('Invalid packet size')
        fields['advertising_data'] = list(span[:advertising_data_size])
        span = span[advertising_data_size:]
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['rssi'] = span[0]
        span = span[1:]
        return LeAdvertisingResponse(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.event_type << 0))
        _span.append((self.address_type << 0))
        _span.extend(self.address.serialize())
        _span.append(((len(self.advertising_data) * 1) << 0))
        _span.extend(self.advertising_data)
        if self.rssi > 255:
            print(f"Invalid value for field LeAdvertisingResponse::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.advertising_data) * 1 + 10

@dataclass
class LeAdvertisingReport(LeMetaEvent):
    responses: List[LeAdvertisingResponse] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_ADVERTISING_REPORT
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAdvertisingReport', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_ADVERTISING_REPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        responses_count = span[0]
        span = span[1:]
        responses = []
        for n in range(responses_count):
            element, span = LeAdvertisingResponse.parse(span)
            responses.append(element)
        fields['responses'] = responses
        return LeAdvertisingReport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.responses) > 255:
            print(f"Invalid length for field LeAdvertisingReport::responses:  {len(self.responses)} > 255; the array will be truncated")
            del self.responses[255:]
        _span.append((len(self.responses) << 0))
        for _elt in self.responses:
            _span.extend(_elt.serialize())
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.responses]) + 1

@dataclass
class LeConnectionUpdateComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    connection_interval: int = field(kw_only=True, default=0)
    peripheral_latency: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CONNECTION_UPDATE_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeConnectionUpdateComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CONNECTION_UPDATE_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['connection_interval'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['peripheral_latency'] = value_
        value_ = int.from_bytes(span[7:9], byteorder='little')
        fields['supervision_timeout'] = value_
        span = span[9:]
        return LeConnectionUpdateComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeConnectionUpdateComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.connection_interval > 65535:
            print(f"Invalid value for field LeConnectionUpdateComplete::connection_interval: {self.connection_interval} > 65535; the value will be truncated")
            self.connection_interval &= 65535
        _span.extend(int.to_bytes((self.connection_interval << 0), length=2, byteorder='little'))
        if self.peripheral_latency > 65535:
            print(f"Invalid value for field LeConnectionUpdateComplete::peripheral_latency: {self.peripheral_latency} > 65535; the value will be truncated")
            self.peripheral_latency &= 65535
        _span.extend(int.to_bytes((self.peripheral_latency << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 65535:
            print(f"Invalid value for field LeConnectionUpdateComplete::supervision_timeout: {self.supervision_timeout} > 65535; the value will be truncated")
            self.supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9

@dataclass
class LeLongTermKeyRequest(LeMetaEvent):
    connection_handle: int = field(kw_only=True, default=0)
    random_number: bytearray = field(kw_only=True, default_factory=bytearray)
    encrypted_diversifier: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_LONG_TERM_KEY_REQUEST
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeLongTermKeyRequest', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_LONG_TERM_KEY_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['random_number'] = list(span[:8])
        span = span[8:]
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['encrypted_diversifier'] = value_
        span = span[2:]
        return LeLongTermKeyRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeLongTermKeyRequest::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.extend(self.random_number)
        if self.encrypted_diversifier > 65535:
            print(f"Invalid value for field LeLongTermKeyRequest::encrypted_diversifier: {self.encrypted_diversifier} > 65535; the value will be truncated")
            self.encrypted_diversifier &= 65535
        _span.extend(int.to_bytes((self.encrypted_diversifier << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 12

@dataclass
class LeRemoteConnectionParameterRequest(LeMetaEvent):
    connection_handle: int = field(kw_only=True, default=0)
    interval_min: int = field(kw_only=True, default=0)
    interval_max: int = field(kw_only=True, default=0)
    latency: int = field(kw_only=True, default=0)
    timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRemoteConnectionParameterRequest', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_REMOTE_CONNECTION_PARAMETER_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['interval_min'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['interval_max'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['latency'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['timeout'] = value_
        span = span[10:]
        return LeRemoteConnectionParameterRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRemoteConnectionParameterRequest::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.interval_min > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequest::interval_min: {self.interval_min} > 65535; the value will be truncated")
            self.interval_min &= 65535
        _span.extend(int.to_bytes((self.interval_min << 0), length=2, byteorder='little'))
        if self.interval_max > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequest::interval_max: {self.interval_max} > 65535; the value will be truncated")
            self.interval_max &= 65535
        _span.extend(int.to_bytes((self.interval_max << 0), length=2, byteorder='little'))
        if self.latency > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequest::latency: {self.latency} > 65535; the value will be truncated")
            self.latency &= 65535
        _span.extend(int.to_bytes((self.latency << 0), length=2, byteorder='little'))
        if self.timeout > 65535:
            print(f"Invalid value for field LeRemoteConnectionParameterRequest::timeout: {self.timeout} > 65535; the value will be truncated")
            self.timeout &= 65535
        _span.extend(int.to_bytes((self.timeout << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class LeDataLengthChange(LeMetaEvent):
    connection_handle: int = field(kw_only=True, default=0)
    max_tx_octets: int = field(kw_only=True, default=0)
    max_tx_time: int = field(kw_only=True, default=0)
    max_rx_octets: int = field(kw_only=True, default=0)
    max_rx_time: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_DATA_LENGTH_CHANGE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeDataLengthChange', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_DATA_LENGTH_CHANGE:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['max_tx_octets'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['max_tx_time'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['max_rx_octets'] = value_
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['max_rx_time'] = value_
        span = span[10:]
        return LeDataLengthChange(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeDataLengthChange::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.max_tx_octets > 65535:
            print(f"Invalid value for field LeDataLengthChange::max_tx_octets: {self.max_tx_octets} > 65535; the value will be truncated")
            self.max_tx_octets &= 65535
        _span.extend(int.to_bytes((self.max_tx_octets << 0), length=2, byteorder='little'))
        if self.max_tx_time > 65535:
            print(f"Invalid value for field LeDataLengthChange::max_tx_time: {self.max_tx_time} > 65535; the value will be truncated")
            self.max_tx_time &= 65535
        _span.extend(int.to_bytes((self.max_tx_time << 0), length=2, byteorder='little'))
        if self.max_rx_octets > 65535:
            print(f"Invalid value for field LeDataLengthChange::max_rx_octets: {self.max_rx_octets} > 65535; the value will be truncated")
            self.max_rx_octets &= 65535
        _span.extend(int.to_bytes((self.max_rx_octets << 0), length=2, byteorder='little'))
        if self.max_rx_time > 65535:
            print(f"Invalid value for field LeDataLengthChange::max_rx_time: {self.max_rx_time} > 65535; the value will be truncated")
            self.max_rx_time &= 65535
        _span.extend(int.to_bytes((self.max_rx_time << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 10

@dataclass
class LeReadLocalP256PublicKeyComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    key_x_coordinate: bytearray = field(kw_only=True, default_factory=bytearray)
    key_y_coordinate: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeReadLocalP256PublicKeyComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        if len(span) < 32:
            raise Exception('Invalid packet size')
        fields['key_x_coordinate'] = list(span[:32])
        span = span[32:]
        if len(span) < 32:
            raise Exception('Invalid packet size')
        fields['key_y_coordinate'] = list(span[:32])
        span = span[32:]
        return LeReadLocalP256PublicKeyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.key_x_coordinate)
        _span.extend(self.key_y_coordinate)
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 65

@dataclass
class LeGenerateDhKeyComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    dh_key: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_GENERATE_DHKEY_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGenerateDhKeyComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_GENERATE_DHKEY_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        if len(span) < 32:
            raise Exception('Invalid packet size')
        fields['dh_key'] = list(span[:32])
        span = span[32:]
        return LeGenerateDhKeyComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.dh_key)
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 33

@dataclass
class LeEnhancedConnectionCompleteV1(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    role: Role = field(kw_only=True, default=Role.CENTRAL)
    peer_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    local_resolvable_private_address: Address = field(kw_only=True, default_factory=Address)
    peer_resolvable_private_address: Address = field(kw_only=True, default_factory=Address)
    connection_interval: int = field(kw_only=True, default=0)
    peripheral_latency: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)
    central_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_ENHANCED_CONNECTION_COMPLETE_V1
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedConnectionCompleteV1', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_ENHANCED_CONNECTION_COMPLETE_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 30:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['role'] = Role(span[3])
        fields['peer_address_type'] = AddressType(span[4])
        fields['peer_address'] = Address.parse_all(span[5:11])
        fields['local_resolvable_private_address'] = Address.parse_all(span[11:17])
        fields['peer_resolvable_private_address'] = Address.parse_all(span[17:23])
        value_ = int.from_bytes(span[23:25], byteorder='little')
        fields['connection_interval'] = value_
        value_ = int.from_bytes(span[25:27], byteorder='little')
        fields['peripheral_latency'] = value_
        value_ = int.from_bytes(span[27:29], byteorder='little')
        fields['supervision_timeout'] = value_
        fields['central_clock_accuracy'] = ClockAccuracy(span[29])
        span = span[30:]
        return LeEnhancedConnectionCompleteV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV1::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.role << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        _span.extend(self.local_resolvable_private_address.serialize())
        _span.extend(self.peer_resolvable_private_address.serialize())
        if self.connection_interval > 65535:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV1::connection_interval: {self.connection_interval} > 65535; the value will be truncated")
            self.connection_interval &= 65535
        _span.extend(int.to_bytes((self.connection_interval << 0), length=2, byteorder='little'))
        if self.peripheral_latency > 65535:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV1::peripheral_latency: {self.peripheral_latency} > 65535; the value will be truncated")
            self.peripheral_latency &= 65535
        _span.extend(int.to_bytes((self.peripheral_latency << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 65535:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV1::supervision_timeout: {self.supervision_timeout} > 65535; the value will be truncated")
            self.supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        _span.append((self.central_clock_accuracy << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 30

@dataclass
class LeEnhancedConnectionCompleteV2(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    role: Role = field(kw_only=True, default=Role.CENTRAL)
    peer_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    peer_address: Address = field(kw_only=True, default_factory=Address)
    local_resolvable_private_address: Address = field(kw_only=True, default_factory=Address)
    peer_resolvable_private_address: Address = field(kw_only=True, default_factory=Address)
    connection_interval: int = field(kw_only=True, default=0)
    peripheral_latency: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)
    central_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)
    advertising_handle: int = field(kw_only=True, default=0)
    sync_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_ENHANCED_CONNECTION_COMPLETE_V2
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeEnhancedConnectionCompleteV2', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_ENHANCED_CONNECTION_COMPLETE_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 33:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['role'] = Role(span[3])
        fields['peer_address_type'] = AddressType(span[4])
        fields['peer_address'] = Address.parse_all(span[5:11])
        fields['local_resolvable_private_address'] = Address.parse_all(span[11:17])
        fields['peer_resolvable_private_address'] = Address.parse_all(span[17:23])
        value_ = int.from_bytes(span[23:25], byteorder='little')
        fields['connection_interval'] = value_
        value_ = int.from_bytes(span[25:27], byteorder='little')
        fields['peripheral_latency'] = value_
        value_ = int.from_bytes(span[27:29], byteorder='little')
        fields['supervision_timeout'] = value_
        fields['central_clock_accuracy'] = ClockAccuracy(span[29])
        fields['advertising_handle'] = span[30]
        value_ = int.from_bytes(span[31:33], byteorder='little')
        fields['sync_handle'] = value_
        span = span[33:]
        return LeEnhancedConnectionCompleteV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV2::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.role << 0))
        _span.append((self.peer_address_type << 0))
        _span.extend(self.peer_address.serialize())
        _span.extend(self.local_resolvable_private_address.serialize())
        _span.extend(self.peer_resolvable_private_address.serialize())
        if self.connection_interval > 65535:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV2::connection_interval: {self.connection_interval} > 65535; the value will be truncated")
            self.connection_interval &= 65535
        _span.extend(int.to_bytes((self.connection_interval << 0), length=2, byteorder='little'))
        if self.peripheral_latency > 65535:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV2::peripheral_latency: {self.peripheral_latency} > 65535; the value will be truncated")
            self.peripheral_latency &= 65535
        _span.extend(int.to_bytes((self.peripheral_latency << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 65535:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV2::supervision_timeout: {self.supervision_timeout} > 65535; the value will be truncated")
            self.supervision_timeout &= 65535
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        _span.append((self.central_clock_accuracy << 0))
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV2::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.sync_handle > 65535:
            print(f"Invalid value for field LeEnhancedConnectionCompleteV2::sync_handle: {self.sync_handle} > 65535; the value will be truncated")
            self.sync_handle &= 65535
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 33

class DirectAdvertisingAddressType(enum.IntEnum):
    PUBLIC_DEVICE_ADDRESS = 0x0
    RANDOM_DEVICE_ADDRESS = 0x1
    PUBLIC_IDENTITY_ADDRESS = 0x2
    RANDOM_IDENTITY_ADDRESS = 0x3
    CONTROLLER_UNABLE_TO_RESOLVE = 0xfe
    NO_ADDRESS_PROVIDED = 0xff

class DirectAdvertisingEventType(enum.IntEnum):
    ADV_DIRECT_IND = 0x1

class DirectAddressType(enum.IntEnum):
    RANDOM_DEVICE_ADDRESS = 0x1

@dataclass
class LeDirectedAdvertisingResponse(Packet):
    event_type: DirectAdvertisingEventType = field(kw_only=True, default=DirectAdvertisingEventType.ADV_DIRECT_IND)
    address_type: DirectAdvertisingAddressType = field(kw_only=True, default=DirectAdvertisingAddressType.PUBLIC_DEVICE_ADDRESS)
    address: Address = field(kw_only=True, default_factory=Address)
    direct_address_type: DirectAddressType = field(kw_only=True, default=DirectAddressType.RANDOM_DEVICE_ADDRESS)
    direct_address: Address = field(kw_only=True, default_factory=Address)
    rssi: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LeDirectedAdvertisingResponse', bytes]:
        fields = {'payload': None}
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['event_type'] = DirectAdvertisingEventType(span[0])
        fields['address_type'] = DirectAdvertisingAddressType(span[1])
        fields['address'] = Address.parse_all(span[2:8])
        fields['direct_address_type'] = DirectAddressType(span[8])
        fields['direct_address'] = Address.parse_all(span[9:15])
        fields['rssi'] = span[15]
        span = span[16:]
        return LeDirectedAdvertisingResponse(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.event_type << 0))
        _span.append((self.address_type << 0))
        _span.extend(self.address.serialize())
        _span.append((self.direct_address_type << 0))
        _span.extend(self.direct_address.serialize())
        if self.rssi > 255:
            print(f"Invalid value for field LeDirectedAdvertisingResponse::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 16

@dataclass
class LeDirectedAdvertisingReport(LeMetaEvent):
    responses: List[LeDirectedAdvertisingResponse] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_DIRECTED_ADVERTISING_REPORT
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeDirectedAdvertisingReport', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_DIRECTED_ADVERTISING_REPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        responses_count = span[0]
        span = span[1:]
        if len(span) < responses_count * 16:
            raise Exception('Invalid packet size')
        responses = []
        for n in range(responses_count):
            responses.append(LeDirectedAdvertisingResponse.parse_all(span[n * 16:(n + 1) * 16]))
        fields['responses'] = responses
        span = span[responses_count * 16:]
        return LeDirectedAdvertisingReport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.responses) > 255:
            print(f"Invalid length for field LeDirectedAdvertisingReport::responses:  {len(self.responses)} > 255; the array will be truncated")
            del self.responses[255:]
        _span.append((len(self.responses) << 0))
        for _elt in self.responses:
            _span.extend(_elt.serialize())
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.responses]) + 1

@dataclass
class LePhyUpdateComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    tx_phy: PhyType = field(kw_only=True, default=PhyType.LE_1M)
    rx_phy: PhyType = field(kw_only=True, default=PhyType.LE_1M)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PHY_UPDATE_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePhyUpdateComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PHY_UPDATE_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['tx_phy'] = PhyType(span[3])
        fields['rx_phy'] = PhyType(span[4])
        span = span[5:]
        return LePhyUpdateComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePhyUpdateComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.tx_phy << 0))
        _span.append((self.rx_phy << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

class DataStatus(enum.IntEnum):
    COMPLETE = 0x0
    CONTINUING = 0x1
    TRUNCATED = 0x2
    RESERVED = 0x3

@dataclass
class LeExtendedAdvertisingResponse(Packet):
    connectable: int = field(kw_only=True, default=0)
    scannable: int = field(kw_only=True, default=0)
    directed: int = field(kw_only=True, default=0)
    scan_response: int = field(kw_only=True, default=0)
    legacy: int = field(kw_only=True, default=0)
    data_status: DataStatus = field(kw_only=True, default=DataStatus.COMPLETE)
    address_type: DirectAdvertisingAddressType = field(kw_only=True, default=DirectAdvertisingAddressType.PUBLIC_DEVICE_ADDRESS)
    address: Address = field(kw_only=True, default_factory=Address)
    primary_phy: PrimaryPhyType = field(kw_only=True, default=PrimaryPhyType.LE_1M)
    secondary_phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    advertising_sid: int = field(kw_only=True, default=0)
    tx_power: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)
    periodic_advertising_interval: int = field(kw_only=True, default=0)
    direct_address_type: DirectAdvertisingAddressType = field(kw_only=True, default=DirectAdvertisingAddressType.PUBLIC_DEVICE_ADDRESS)
    direct_address: Address = field(kw_only=True, default_factory=Address)
    advertising_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['LeExtendedAdvertisingResponse', bytes]:
        fields = {'payload': None}
        if len(span) < 24:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connectable'] = (value_ >> 0) & 0x1
        fields['scannable'] = (value_ >> 1) & 0x1
        fields['directed'] = (value_ >> 2) & 0x1
        fields['scan_response'] = (value_ >> 3) & 0x1
        fields['legacy'] = (value_ >> 4) & 0x1
        fields['data_status'] = DataStatus((value_ >> 5) & 0x3)
        fields['address_type'] = DirectAdvertisingAddressType(span[2])
        fields['address'] = Address.parse_all(span[3:9])
        fields['primary_phy'] = PrimaryPhyType(span[9])
        fields['secondary_phy'] = SecondaryPhyType(span[10])
        fields['advertising_sid'] = span[11]
        fields['tx_power'] = span[12]
        fields['rssi'] = span[13]
        value_ = int.from_bytes(span[14:16], byteorder='little')
        fields['periodic_advertising_interval'] = value_
        fields['direct_address_type'] = DirectAdvertisingAddressType(span[16])
        fields['direct_address'] = Address.parse_all(span[17:23])
        advertising_data_size = span[23]
        span = span[24:]
        if len(span) < advertising_data_size:
            raise Exception('Invalid packet size')
        fields['advertising_data'] = list(span[:advertising_data_size])
        span = span[advertising_data_size:]
        return LeExtendedAdvertisingResponse(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connectable > 1:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::connectable: {self.connectable} > 1; the value will be truncated")
            self.connectable &= 1
        if self.scannable > 1:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::scannable: {self.scannable} > 1; the value will be truncated")
            self.scannable &= 1
        if self.directed > 1:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::directed: {self.directed} > 1; the value will be truncated")
            self.directed &= 1
        if self.scan_response > 1:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::scan_response: {self.scan_response} > 1; the value will be truncated")
            self.scan_response &= 1
        if self.legacy > 1:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::legacy: {self.legacy} > 1; the value will be truncated")
            self.legacy &= 1
        _value = (
            (self.connectable << 0) |
            (self.scannable << 1) |
            (self.directed << 2) |
            (self.scan_response << 3) |
            (self.legacy << 4) |
            (self.data_status << 5)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        _span.append((self.address_type << 0))
        _span.extend(self.address.serialize())
        _span.append((self.primary_phy << 0))
        _span.append((self.secondary_phy << 0))
        if self.advertising_sid > 255:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        if self.tx_power > 255:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        if self.rssi > 255:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        if self.periodic_advertising_interval > 65535:
            print(f"Invalid value for field LeExtendedAdvertisingResponse::periodic_advertising_interval: {self.periodic_advertising_interval} > 65535; the value will be truncated")
            self.periodic_advertising_interval &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval << 0), length=2, byteorder='little'))
        _span.append((self.direct_address_type << 0))
        _span.extend(self.direct_address.serialize())
        _span.append(((len(self.advertising_data) * 1) << 0))
        _span.extend(self.advertising_data)
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.advertising_data) * 1 + 24

@dataclass
class LeExtendedAdvertisingReport(LeMetaEvent):
    responses: List[LeExtendedAdvertisingResponse] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_EXTENDED_ADVERTISING_REPORT
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeExtendedAdvertisingReport', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_EXTENDED_ADVERTISING_REPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        responses_count = span[0]
        span = span[1:]
        responses = []
        for n in range(responses_count):
            element, span = LeExtendedAdvertisingResponse.parse(span)
            responses.append(element)
        fields['responses'] = responses
        return LeExtendedAdvertisingReport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.responses) > 255:
            print(f"Invalid length for field LeExtendedAdvertisingReport::responses:  {len(self.responses)} > 255; the array will be truncated")
            del self.responses[255:]
        _span.append((len(self.responses) << 0))
        for _elt in self.responses:
            _span.extend(_elt.serialize())
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.responses]) + 1

@dataclass
class LePeriodicAdvertisingSyncEstablishedV1(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    sync_handle: int = field(kw_only=True, default=0)
    advertising_sid: int = field(kw_only=True, default=0)
    advertiser_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    advertiser_phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    periodic_advertising_interval: int = field(kw_only=True, default=0)
    advertiser_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_V1
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSyncEstablishedV1', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 15:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['advertising_sid'] = span[3]
        fields['advertiser_address_type'] = AddressType(span[4])
        fields['advertiser_address'] = Address.parse_all(span[5:11])
        fields['advertiser_phy'] = SecondaryPhyType(span[11])
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['periodic_advertising_interval'] = value_
        fields['advertiser_clock_accuracy'] = ClockAccuracy(span[14])
        span = span[15:]
        return LePeriodicAdvertisingSyncEstablishedV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV1::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.advertising_sid > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV1::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        _span.append((self.advertiser_address_type << 0))
        _span.extend(self.advertiser_address.serialize())
        _span.append((self.advertiser_phy << 0))
        if self.periodic_advertising_interval > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV1::periodic_advertising_interval: {self.periodic_advertising_interval} > 65535; the value will be truncated")
            self.periodic_advertising_interval &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval << 0), length=2, byteorder='little'))
        _span.append((self.advertiser_clock_accuracy << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 15

@dataclass
class LePeriodicAdvertisingSyncEstablishedV2(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    sync_handle: int = field(kw_only=True, default=0)
    advertising_sid: int = field(kw_only=True, default=0)
    advertiser_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    advertiser_phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    periodic_advertising_interval: int = field(kw_only=True, default=0)
    advertiser_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)
    num_subevents: int = field(kw_only=True, default=0)
    subevent_interval: int = field(kw_only=True, default=0)
    response_slot_delay: int = field(kw_only=True, default=0)
    response_slot_spacing: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_V2
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSyncEstablishedV2', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 19:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['advertising_sid'] = span[3]
        fields['advertiser_address_type'] = AddressType(span[4])
        fields['advertiser_address'] = Address.parse_all(span[5:11])
        fields['advertiser_phy'] = SecondaryPhyType(span[11])
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['periodic_advertising_interval'] = value_
        fields['advertiser_clock_accuracy'] = ClockAccuracy(span[14])
        fields['num_subevents'] = span[15]
        fields['subevent_interval'] = span[16]
        fields['response_slot_delay'] = span[17]
        fields['response_slot_spacing'] = span[18]
        span = span[19:]
        return LePeriodicAdvertisingSyncEstablishedV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV2::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.advertising_sid > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV2::advertising_sid: {self.advertising_sid} > 255; the value will be truncated")
            self.advertising_sid &= 255
        _span.append((self.advertising_sid << 0))
        _span.append((self.advertiser_address_type << 0))
        _span.extend(self.advertiser_address.serialize())
        _span.append((self.advertiser_phy << 0))
        if self.periodic_advertising_interval > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV2::periodic_advertising_interval: {self.periodic_advertising_interval} > 65535; the value will be truncated")
            self.periodic_advertising_interval &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval << 0), length=2, byteorder='little'))
        _span.append((self.advertiser_clock_accuracy << 0))
        if self.num_subevents > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV2::num_subevents: {self.num_subevents} > 255; the value will be truncated")
            self.num_subevents &= 255
        _span.append((self.num_subevents << 0))
        if self.subevent_interval > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV2::subevent_interval: {self.subevent_interval} > 255; the value will be truncated")
            self.subevent_interval &= 255
        _span.append((self.subevent_interval << 0))
        if self.response_slot_delay > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV2::response_slot_delay: {self.response_slot_delay} > 255; the value will be truncated")
            self.response_slot_delay &= 255
        _span.append((self.response_slot_delay << 0))
        if self.response_slot_spacing > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncEstablishedV2::response_slot_spacing: {self.response_slot_spacing} > 255; the value will be truncated")
            self.response_slot_spacing &= 255
        _span.append((self.response_slot_spacing << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 19

@dataclass
class LePeriodicAdvertisingReportV1(LeMetaEvent):
    sync_handle: int = field(kw_only=True, default=0)
    tx_power: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)
    cte_type: CteType = field(kw_only=True, default=CteType.AOA_CONSTANT_TONE_EXTENSION)
    data_status: DataStatus = field(kw_only=True, default=DataStatus.COMPLETE)
    data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PERIODIC_ADVERTISING_REPORT_V1
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingReportV1', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PERIODIC_ADVERTISING_REPORT_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 7:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['tx_power'] = span[2]
        fields['rssi'] = span[3]
        fields['cte_type'] = CteType(span[4])
        fields['data_status'] = DataStatus((span[5] >> 0) & 0x3)
        data_size = span[6]
        span = span[7:]
        if len(span) < data_size:
            raise Exception('Invalid packet size')
        fields['data'] = list(span[:data_size])
        span = span[data_size:]
        return LePeriodicAdvertisingReportV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingReportV1::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.tx_power > 255:
            print(f"Invalid value for field LePeriodicAdvertisingReportV1::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        if self.rssi > 255:
            print(f"Invalid value for field LePeriodicAdvertisingReportV1::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        _span.append((self.cte_type << 0))
        _span.append((self.data_status << 0))
        _span.append(((len(self.data) * 1) << 0))
        _span.extend(self.data)
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.data) * 1 + 7

@dataclass
class LePeriodicAdvertisingReportV2(LeMetaEvent):
    sync_handle: int = field(kw_only=True, default=0)
    tx_power: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)
    cte_type: CteType = field(kw_only=True, default=CteType.AOA_CONSTANT_TONE_EXTENSION)
    periodic_event_counter: int = field(kw_only=True, default=0)
    subevent: int = field(kw_only=True, default=0)
    data_status: DataStatus = field(kw_only=True, default=DataStatus.COMPLETE)
    data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PERIODIC_ADVERTISING_REPORT_V2
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingReportV2', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PERIODIC_ADVERTISING_REPORT_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['tx_power'] = span[2]
        fields['rssi'] = span[3]
        fields['cte_type'] = CteType(span[4])
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['periodic_event_counter'] = value_
        fields['subevent'] = span[7]
        fields['data_status'] = DataStatus((span[8] >> 0) & 0x3)
        data_size = span[9]
        span = span[10:]
        if len(span) < data_size:
            raise Exception('Invalid packet size')
        fields['data'] = list(span[:data_size])
        span = span[data_size:]
        return LePeriodicAdvertisingReportV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingReportV2::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.tx_power > 255:
            print(f"Invalid value for field LePeriodicAdvertisingReportV2::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        if self.rssi > 255:
            print(f"Invalid value for field LePeriodicAdvertisingReportV2::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        _span.append((self.cte_type << 0))
        if self.periodic_event_counter > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingReportV2::periodic_event_counter: {self.periodic_event_counter} > 65535; the value will be truncated")
            self.periodic_event_counter &= 65535
        _span.extend(int.to_bytes((self.periodic_event_counter << 0), length=2, byteorder='little'))
        if self.subevent > 255:
            print(f"Invalid value for field LePeriodicAdvertisingReportV2::subevent: {self.subevent} > 255; the value will be truncated")
            self.subevent &= 255
        _span.append((self.subevent << 0))
        _span.append((self.data_status << 0))
        _span.append(((len(self.data) * 1) << 0))
        _span.extend(self.data)
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.data) * 1 + 10

@dataclass
class LePeriodicAdvertisingSyncLost(LeMetaEvent):
    sync_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_LOST
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSyncLost', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_LOST:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        span = span[2:]
        return LePeriodicAdvertisingSyncLost(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncLost::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeScanTimeout(LeMetaEvent):
    

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_SCAN_TIMEOUT
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeScanTimeout', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_SCAN_TIMEOUT:
            raise Exception("Invalid constraint field values")
        return LeScanTimeout(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeAdvertisingSetTerminated(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    advertising_handle: int = field(kw_only=True, default=0)
    connection_handle: int = field(kw_only=True, default=0)
    num_completed_extended_advertising_events: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_ADVERTISING_SET_TERMINATED
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAdvertisingSetTerminated', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_ADVERTISING_SET_TERMINATED:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['advertising_handle'] = span[1]
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['num_completed_extended_advertising_events'] = span[4]
        span = span[5:]
        return LeAdvertisingSetTerminated(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeAdvertisingSetTerminated::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeAdvertisingSetTerminated::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.num_completed_extended_advertising_events > 255:
            print(f"Invalid value for field LeAdvertisingSetTerminated::num_completed_extended_advertising_events: {self.num_completed_extended_advertising_events} > 255; the value will be truncated")
            self.num_completed_extended_advertising_events &= 255
        _span.append((self.num_completed_extended_advertising_events << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 5

@dataclass
class LeScanRequestReceived(LeMetaEvent):
    advertising_handle: int = field(kw_only=True, default=0)
    scanner_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    scanner_address: Address = field(kw_only=True, default_factory=Address)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_SCAN_REQUEST_RECEIVED
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeScanRequestReceived', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_SCAN_REQUEST_RECEIVED:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['advertising_handle'] = span[0]
        fields['scanner_address_type'] = AddressType(span[1])
        fields['scanner_address'] = Address.parse_all(span[2:8])
        span = span[8:]
        return LeScanRequestReceived(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.advertising_handle > 255:
            print(f"Invalid value for field LeScanRequestReceived::advertising_handle: {self.advertising_handle} > 255; the value will be truncated")
            self.advertising_handle &= 255
        _span.append((self.advertising_handle << 0))
        _span.append((self.scanner_address_type << 0))
        _span.extend(self.scanner_address.serialize())
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

class ChannelSelectionAlgorithm(enum.IntEnum):
    ALGORITHM_1 = 0x0
    ALGORITHM_2 = 0x1

@dataclass
class LeChannelSelectionAlgorithm(LeMetaEvent):
    connection_handle: int = field(kw_only=True, default=0)
    channel_selection_algorithm: ChannelSelectionAlgorithm = field(kw_only=True, default=ChannelSelectionAlgorithm.ALGORITHM_1)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CHANNEL_SELECTION_ALGORITHM
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeChannelSelectionAlgorithm', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CHANNEL_SELECTION_ALGORITHM:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['channel_selection_algorithm'] = ChannelSelectionAlgorithm(span[2])
        span = span[3:]
        return LeChannelSelectionAlgorithm(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeChannelSelectionAlgorithm::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.channel_selection_algorithm << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeConnectionlessIqReport(LeMetaEvent):
    

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CONNECTIONLESS_IQ_REPORT
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeConnectionlessIqReport', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CONNECTIONLESS_IQ_REPORT:
            raise Exception("Invalid constraint field values")
        payload = span
        span = bytes([])
        fields['payload'] = payload
        return LeConnectionlessIqReport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(payload or self.payload or [])
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload)

@dataclass
class LeConnectionIqReport(LeMetaEvent):
    

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CONNECTION_IQ_REPORT
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeConnectionIqReport', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CONNECTION_IQ_REPORT:
            raise Exception("Invalid constraint field values")
        payload = span
        span = bytes([])
        fields['payload'] = payload
        return LeConnectionIqReport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(payload or self.payload or [])
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload)

@dataclass
class LeCteRequestFailed(LeMetaEvent):
    

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CTE_REQUEST_FAILED
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCteRequestFailed', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CTE_REQUEST_FAILED:
            raise Exception("Invalid constraint field values")
        payload = span
        span = bytes([])
        fields['payload'] = payload
        return LeCteRequestFailed(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(payload or self.payload or [])
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload)

@dataclass
class LePeriodicAdvertisingSyncTransferReceivedV1(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    service_data: int = field(kw_only=True, default=0)
    sync_handle: int = field(kw_only=True, default=0)
    advertising_sid: int = field(kw_only=True, default=0)
    advertiser_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    advertiser_phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    periodic_advertising_interval: int = field(kw_only=True, default=0)
    advertiser_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_V1
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSyncTransferReceivedV1', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 19:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['service_data'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['advertising_sid'] = (span[7] >> 0) & 0xf
        fields['advertiser_address_type'] = AddressType(span[8])
        fields['advertiser_address'] = Address.parse_all(span[9:15])
        fields['advertiser_phy'] = SecondaryPhyType(span[15])
        value_ = int.from_bytes(span[16:18], byteorder='little')
        fields['periodic_advertising_interval'] = value_
        fields['advertiser_clock_accuracy'] = ClockAccuracy(span[18])
        span = span[19:]
        return LePeriodicAdvertisingSyncTransferReceivedV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV1::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.service_data > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV1::service_data: {self.service_data} > 65535; the value will be truncated")
            self.service_data &= 65535
        _span.extend(int.to_bytes((self.service_data << 0), length=2, byteorder='little'))
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV1::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.advertising_sid > 15:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV1::advertising_sid: {self.advertising_sid} > 15; the value will be truncated")
            self.advertising_sid &= 15
        _span.append((self.advertising_sid << 0))
        _span.append((self.advertiser_address_type << 0))
        _span.extend(self.advertiser_address.serialize())
        _span.append((self.advertiser_phy << 0))
        if self.periodic_advertising_interval > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV1::periodic_advertising_interval: {self.periodic_advertising_interval} > 65535; the value will be truncated")
            self.periodic_advertising_interval &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval << 0), length=2, byteorder='little'))
        _span.append((self.advertiser_clock_accuracy << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 19

@dataclass
class LePeriodicAdvertisingSyncTransferReceivedV2(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    service_data: int = field(kw_only=True, default=0)
    sync_handle: int = field(kw_only=True, default=0)
    advertising_sid: int = field(kw_only=True, default=0)
    advertiser_address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    advertiser_phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    periodic_advertising_interval: int = field(kw_only=True, default=0)
    advertiser_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)
    num_subevents: int = field(kw_only=True, default=0)
    subevent_interval: int = field(kw_only=True, default=0)
    response_slot_delay: int = field(kw_only=True, default=0)
    response_slot_spacing: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_V2
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePeriodicAdvertisingSyncTransferReceivedV2', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 23:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['service_data'] = value_
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['advertising_sid'] = (span[7] >> 0) & 0xf
        fields['advertiser_address_type'] = AddressType(span[8])
        fields['advertiser_address'] = Address.parse_all(span[9:15])
        fields['advertiser_phy'] = SecondaryPhyType(span[15])
        value_ = int.from_bytes(span[16:18], byteorder='little')
        fields['periodic_advertising_interval'] = value_
        fields['advertiser_clock_accuracy'] = ClockAccuracy(span[18])
        fields['num_subevents'] = span[19]
        fields['subevent_interval'] = span[20]
        fields['response_slot_delay'] = span[21]
        fields['response_slot_spacing'] = span[22]
        span = span[23:]
        return LePeriodicAdvertisingSyncTransferReceivedV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.service_data > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::service_data: {self.service_data} > 65535; the value will be truncated")
            self.service_data &= 65535
        _span.extend(int.to_bytes((self.service_data << 0), length=2, byteorder='little'))
        if self.sync_handle > 4095:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.advertising_sid > 15:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::advertising_sid: {self.advertising_sid} > 15; the value will be truncated")
            self.advertising_sid &= 15
        _span.append((self.advertising_sid << 0))
        _span.append((self.advertiser_address_type << 0))
        _span.extend(self.advertiser_address.serialize())
        _span.append((self.advertiser_phy << 0))
        if self.periodic_advertising_interval > 65535:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::periodic_advertising_interval: {self.periodic_advertising_interval} > 65535; the value will be truncated")
            self.periodic_advertising_interval &= 65535
        _span.extend(int.to_bytes((self.periodic_advertising_interval << 0), length=2, byteorder='little'))
        _span.append((self.advertiser_clock_accuracy << 0))
        if self.num_subevents > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::num_subevents: {self.num_subevents} > 255; the value will be truncated")
            self.num_subevents &= 255
        _span.append((self.num_subevents << 0))
        if self.subevent_interval > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::subevent_interval: {self.subevent_interval} > 255; the value will be truncated")
            self.subevent_interval &= 255
        _span.append((self.subevent_interval << 0))
        if self.response_slot_delay > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::response_slot_delay: {self.response_slot_delay} > 255; the value will be truncated")
            self.response_slot_delay &= 255
        _span.append((self.response_slot_delay << 0))
        if self.response_slot_spacing > 255:
            print(f"Invalid value for field LePeriodicAdvertisingSyncTransferReceivedV2::response_slot_spacing: {self.response_slot_spacing} > 255; the value will be truncated")
            self.response_slot_spacing &= 255
        _span.append((self.response_slot_spacing << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 23

@dataclass
class LeCisEstablishedV1(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    cig_sync_delay: int = field(kw_only=True, default=0)
    cis_sync_delay: int = field(kw_only=True, default=0)
    transport_latency_c_to_p: int = field(kw_only=True, default=0)
    transport_latency_p_to_c: int = field(kw_only=True, default=0)
    phy_c_to_p: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    phy_p_to_c: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    nse: int = field(kw_only=True, default=0)
    bn_c_to_p: int = field(kw_only=True, default=0)
    bn_p_to_c: int = field(kw_only=True, default=0)
    ft_c_to_p: int = field(kw_only=True, default=0)
    ft_p_to_c: int = field(kw_only=True, default=0)
    max_pdu_c_to_p: int = field(kw_only=True, default=0)
    max_pdu_p_to_c: int = field(kw_only=True, default=0)
    iso_interval: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CIS_ESTABLISHED_V1
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCisEstablishedV1', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CIS_ESTABLISHED_V1:
            raise Exception("Invalid constraint field values")
        if len(span) < 28:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:6], byteorder='little')
        fields['cig_sync_delay'] = value_
        value_ = int.from_bytes(span[6:9], byteorder='little')
        fields['cis_sync_delay'] = value_
        value_ = int.from_bytes(span[9:12], byteorder='little')
        fields['transport_latency_c_to_p'] = value_
        value_ = int.from_bytes(span[12:15], byteorder='little')
        fields['transport_latency_p_to_c'] = value_
        fields['phy_c_to_p'] = SecondaryPhyType(span[15])
        fields['phy_p_to_c'] = SecondaryPhyType(span[16])
        fields['nse'] = span[17]
        fields['bn_c_to_p'] = (span[18] >> 0) & 0xf
        fields['bn_p_to_c'] = (span[19] >> 0) & 0xf
        fields['ft_c_to_p'] = span[20]
        fields['ft_p_to_c'] = span[21]
        fields['max_pdu_c_to_p'] = span[22]
        fields['max_pdu_p_to_c'] = span[24]
        value_ = int.from_bytes(span[26:28], byteorder='little')
        fields['iso_interval'] = value_
        span = span[28:]
        return LeCisEstablishedV1(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCisEstablishedV1::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.cig_sync_delay > 16777215:
            print(f"Invalid value for field LeCisEstablishedV1::cig_sync_delay: {self.cig_sync_delay} > 16777215; the value will be truncated")
            self.cig_sync_delay &= 16777215
        _span.extend(int.to_bytes((self.cig_sync_delay << 0), length=3, byteorder='little'))
        if self.cis_sync_delay > 16777215:
            print(f"Invalid value for field LeCisEstablishedV1::cis_sync_delay: {self.cis_sync_delay} > 16777215; the value will be truncated")
            self.cis_sync_delay &= 16777215
        _span.extend(int.to_bytes((self.cis_sync_delay << 0), length=3, byteorder='little'))
        if self.transport_latency_c_to_p > 16777215:
            print(f"Invalid value for field LeCisEstablishedV1::transport_latency_c_to_p: {self.transport_latency_c_to_p} > 16777215; the value will be truncated")
            self.transport_latency_c_to_p &= 16777215
        _span.extend(int.to_bytes((self.transport_latency_c_to_p << 0), length=3, byteorder='little'))
        if self.transport_latency_p_to_c > 16777215:
            print(f"Invalid value for field LeCisEstablishedV1::transport_latency_p_to_c: {self.transport_latency_p_to_c} > 16777215; the value will be truncated")
            self.transport_latency_p_to_c &= 16777215
        _span.extend(int.to_bytes((self.transport_latency_p_to_c << 0), length=3, byteorder='little'))
        _span.append((self.phy_c_to_p << 0))
        _span.append((self.phy_p_to_c << 0))
        if self.nse > 255:
            print(f"Invalid value for field LeCisEstablishedV1::nse: {self.nse} > 255; the value will be truncated")
            self.nse &= 255
        _span.append((self.nse << 0))
        if self.bn_c_to_p > 15:
            print(f"Invalid value for field LeCisEstablishedV1::bn_c_to_p: {self.bn_c_to_p} > 15; the value will be truncated")
            self.bn_c_to_p &= 15
        _span.append((self.bn_c_to_p << 0))
        if self.bn_p_to_c > 15:
            print(f"Invalid value for field LeCisEstablishedV1::bn_p_to_c: {self.bn_p_to_c} > 15; the value will be truncated")
            self.bn_p_to_c &= 15
        _span.append((self.bn_p_to_c << 0))
        if self.ft_c_to_p > 255:
            print(f"Invalid value for field LeCisEstablishedV1::ft_c_to_p: {self.ft_c_to_p} > 255; the value will be truncated")
            self.ft_c_to_p &= 255
        _span.append((self.ft_c_to_p << 0))
        if self.ft_p_to_c > 255:
            print(f"Invalid value for field LeCisEstablishedV1::ft_p_to_c: {self.ft_p_to_c} > 255; the value will be truncated")
            self.ft_p_to_c &= 255
        _span.append((self.ft_p_to_c << 0))
        if self.max_pdu_c_to_p > 255:
            print(f"Invalid value for field LeCisEstablishedV1::max_pdu_c_to_p: {self.max_pdu_c_to_p} > 255; the value will be truncated")
            self.max_pdu_c_to_p &= 255
        _span.append((self.max_pdu_c_to_p << 0))
        _span.extend([0] * 1)
        if self.max_pdu_p_to_c > 255:
            print(f"Invalid value for field LeCisEstablishedV1::max_pdu_p_to_c: {self.max_pdu_p_to_c} > 255; the value will be truncated")
            self.max_pdu_p_to_c &= 255
        _span.append((self.max_pdu_p_to_c << 0))
        _span.extend([0] * 1)
        if self.iso_interval > 65535:
            print(f"Invalid value for field LeCisEstablishedV1::iso_interval: {self.iso_interval} > 65535; the value will be truncated")
            self.iso_interval &= 65535
        _span.extend(int.to_bytes((self.iso_interval << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 28

@dataclass
class LeCisEstablishedV2(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    cig_sync_delay: int = field(kw_only=True, default=0)
    cis_sync_delay: int = field(kw_only=True, default=0)
    transport_latency_c_to_p: int = field(kw_only=True, default=0)
    transport_latency_p_to_c: int = field(kw_only=True, default=0)
    phy_c_to_p: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    phy_p_to_c: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    nse: int = field(kw_only=True, default=0)
    bn_c_to_p: int = field(kw_only=True, default=0)
    bn_p_to_c: int = field(kw_only=True, default=0)
    ft_c_to_p: int = field(kw_only=True, default=0)
    ft_p_to_c: int = field(kw_only=True, default=0)
    max_pdu_c_to_p: int = field(kw_only=True, default=0)
    max_pdu_p_to_c: int = field(kw_only=True, default=0)
    iso_interval: int = field(kw_only=True, default=0)
    sub_interval: int = field(kw_only=True, default=0)
    max_sdu_c_to_p: int = field(kw_only=True, default=0)
    max_sdu_p_to_c: int = field(kw_only=True, default=0)
    sdu_interval_c_to_p: int = field(kw_only=True, default=0)
    sdu_interval_p_to_c: int = field(kw_only=True, default=0)
    framing: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CIS_ESTABLISHED_V2
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCisEstablishedV2', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CIS_ESTABLISHED_V2:
            raise Exception("Invalid constraint field values")
        if len(span) < 42:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:6], byteorder='little')
        fields['cig_sync_delay'] = value_
        value_ = int.from_bytes(span[6:9], byteorder='little')
        fields['cis_sync_delay'] = value_
        value_ = int.from_bytes(span[9:12], byteorder='little')
        fields['transport_latency_c_to_p'] = value_
        value_ = int.from_bytes(span[12:15], byteorder='little')
        fields['transport_latency_p_to_c'] = value_
        fields['phy_c_to_p'] = SecondaryPhyType(span[15])
        fields['phy_p_to_c'] = SecondaryPhyType(span[16])
        fields['nse'] = span[17]
        fields['bn_c_to_p'] = (span[18] >> 0) & 0xf
        fields['bn_p_to_c'] = (span[19] >> 0) & 0xf
        fields['ft_c_to_p'] = span[20]
        fields['ft_p_to_c'] = span[21]
        fields['max_pdu_c_to_p'] = span[22]
        fields['max_pdu_p_to_c'] = span[24]
        value_ = int.from_bytes(span[26:28], byteorder='little')
        fields['iso_interval'] = value_
        value_ = int.from_bytes(span[28:31], byteorder='little')
        fields['sub_interval'] = value_
        value_ = int.from_bytes(span[31:33], byteorder='little')
        fields['max_sdu_c_to_p'] = value_
        value_ = int.from_bytes(span[33:35], byteorder='little')
        fields['max_sdu_p_to_c'] = value_
        value_ = int.from_bytes(span[35:38], byteorder='little')
        fields['sdu_interval_c_to_p'] = value_
        value_ = int.from_bytes(span[38:41], byteorder='little')
        fields['sdu_interval_p_to_c'] = value_
        fields['framing'] = Enable(span[41])
        span = span[42:]
        return LeCisEstablishedV2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeCisEstablishedV2::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.cig_sync_delay > 16777215:
            print(f"Invalid value for field LeCisEstablishedV2::cig_sync_delay: {self.cig_sync_delay} > 16777215; the value will be truncated")
            self.cig_sync_delay &= 16777215
        _span.extend(int.to_bytes((self.cig_sync_delay << 0), length=3, byteorder='little'))
        if self.cis_sync_delay > 16777215:
            print(f"Invalid value for field LeCisEstablishedV2::cis_sync_delay: {self.cis_sync_delay} > 16777215; the value will be truncated")
            self.cis_sync_delay &= 16777215
        _span.extend(int.to_bytes((self.cis_sync_delay << 0), length=3, byteorder='little'))
        if self.transport_latency_c_to_p > 16777215:
            print(f"Invalid value for field LeCisEstablishedV2::transport_latency_c_to_p: {self.transport_latency_c_to_p} > 16777215; the value will be truncated")
            self.transport_latency_c_to_p &= 16777215
        _span.extend(int.to_bytes((self.transport_latency_c_to_p << 0), length=3, byteorder='little'))
        if self.transport_latency_p_to_c > 16777215:
            print(f"Invalid value for field LeCisEstablishedV2::transport_latency_p_to_c: {self.transport_latency_p_to_c} > 16777215; the value will be truncated")
            self.transport_latency_p_to_c &= 16777215
        _span.extend(int.to_bytes((self.transport_latency_p_to_c << 0), length=3, byteorder='little'))
        _span.append((self.phy_c_to_p << 0))
        _span.append((self.phy_p_to_c << 0))
        if self.nse > 255:
            print(f"Invalid value for field LeCisEstablishedV2::nse: {self.nse} > 255; the value will be truncated")
            self.nse &= 255
        _span.append((self.nse << 0))
        if self.bn_c_to_p > 15:
            print(f"Invalid value for field LeCisEstablishedV2::bn_c_to_p: {self.bn_c_to_p} > 15; the value will be truncated")
            self.bn_c_to_p &= 15
        _span.append((self.bn_c_to_p << 0))
        if self.bn_p_to_c > 15:
            print(f"Invalid value for field LeCisEstablishedV2::bn_p_to_c: {self.bn_p_to_c} > 15; the value will be truncated")
            self.bn_p_to_c &= 15
        _span.append((self.bn_p_to_c << 0))
        if self.ft_c_to_p > 255:
            print(f"Invalid value for field LeCisEstablishedV2::ft_c_to_p: {self.ft_c_to_p} > 255; the value will be truncated")
            self.ft_c_to_p &= 255
        _span.append((self.ft_c_to_p << 0))
        if self.ft_p_to_c > 255:
            print(f"Invalid value for field LeCisEstablishedV2::ft_p_to_c: {self.ft_p_to_c} > 255; the value will be truncated")
            self.ft_p_to_c &= 255
        _span.append((self.ft_p_to_c << 0))
        if self.max_pdu_c_to_p > 255:
            print(f"Invalid value for field LeCisEstablishedV2::max_pdu_c_to_p: {self.max_pdu_c_to_p} > 255; the value will be truncated")
            self.max_pdu_c_to_p &= 255
        _span.append((self.max_pdu_c_to_p << 0))
        _span.extend([0] * 1)
        if self.max_pdu_p_to_c > 255:
            print(f"Invalid value for field LeCisEstablishedV2::max_pdu_p_to_c: {self.max_pdu_p_to_c} > 255; the value will be truncated")
            self.max_pdu_p_to_c &= 255
        _span.append((self.max_pdu_p_to_c << 0))
        _span.extend([0] * 1)
        if self.iso_interval > 65535:
            print(f"Invalid value for field LeCisEstablishedV2::iso_interval: {self.iso_interval} > 65535; the value will be truncated")
            self.iso_interval &= 65535
        _span.extend(int.to_bytes((self.iso_interval << 0), length=2, byteorder='little'))
        if self.sub_interval > 16777215:
            print(f"Invalid value for field LeCisEstablishedV2::sub_interval: {self.sub_interval} > 16777215; the value will be truncated")
            self.sub_interval &= 16777215
        _span.extend(int.to_bytes((self.sub_interval << 0), length=3, byteorder='little'))
        if self.max_sdu_c_to_p > 65535:
            print(f"Invalid value for field LeCisEstablishedV2::max_sdu_c_to_p: {self.max_sdu_c_to_p} > 65535; the value will be truncated")
            self.max_sdu_c_to_p &= 65535
        _span.extend(int.to_bytes((self.max_sdu_c_to_p << 0), length=2, byteorder='little'))
        if self.max_sdu_p_to_c > 65535:
            print(f"Invalid value for field LeCisEstablishedV2::max_sdu_p_to_c: {self.max_sdu_p_to_c} > 65535; the value will be truncated")
            self.max_sdu_p_to_c &= 65535
        _span.extend(int.to_bytes((self.max_sdu_p_to_c << 0), length=2, byteorder='little'))
        if self.sdu_interval_c_to_p > 16777215:
            print(f"Invalid value for field LeCisEstablishedV2::sdu_interval_c_to_p: {self.sdu_interval_c_to_p} > 16777215; the value will be truncated")
            self.sdu_interval_c_to_p &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval_c_to_p << 0), length=3, byteorder='little'))
        if self.sdu_interval_p_to_c > 16777215:
            print(f"Invalid value for field LeCisEstablishedV2::sdu_interval_p_to_c: {self.sdu_interval_p_to_c} > 16777215; the value will be truncated")
            self.sdu_interval_p_to_c &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval_p_to_c << 0), length=3, byteorder='little'))
        _span.append((self.framing << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 42

@dataclass
class LeCisRequest(LeMetaEvent):
    acl_connection_handle: int = field(kw_only=True, default=0)
    cis_connection_handle: int = field(kw_only=True, default=0)
    cig_id: int = field(kw_only=True, default=0)
    cis_id: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CIS_REQUEST
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCisRequest', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CIS_REQUEST:
            raise Exception("Invalid constraint field values")
        if len(span) < 6:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['acl_connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['cis_connection_handle'] = (value_ >> 0) & 0xfff
        fields['cig_id'] = span[4]
        fields['cis_id'] = span[5]
        span = span[6:]
        return LeCisRequest(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.acl_connection_handle > 4095:
            print(f"Invalid value for field LeCisRequest::acl_connection_handle: {self.acl_connection_handle} > 4095; the value will be truncated")
            self.acl_connection_handle &= 4095
        _span.extend(int.to_bytes((self.acl_connection_handle << 0), length=2, byteorder='little'))
        if self.cis_connection_handle > 4095:
            print(f"Invalid value for field LeCisRequest::cis_connection_handle: {self.cis_connection_handle} > 4095; the value will be truncated")
            self.cis_connection_handle &= 4095
        _span.extend(int.to_bytes((self.cis_connection_handle << 0), length=2, byteorder='little'))
        if self.cig_id > 255:
            print(f"Invalid value for field LeCisRequest::cig_id: {self.cig_id} > 255; the value will be truncated")
            self.cig_id &= 255
        _span.append((self.cig_id << 0))
        if self.cis_id > 255:
            print(f"Invalid value for field LeCisRequest::cis_id: {self.cis_id} > 255; the value will be truncated")
            self.cis_id &= 255
        _span.append((self.cis_id << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 6

@dataclass
class LeCreateBigComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    big_handle: int = field(kw_only=True, default=0)
    big_sync_delay: int = field(kw_only=True, default=0)
    transport_latency_big: int = field(kw_only=True, default=0)
    phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    nse: int = field(kw_only=True, default=0)
    bn: int = field(kw_only=True, default=0)
    pto: int = field(kw_only=True, default=0)
    irc: int = field(kw_only=True, default=0)
    max_pdu: int = field(kw_only=True, default=0)
    iso_interval: int = field(kw_only=True, default=0)
    connection_handle: List[int] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_CREATE_BIG_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeCreateBigComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_CREATE_BIG_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 18:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['big_handle'] = span[1]
        value_ = int.from_bytes(span[2:5], byteorder='little')
        fields['big_sync_delay'] = value_
        value_ = int.from_bytes(span[5:8], byteorder='little')
        fields['transport_latency_big'] = value_
        fields['phy'] = SecondaryPhyType(span[8])
        fields['nse'] = span[9]
        fields['bn'] = span[10]
        fields['pto'] = span[11]
        fields['irc'] = span[12]
        value_ = int.from_bytes(span[13:15], byteorder='little')
        fields['max_pdu'] = value_
        value_ = int.from_bytes(span[15:17], byteorder='little')
        fields['iso_interval'] = value_
        connection_handle_size = span[17]
        span = span[18:]
        if len(span) < connection_handle_size:
            raise Exception('Invalid packet size')
        if connection_handle_size % 2 != 0:
            raise Exception('Array size is not a multiple of the element size')
        connection_handle_count = int(connection_handle_size / 2)
        connection_handle = []
        for n in range(connection_handle_count):
            connection_handle.append(int.from_bytes(span[n * 2:(n + 1) * 2], byteorder='little'))
        fields['connection_handle'] = connection_handle
        span = span[connection_handle_size:]
        return LeCreateBigComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.big_handle > 255:
            print(f"Invalid value for field LeCreateBigComplete::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        if self.big_sync_delay > 16777215:
            print(f"Invalid value for field LeCreateBigComplete::big_sync_delay: {self.big_sync_delay} > 16777215; the value will be truncated")
            self.big_sync_delay &= 16777215
        _span.extend(int.to_bytes((self.big_sync_delay << 0), length=3, byteorder='little'))
        if self.transport_latency_big > 16777215:
            print(f"Invalid value for field LeCreateBigComplete::transport_latency_big: {self.transport_latency_big} > 16777215; the value will be truncated")
            self.transport_latency_big &= 16777215
        _span.extend(int.to_bytes((self.transport_latency_big << 0), length=3, byteorder='little'))
        _span.append((self.phy << 0))
        if self.nse > 255:
            print(f"Invalid value for field LeCreateBigComplete::nse: {self.nse} > 255; the value will be truncated")
            self.nse &= 255
        _span.append((self.nse << 0))
        if self.bn > 255:
            print(f"Invalid value for field LeCreateBigComplete::bn: {self.bn} > 255; the value will be truncated")
            self.bn &= 255
        _span.append((self.bn << 0))
        if self.pto > 255:
            print(f"Invalid value for field LeCreateBigComplete::pto: {self.pto} > 255; the value will be truncated")
            self.pto &= 255
        _span.append((self.pto << 0))
        if self.irc > 255:
            print(f"Invalid value for field LeCreateBigComplete::irc: {self.irc} > 255; the value will be truncated")
            self.irc &= 255
        _span.append((self.irc << 0))
        if self.max_pdu > 65535:
            print(f"Invalid value for field LeCreateBigComplete::max_pdu: {self.max_pdu} > 65535; the value will be truncated")
            self.max_pdu &= 65535
        _span.extend(int.to_bytes((self.max_pdu << 0), length=2, byteorder='little'))
        if self.iso_interval > 65535:
            print(f"Invalid value for field LeCreateBigComplete::iso_interval: {self.iso_interval} > 65535; the value will be truncated")
            self.iso_interval &= 65535
        _span.extend(int.to_bytes((self.iso_interval << 0), length=2, byteorder='little'))
        _span.append(((len(self.connection_handle) * 2) << 0))
        for _elt in self.connection_handle:
            _span.extend(int.to_bytes(_elt, length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.connection_handle) * 2 + 18

@dataclass
class LeTerminateBigComplete(LeMetaEvent):
    big_handle: int = field(kw_only=True, default=0)
    reason: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_TERMINATE_BIG_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTerminateBigComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_TERMINATE_BIG_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['big_handle'] = span[0]
        fields['reason'] = ErrorCode(span[1])
        span = span[2:]
        return LeTerminateBigComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.big_handle > 255:
            print(f"Invalid value for field LeTerminateBigComplete::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        _span.append((self.reason << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeBigSyncEstablished(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    big_handle: int = field(kw_only=True, default=0)
    transport_latency_big: int = field(kw_only=True, default=0)
    nse: int = field(kw_only=True, default=0)
    bn: int = field(kw_only=True, default=0)
    pto: int = field(kw_only=True, default=0)
    irc: int = field(kw_only=True, default=0)
    max_pdu: int = field(kw_only=True, default=0)
    iso_interval: int = field(kw_only=True, default=0)
    connection_handle: List[int] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_BIG_SYNC_ESTABLISHED
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBigSyncEstablished', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_BIG_SYNC_ESTABLISHED:
            raise Exception("Invalid constraint field values")
        if len(span) < 14:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['big_handle'] = span[1]
        value_ = int.from_bytes(span[2:5], byteorder='little')
        fields['transport_latency_big'] = value_
        fields['nse'] = span[5]
        fields['bn'] = span[6]
        fields['pto'] = span[7]
        fields['irc'] = span[8]
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['max_pdu'] = value_
        value_ = int.from_bytes(span[11:13], byteorder='little')
        fields['iso_interval'] = value_
        connection_handle_size = span[13]
        span = span[14:]
        if len(span) < connection_handle_size:
            raise Exception('Invalid packet size')
        if connection_handle_size % 2 != 0:
            raise Exception('Array size is not a multiple of the element size')
        connection_handle_count = int(connection_handle_size / 2)
        connection_handle = []
        for n in range(connection_handle_count):
            connection_handle.append(int.from_bytes(span[n * 2:(n + 1) * 2], byteorder='little'))
        fields['connection_handle'] = connection_handle
        span = span[connection_handle_size:]
        return LeBigSyncEstablished(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.big_handle > 255:
            print(f"Invalid value for field LeBigSyncEstablished::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        if self.transport_latency_big > 16777215:
            print(f"Invalid value for field LeBigSyncEstablished::transport_latency_big: {self.transport_latency_big} > 16777215; the value will be truncated")
            self.transport_latency_big &= 16777215
        _span.extend(int.to_bytes((self.transport_latency_big << 0), length=3, byteorder='little'))
        if self.nse > 255:
            print(f"Invalid value for field LeBigSyncEstablished::nse: {self.nse} > 255; the value will be truncated")
            self.nse &= 255
        _span.append((self.nse << 0))
        if self.bn > 255:
            print(f"Invalid value for field LeBigSyncEstablished::bn: {self.bn} > 255; the value will be truncated")
            self.bn &= 255
        _span.append((self.bn << 0))
        if self.pto > 255:
            print(f"Invalid value for field LeBigSyncEstablished::pto: {self.pto} > 255; the value will be truncated")
            self.pto &= 255
        _span.append((self.pto << 0))
        if self.irc > 255:
            print(f"Invalid value for field LeBigSyncEstablished::irc: {self.irc} > 255; the value will be truncated")
            self.irc &= 255
        _span.append((self.irc << 0))
        if self.max_pdu > 65535:
            print(f"Invalid value for field LeBigSyncEstablished::max_pdu: {self.max_pdu} > 65535; the value will be truncated")
            self.max_pdu &= 65535
        _span.extend(int.to_bytes((self.max_pdu << 0), length=2, byteorder='little'))
        if self.iso_interval > 65535:
            print(f"Invalid value for field LeBigSyncEstablished::iso_interval: {self.iso_interval} > 65535; the value will be truncated")
            self.iso_interval &= 65535
        _span.extend(int.to_bytes((self.iso_interval << 0), length=2, byteorder='little'))
        _span.append(((len(self.connection_handle) * 2) << 0))
        for _elt in self.connection_handle:
            _span.extend(int.to_bytes(_elt, length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.connection_handle) * 2 + 14

@dataclass
class LeBigSyncLost(LeMetaEvent):
    big_handle: int = field(kw_only=True, default=0)
    reason: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_BIG_SYNC_LOST
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBigSyncLost', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_BIG_SYNC_LOST:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['big_handle'] = span[0]
        fields['reason'] = ErrorCode(span[1])
        span = span[2:]
        return LeBigSyncLost(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.big_handle > 255:
            print(f"Invalid value for field LeBigSyncLost::big_handle: {self.big_handle} > 255; the value will be truncated")
            self.big_handle &= 255
        _span.append((self.big_handle << 0))
        _span.append((self.reason << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeRequestPeerScaComplete(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    peer_clock_accuracy: ClockAccuracy = field(kw_only=True, default=ClockAccuracy.PPM_500)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_REQUEST_PEER_SCA_COMPLETE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeRequestPeerScaComplete', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_REQUEST_PEER_SCA_COMPLETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['peer_clock_accuracy'] = ClockAccuracy(span[3])
        span = span[4:]
        return LeRequestPeerScaComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeRequestPeerScaComplete::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.peer_clock_accuracy << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

class PathLossZone(enum.IntEnum):
    LOW = 0x0
    MID = 0x1
    HIGH = 0x2

@dataclass
class LePathLossThreshold(LeMetaEvent):
    connection_handle: int = field(kw_only=True, default=0)
    current_path_loss: int = field(kw_only=True, default=0)
    zone_entered: PathLossZone = field(kw_only=True, default=PathLossZone.LOW)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_PATH_LOSS_THRESHOLD
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LePathLossThreshold', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_PATH_LOSS_THRESHOLD:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['current_path_loss'] = span[2]
        fields['zone_entered'] = PathLossZone(span[3])
        span = span[4:]
        return LePathLossThreshold(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field LePathLossThreshold::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.current_path_loss > 255:
            print(f"Invalid value for field LePathLossThreshold::current_path_loss: {self.current_path_loss} > 255; the value will be truncated")
            self.current_path_loss &= 255
        _span.append((self.current_path_loss << 0))
        _span.append((self.zone_entered << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

class ReportingReason(enum.IntEnum):
    LOCAL_TRANSMIT_POWER_CHANGED = 0x0
    REMOTE_TRANSMIT_POWER_CHANGED = 0x1
    READ_COMMAND_COMPLETE = 0x2

@dataclass
class LeTransmitPowerReporting(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    reason: ReportingReason = field(kw_only=True, default=ReportingReason.LOCAL_TRANSMIT_POWER_CHANGED)
    phy: int = field(kw_only=True, default=0)
    transmit_power_level: int = field(kw_only=True, default=0)
    transmit_power_level_flag: int = field(kw_only=True, default=0)
    delta: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_TRANSMIT_POWER_REPORTING
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeTransmitPowerReporting', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_TRANSMIT_POWER_REPORTING:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['reason'] = ReportingReason(span[3])
        fields['phy'] = span[4]
        fields['transmit_power_level'] = span[5]
        fields['transmit_power_level_flag'] = span[6]
        fields['delta'] = span[7]
        span = span[8:]
        return LeTransmitPowerReporting(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeTransmitPowerReporting::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        _span.append((self.reason << 0))
        if self.phy > 255:
            print(f"Invalid value for field LeTransmitPowerReporting::phy: {self.phy} > 255; the value will be truncated")
            self.phy &= 255
        _span.append((self.phy << 0))
        if self.transmit_power_level > 255:
            print(f"Invalid value for field LeTransmitPowerReporting::transmit_power_level: {self.transmit_power_level} > 255; the value will be truncated")
            self.transmit_power_level &= 255
        _span.append((self.transmit_power_level << 0))
        if self.transmit_power_level_flag > 255:
            print(f"Invalid value for field LeTransmitPowerReporting::transmit_power_level_flag: {self.transmit_power_level_flag} > 255; the value will be truncated")
            self.transmit_power_level_flag &= 255
        _span.append((self.transmit_power_level_flag << 0))
        if self.delta > 255:
            print(f"Invalid value for field LeTransmitPowerReporting::delta: {self.delta} > 255; the value will be truncated")
            self.delta &= 255
        _span.append((self.delta << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeBigInfoAdvertisingReport(LeMetaEvent):
    sync_handle: int = field(kw_only=True, default=0)
    num_bis: int = field(kw_only=True, default=0)
    nse: int = field(kw_only=True, default=0)
    iso_interval: int = field(kw_only=True, default=0)
    bn: int = field(kw_only=True, default=0)
    pto: int = field(kw_only=True, default=0)
    irc: int = field(kw_only=True, default=0)
    max_pdu: int = field(kw_only=True, default=0)
    sdu_interval: int = field(kw_only=True, default=0)
    max_sdu: int = field(kw_only=True, default=0)
    phy: SecondaryPhyType = field(kw_only=True, default=SecondaryPhyType.NO_PACKETS)
    framing: Enable = field(kw_only=True, default=Enable.DISABLED)
    encryption: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_BIG_INFO_ADVERTISING_REPORT
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBigInfoAdvertisingReport', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_BIG_INFO_ADVERTISING_REPORT:
            raise Exception("Invalid constraint field values")
        if len(span) < 19:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['sync_handle'] = (value_ >> 0) & 0xfff
        fields['num_bis'] = span[2]
        fields['nse'] = span[3]
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['iso_interval'] = value_
        fields['bn'] = span[6]
        fields['pto'] = span[7]
        fields['irc'] = span[8]
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['max_pdu'] = value_
        value_ = int.from_bytes(span[11:14], byteorder='little')
        fields['sdu_interval'] = value_
        value_ = int.from_bytes(span[14:16], byteorder='little')
        fields['max_sdu'] = value_
        fields['phy'] = SecondaryPhyType(span[16])
        fields['framing'] = Enable(span[17])
        fields['encryption'] = Enable(span[18])
        span = span[19:]
        return LeBigInfoAdvertisingReport(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.sync_handle > 4095:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::sync_handle: {self.sync_handle} > 4095; the value will be truncated")
            self.sync_handle &= 4095
        _span.extend(int.to_bytes((self.sync_handle << 0), length=2, byteorder='little'))
        if self.num_bis > 255:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::num_bis: {self.num_bis} > 255; the value will be truncated")
            self.num_bis &= 255
        _span.append((self.num_bis << 0))
        if self.nse > 255:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::nse: {self.nse} > 255; the value will be truncated")
            self.nse &= 255
        _span.append((self.nse << 0))
        if self.iso_interval > 65535:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::iso_interval: {self.iso_interval} > 65535; the value will be truncated")
            self.iso_interval &= 65535
        _span.extend(int.to_bytes((self.iso_interval << 0), length=2, byteorder='little'))
        if self.bn > 255:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::bn: {self.bn} > 255; the value will be truncated")
            self.bn &= 255
        _span.append((self.bn << 0))
        if self.pto > 255:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::pto: {self.pto} > 255; the value will be truncated")
            self.pto &= 255
        _span.append((self.pto << 0))
        if self.irc > 255:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::irc: {self.irc} > 255; the value will be truncated")
            self.irc &= 255
        _span.append((self.irc << 0))
        if self.max_pdu > 65535:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::max_pdu: {self.max_pdu} > 65535; the value will be truncated")
            self.max_pdu &= 65535
        _span.extend(int.to_bytes((self.max_pdu << 0), length=2, byteorder='little'))
        if self.sdu_interval > 16777215:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::sdu_interval: {self.sdu_interval} > 16777215; the value will be truncated")
            self.sdu_interval &= 16777215
        _span.extend(int.to_bytes((self.sdu_interval << 0), length=3, byteorder='little'))
        if self.max_sdu > 65535:
            print(f"Invalid value for field LeBigInfoAdvertisingReport::max_sdu: {self.max_sdu} > 65535; the value will be truncated")
            self.max_sdu &= 65535
        _span.extend(int.to_bytes((self.max_sdu << 0), length=2, byteorder='little'))
        _span.append((self.phy << 0))
        _span.append((self.framing << 0))
        _span.append((self.encryption << 0))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 19

@dataclass
class LeSubrateChange(LeMetaEvent):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    connection_handle: int = field(kw_only=True, default=0)
    subrate_factor: int = field(kw_only=True, default=0)
    peripheral_latency: int = field(kw_only=True, default=0)
    continuation_number: int = field(kw_only=True, default=0)
    supervision_timeout: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subevent_code = SubeventCode.LE_SUBRATE_CHANGE
        self.event_code = EventCode.LE_META_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeSubrateChange', bytes]:
        if fields['subevent_code'] != SubeventCode.LE_SUBRATE_CHANGE:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['subrate_factor'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[5:7], byteorder='little')
        fields['peripheral_latency'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[7:9], byteorder='little')
        fields['continuation_number'] = (value_ >> 0) & 0x1ff
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['supervision_timeout'] = (value_ >> 0) & 0xfff
        span = span[11:]
        return LeSubrateChange(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 4095:
            print(f"Invalid value for field LeSubrateChange::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.subrate_factor > 511:
            print(f"Invalid value for field LeSubrateChange::subrate_factor: {self.subrate_factor} > 511; the value will be truncated")
            self.subrate_factor &= 511
        _span.extend(int.to_bytes((self.subrate_factor << 0), length=2, byteorder='little'))
        if self.peripheral_latency > 511:
            print(f"Invalid value for field LeSubrateChange::peripheral_latency: {self.peripheral_latency} > 511; the value will be truncated")
            self.peripheral_latency &= 511
        _span.extend(int.to_bytes((self.peripheral_latency << 0), length=2, byteorder='little'))
        if self.continuation_number > 511:
            print(f"Invalid value for field LeSubrateChange::continuation_number: {self.continuation_number} > 511; the value will be truncated")
            self.continuation_number &= 511
        _span.extend(int.to_bytes((self.continuation_number << 0), length=2, byteorder='little'))
        if self.supervision_timeout > 4095:
            print(f"Invalid value for field LeSubrateChange::supervision_timeout: {self.supervision_timeout} > 4095; the value will be truncated")
            self.supervision_timeout &= 4095
        _span.extend(int.to_bytes((self.supervision_timeout << 0), length=2, byteorder='little'))
        return LeMetaEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

class IsoPacketBoundaryFlag(enum.IntEnum):
    FIRST_FRAGMENT = 0x0
    CONTINUATION_FRAGMENT = 0x1
    COMPLETE_SDU = 0x2
    LAST_FRAGMENT = 0x3

class TimeStampFlag(enum.IntEnum):
    NOT_PRESENT = 0x0
    PRESENT = 0x1

@dataclass
class Iso(Packet):
    connection_handle: int = field(kw_only=True, default=0)
    pb_flag: IsoPacketBoundaryFlag = field(kw_only=True, default=IsoPacketBoundaryFlag.FIRST_FRAGMENT)
    ts_flag: TimeStampFlag = field(kw_only=True, default=TimeStampFlag.NOT_PRESENT)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['Iso', bytes]:
        fields = {'payload': None}
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['connection_handle'] = (value_ >> 0) & 0xfff
        fields['pb_flag'] = IsoPacketBoundaryFlag((value_ >> 12) & 0x3)
        fields['ts_flag'] = TimeStampFlag((value_ >> 14) & 0x1)
        value_ = int.from_bytes(span[2:4], byteorder='little')
        _payload__size = (value_ >> 0) & 0x3fff
        span = span[4:]
        if len(span) < _payload__size:
            raise Exception('Invalid packet size')
        payload = span[:_payload__size]
        span = span[_payload__size:]
        fields['payload'] = payload
        try:
            return IsoWithTimestamp.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return IsoWithoutTimestamp.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return Iso(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.connection_handle > 4095:
            print(f"Invalid value for field Iso::connection_handle: {self.connection_handle} > 4095; the value will be truncated")
            self.connection_handle &= 4095
        _value = (
            (self.connection_handle << 0) |
            (self.pb_flag << 12) |
            (self.ts_flag << 14)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        _payload_size = len(payload or self.payload or [])
        if _payload_size > 16383:
            print(f"Invalid length for payload field:  {_payload_size} > 16383; the packet cannot be generated")
            raise Exception("Invalid payload length")
        _span.extend(int.to_bytes((_payload_size << 0), length=2, byteorder='little'))
        _span.extend(payload or self.payload or [])
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.payload) + 4

class IsoPacketStatusFlag(enum.IntEnum):
    VALID = 0x0
    POSSIBLY_INVALID = 0x1
    LOST_DATA = 0x2

@dataclass
class IsoWithTimestamp(Iso):
    time_stamp: int = field(kw_only=True, default=0)
    packet_sequence_number: int = field(kw_only=True, default=0)
    iso_sdu_length: int = field(kw_only=True, default=0)
    packet_status_flag: IsoPacketStatusFlag = field(kw_only=True, default=IsoPacketStatusFlag.VALID)

    def __post_init__(self):
        self.ts_flag = TimeStampFlag.PRESENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IsoWithTimestamp', bytes]:
        if fields['ts_flag'] != TimeStampFlag.PRESENT:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:4], byteorder='little')
        fields['time_stamp'] = value_
        value_ = int.from_bytes(span[4:6], byteorder='little')
        fields['packet_sequence_number'] = value_
        value_ = int.from_bytes(span[6:8], byteorder='little')
        fields['iso_sdu_length'] = (value_ >> 0) & 0xfff
        fields['packet_status_flag'] = IsoPacketStatusFlag((value_ >> 14) & 0x3)
        span = span[8:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        return IsoWithTimestamp(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.time_stamp > 4294967295:
            print(f"Invalid value for field IsoWithTimestamp::time_stamp: {self.time_stamp} > 4294967295; the value will be truncated")
            self.time_stamp &= 4294967295
        _span.extend(int.to_bytes((self.time_stamp << 0), length=4, byteorder='little'))
        if self.packet_sequence_number > 65535:
            print(f"Invalid value for field IsoWithTimestamp::packet_sequence_number: {self.packet_sequence_number} > 65535; the value will be truncated")
            self.packet_sequence_number &= 65535
        _span.extend(int.to_bytes((self.packet_sequence_number << 0), length=2, byteorder='little'))
        if self.iso_sdu_length > 4095:
            print(f"Invalid value for field IsoWithTimestamp::iso_sdu_length: {self.iso_sdu_length} > 4095; the value will be truncated")
            self.iso_sdu_length &= 4095
        _value = (
            (self.iso_sdu_length << 0) |
            (self.packet_status_flag << 14)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        _span.extend(payload or self.payload or [])
        return Iso.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 8

@dataclass
class IsoWithoutTimestamp(Iso):
    packet_sequence_number: int = field(kw_only=True, default=0)
    iso_sdu_length: int = field(kw_only=True, default=0)
    packet_status_flag: IsoPacketStatusFlag = field(kw_only=True, default=IsoPacketStatusFlag.VALID)

    def __post_init__(self):
        self.ts_flag = TimeStampFlag.NOT_PRESENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['IsoWithoutTimestamp', bytes]:
        if fields['ts_flag'] != TimeStampFlag.NOT_PRESENT:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['packet_sequence_number'] = value_
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['iso_sdu_length'] = (value_ >> 0) & 0xfff
        fields['packet_status_flag'] = IsoPacketStatusFlag((value_ >> 14) & 0x3)
        span = span[4:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        return IsoWithoutTimestamp(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.packet_sequence_number > 65535:
            print(f"Invalid value for field IsoWithoutTimestamp::packet_sequence_number: {self.packet_sequence_number} > 65535; the value will be truncated")
            self.packet_sequence_number &= 65535
        _span.extend(int.to_bytes((self.packet_sequence_number << 0), length=2, byteorder='little'))
        if self.iso_sdu_length > 4095:
            print(f"Invalid value for field IsoWithoutTimestamp::iso_sdu_length: {self.iso_sdu_length} > 4095; the value will be truncated")
            self.iso_sdu_length &= 4095
        _value = (
            (self.iso_sdu_length << 0) |
            (self.packet_status_flag << 14)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        _span.extend(payload or self.payload or [])
        return Iso.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 4

class GapDataType(enum.IntEnum):
    INVALID = 0x0
    FLAGS = 0x1
    INCOMPLETE_LIST_16_BIT_UUIDS = 0x2
    COMPLETE_LIST_16_BIT_UUIDS = 0x3
    INCOMPLETE_LIST_32_BIT_UUIDS = 0x4
    COMPLETE_LIST_32_BIT_UUIDS = 0x5
    INCOMPLETE_LIST_128_BIT_UUIDS = 0x6
    COMPLETE_LIST_128_BIT_UUIDS = 0x7
    SHORTENED_LOCAL_NAME = 0x8
    COMPLETE_LOCAL_NAME = 0x9
    TX_POWER_LEVEL = 0xa
    CLASS_OF_DEVICE = 0xd
    SIMPLE_PAIRING_HASH_C = 0xe
    SIMPLE_PAIRING_RANDOMIZER_R = 0xf
    DEVICE_ID = 0x10
    SECURITY_MANAGER_OOB_FLAGS = 0x11
    SLAVE_CONNECTION_INTERVAL_RANGE = 0x12
    LIST_16BIT_SERVICE_SOLICITATION_UUIDS = 0x14
    LIST_128BIT_SERVICE_SOLICITATION_UUIDS = 0x15
    SERVICE_DATA_16_BIT_UUIDS = 0x16
    PUBLIC_TARGET_ADDRESS = 0x17
    RANDOM_TARGET_ADDRESS = 0x18
    APPEARANCE = 0x19
    ADVERTISING_INTERVAL = 0x1a
    LE_BLUETOOTH_DEVICE_ADDRESS = 0x1b
    LE_ROLE = 0x1c
    SIMPLE_PAIRING_HASH_C_256 = 0x1d
    SIMPLE_PAIRING_RANDOMIZER_R_256 = 0x1e
    LIST_32BIT_SERVICE_SOLICITATION_UUIDS = 0x1f
    SERVICE_DATA_32_BIT_UUIDS = 0x20
    SERVICE_DATA_128_BIT_UUIDS = 0x21
    LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE = 0x22
    LE_SECURE_CONNECTIONS_RANDOM_VALUE = 0x23
    URI = 0x24
    INDOOR_POSITIONING = 0x25
    TRANSPORT_DISCOVERY_DATA = 0x26
    LE_SUPPORTED_FEATURES = 0x27
    CHANNEL_MAP_UPDATE_INDICATION = 0x28
    MESH_PB_ADV = 0x29
    MESH_MESSAGE = 0x2a
    MESH_BEACON = 0x2b
    BIG_INFO = 0x2c
    BROADCAST_CODE = 0x2d
    THREE_D_INFORMATION_DATA = 0x3d
    MANUFACTURER_SPECIFIC_DATA = 0xff

@dataclass
class LeGetVendorCapabilities(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_GET_VENDOR_CAPABILITIES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGetVendorCapabilities', bytes]:
        if fields['op_code'] != OpCode.LE_GET_VENDOR_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        return LeGetVendorCapabilities(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeGetVendorCapabilitiesComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    vendor_capabilities: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_GET_VENDOR_CAPABILITIES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGetVendorCapabilitiesComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_GET_VENDOR_CAPABILITIES:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        fields['vendor_capabilities'] = list(span)
        span = bytes()
        return LeGetVendorCapabilitiesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.extend(self.vendor_capabilities)
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.vendor_capabilities) * 1 + 1

@dataclass
class VendorCapabilities_V_0_96(Packet):
    max_advt_instances: int = field(kw_only=True, default=0)
    offloaded_resolution_of_private_address: int = field(kw_only=True, default=0)
    total_scan_results_storage: int = field(kw_only=True, default=0)
    max_irk_list_sz: int = field(kw_only=True, default=0)
    filtering_support: int = field(kw_only=True, default=0)
    max_filter: int = field(kw_only=True, default=0)
    activity_energy_info_support: int = field(kw_only=True, default=0)
    total_num_of_advt_tracked: int = field(kw_only=True, default=0)
    extended_scan_support: int = field(kw_only=True, default=0)
    debug_logging_supported: int = field(kw_only=True, default=0)
    le_address_generation_offloading_support: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['VendorCapabilities_V_0_96', bytes]:
        fields = {'payload': None}
        if len(span) < 15:
            raise Exception('Invalid packet size')
        fields['max_advt_instances'] = span[0]
        fields['offloaded_resolution_of_private_address'] = span[1]
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['total_scan_results_storage'] = value_
        fields['max_irk_list_sz'] = span[4]
        fields['filtering_support'] = span[5]
        fields['max_filter'] = span[6]
        fields['activity_energy_info_support'] = span[7]
        value_ = int.from_bytes(span[8:10], byteorder='little')
        if value_ != 0x60:
            raise Exception('Unexpected fixed field value')
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['total_num_of_advt_tracked'] = value_
        fields['extended_scan_support'] = span[12]
        fields['debug_logging_supported'] = span[13]
        fields['le_address_generation_offloading_support'] = span[14]
        span = span[15:]
        return VendorCapabilities_V_0_96(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.max_advt_instances > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::max_advt_instances: {self.max_advt_instances} > 255; the value will be truncated")
            self.max_advt_instances &= 255
        _span.append((self.max_advt_instances << 0))
        if self.offloaded_resolution_of_private_address > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::offloaded_resolution_of_private_address: {self.offloaded_resolution_of_private_address} > 255; the value will be truncated")
            self.offloaded_resolution_of_private_address &= 255
        _span.append((self.offloaded_resolution_of_private_address << 0))
        if self.total_scan_results_storage > 65535:
            print(f"Invalid value for field VendorCapabilities_V_0_96::total_scan_results_storage: {self.total_scan_results_storage} > 65535; the value will be truncated")
            self.total_scan_results_storage &= 65535
        _span.extend(int.to_bytes((self.total_scan_results_storage << 0), length=2, byteorder='little'))
        if self.max_irk_list_sz > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::max_irk_list_sz: {self.max_irk_list_sz} > 255; the value will be truncated")
            self.max_irk_list_sz &= 255
        _span.append((self.max_irk_list_sz << 0))
        if self.filtering_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::filtering_support: {self.filtering_support} > 255; the value will be truncated")
            self.filtering_support &= 255
        _span.append((self.filtering_support << 0))
        if self.max_filter > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::max_filter: {self.max_filter} > 255; the value will be truncated")
            self.max_filter &= 255
        _span.append((self.max_filter << 0))
        if self.activity_energy_info_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::activity_energy_info_support: {self.activity_energy_info_support} > 255; the value will be truncated")
            self.activity_energy_info_support &= 255
        _span.append((self.activity_energy_info_support << 0))
        _span.extend(int.to_bytes((96 << 0), length=2, byteorder='little'))
        if self.total_num_of_advt_tracked > 65535:
            print(f"Invalid value for field VendorCapabilities_V_0_96::total_num_of_advt_tracked: {self.total_num_of_advt_tracked} > 65535; the value will be truncated")
            self.total_num_of_advt_tracked &= 65535
        _span.extend(int.to_bytes((self.total_num_of_advt_tracked << 0), length=2, byteorder='little'))
        if self.extended_scan_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::extended_scan_support: {self.extended_scan_support} > 255; the value will be truncated")
            self.extended_scan_support &= 255
        _span.append((self.extended_scan_support << 0))
        if self.debug_logging_supported > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::debug_logging_supported: {self.debug_logging_supported} > 255; the value will be truncated")
            self.debug_logging_supported &= 255
        _span.append((self.debug_logging_supported << 0))
        if self.le_address_generation_offloading_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_96::le_address_generation_offloading_support: {self.le_address_generation_offloading_support} > 255; the value will be truncated")
            self.le_address_generation_offloading_support &= 255
        _span.append((self.le_address_generation_offloading_support << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 15

@dataclass
class VendorCapabilities_V_0_98(Packet):
    total_scan_results_storage: int = field(kw_only=True, default=0)
    max_irk_list_sz: int = field(kw_only=True, default=0)
    filtering_support: int = field(kw_only=True, default=0)
    max_filter: int = field(kw_only=True, default=0)
    activity_energy_info_support: int = field(kw_only=True, default=0)
    total_num_of_advt_tracked: int = field(kw_only=True, default=0)
    extended_scan_support: int = field(kw_only=True, default=0)
    debug_logging_supported: int = field(kw_only=True, default=0)
    a2dp_source_offload_capability_mask: int = field(kw_only=True, default=0)
    bluetooth_quality_report_support: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['VendorCapabilities_V_0_98', bytes]:
        fields = {'payload': None}
        if len(span) < 20:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['total_scan_results_storage'] = value_
        fields['max_irk_list_sz'] = span[4]
        fields['filtering_support'] = span[5]
        fields['max_filter'] = span[6]
        fields['activity_energy_info_support'] = span[7]
        value_ = int.from_bytes(span[8:10], byteorder='little')
        if value_ != 0x62:
            raise Exception('Unexpected fixed field value')
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['total_num_of_advt_tracked'] = value_
        fields['extended_scan_support'] = span[12]
        fields['debug_logging_supported'] = span[13]
        value_ = int.from_bytes(span[15:19], byteorder='little')
        fields['a2dp_source_offload_capability_mask'] = value_
        fields['bluetooth_quality_report_support'] = span[19]
        span = span[20:]
        return VendorCapabilities_V_0_98(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend([0] * 1)
        _span.extend([0] * 1)
        if self.total_scan_results_storage > 65535:
            print(f"Invalid value for field VendorCapabilities_V_0_98::total_scan_results_storage: {self.total_scan_results_storage} > 65535; the value will be truncated")
            self.total_scan_results_storage &= 65535
        _span.extend(int.to_bytes((self.total_scan_results_storage << 0), length=2, byteorder='little'))
        if self.max_irk_list_sz > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_98::max_irk_list_sz: {self.max_irk_list_sz} > 255; the value will be truncated")
            self.max_irk_list_sz &= 255
        _span.append((self.max_irk_list_sz << 0))
        if self.filtering_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_98::filtering_support: {self.filtering_support} > 255; the value will be truncated")
            self.filtering_support &= 255
        _span.append((self.filtering_support << 0))
        if self.max_filter > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_98::max_filter: {self.max_filter} > 255; the value will be truncated")
            self.max_filter &= 255
        _span.append((self.max_filter << 0))
        if self.activity_energy_info_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_98::activity_energy_info_support: {self.activity_energy_info_support} > 255; the value will be truncated")
            self.activity_energy_info_support &= 255
        _span.append((self.activity_energy_info_support << 0))
        _span.extend(int.to_bytes((98 << 0), length=2, byteorder='little'))
        if self.total_num_of_advt_tracked > 65535:
            print(f"Invalid value for field VendorCapabilities_V_0_98::total_num_of_advt_tracked: {self.total_num_of_advt_tracked} > 65535; the value will be truncated")
            self.total_num_of_advt_tracked &= 65535
        _span.extend(int.to_bytes((self.total_num_of_advt_tracked << 0), length=2, byteorder='little'))
        if self.extended_scan_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_98::extended_scan_support: {self.extended_scan_support} > 255; the value will be truncated")
            self.extended_scan_support &= 255
        _span.append((self.extended_scan_support << 0))
        if self.debug_logging_supported > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_98::debug_logging_supported: {self.debug_logging_supported} > 255; the value will be truncated")
            self.debug_logging_supported &= 255
        _span.append((self.debug_logging_supported << 0))
        _span.extend([0] * 1)
        if self.a2dp_source_offload_capability_mask > 4294967295:
            print(f"Invalid value for field VendorCapabilities_V_0_98::a2dp_source_offload_capability_mask: {self.a2dp_source_offload_capability_mask} > 4294967295; the value will be truncated")
            self.a2dp_source_offload_capability_mask &= 4294967295
        _span.extend(int.to_bytes((self.a2dp_source_offload_capability_mask << 0), length=4, byteorder='little'))
        if self.bluetooth_quality_report_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_0_98::bluetooth_quality_report_support: {self.bluetooth_quality_report_support} > 255; the value will be truncated")
            self.bluetooth_quality_report_support &= 255
        _span.append((self.bluetooth_quality_report_support << 0))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 20

@dataclass
class VendorCapabilities_V_1_03(Packet):
    total_scan_results_storage: int = field(kw_only=True, default=0)
    max_irk_list_sz: int = field(kw_only=True, default=0)
    filtering_support: int = field(kw_only=True, default=0)
    max_filter: int = field(kw_only=True, default=0)
    activity_energy_info_support: int = field(kw_only=True, default=0)
    total_num_of_advt_tracked: int = field(kw_only=True, default=0)
    extended_scan_support: int = field(kw_only=True, default=0)
    debug_logging_supported: int = field(kw_only=True, default=0)
    a2dp_source_offload_capability_mask: int = field(kw_only=True, default=0)
    bluetooth_quality_report_support: int = field(kw_only=True, default=0)
    dynamic_audio_buffer_support: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['VendorCapabilities_V_1_03', bytes]:
        fields = {'payload': None}
        if len(span) < 24:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['total_scan_results_storage'] = value_
        fields['max_irk_list_sz'] = span[4]
        fields['filtering_support'] = span[5]
        fields['max_filter'] = span[6]
        fields['activity_energy_info_support'] = span[7]
        value_ = int.from_bytes(span[8:10], byteorder='little')
        if value_ != 0x103:
            raise Exception('Unexpected fixed field value')
        value_ = int.from_bytes(span[10:12], byteorder='little')
        fields['total_num_of_advt_tracked'] = value_
        fields['extended_scan_support'] = span[12]
        fields['debug_logging_supported'] = span[13]
        value_ = int.from_bytes(span[15:19], byteorder='little')
        fields['a2dp_source_offload_capability_mask'] = value_
        fields['bluetooth_quality_report_support'] = span[19]
        value_ = int.from_bytes(span[20:24], byteorder='little')
        fields['dynamic_audio_buffer_support'] = value_
        span = span[24:]
        return VendorCapabilities_V_1_03(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend([0] * 1)
        _span.extend([0] * 1)
        if self.total_scan_results_storage > 65535:
            print(f"Invalid value for field VendorCapabilities_V_1_03::total_scan_results_storage: {self.total_scan_results_storage} > 65535; the value will be truncated")
            self.total_scan_results_storage &= 65535
        _span.extend(int.to_bytes((self.total_scan_results_storage << 0), length=2, byteorder='little'))
        if self.max_irk_list_sz > 255:
            print(f"Invalid value for field VendorCapabilities_V_1_03::max_irk_list_sz: {self.max_irk_list_sz} > 255; the value will be truncated")
            self.max_irk_list_sz &= 255
        _span.append((self.max_irk_list_sz << 0))
        if self.filtering_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_1_03::filtering_support: {self.filtering_support} > 255; the value will be truncated")
            self.filtering_support &= 255
        _span.append((self.filtering_support << 0))
        if self.max_filter > 255:
            print(f"Invalid value for field VendorCapabilities_V_1_03::max_filter: {self.max_filter} > 255; the value will be truncated")
            self.max_filter &= 255
        _span.append((self.max_filter << 0))
        if self.activity_energy_info_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_1_03::activity_energy_info_support: {self.activity_energy_info_support} > 255; the value will be truncated")
            self.activity_energy_info_support &= 255
        _span.append((self.activity_energy_info_support << 0))
        _span.extend(int.to_bytes((259 << 0), length=2, byteorder='little'))
        if self.total_num_of_advt_tracked > 65535:
            print(f"Invalid value for field VendorCapabilities_V_1_03::total_num_of_advt_tracked: {self.total_num_of_advt_tracked} > 65535; the value will be truncated")
            self.total_num_of_advt_tracked &= 65535
        _span.extend(int.to_bytes((self.total_num_of_advt_tracked << 0), length=2, byteorder='little'))
        if self.extended_scan_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_1_03::extended_scan_support: {self.extended_scan_support} > 255; the value will be truncated")
            self.extended_scan_support &= 255
        _span.append((self.extended_scan_support << 0))
        if self.debug_logging_supported > 255:
            print(f"Invalid value for field VendorCapabilities_V_1_03::debug_logging_supported: {self.debug_logging_supported} > 255; the value will be truncated")
            self.debug_logging_supported &= 255
        _span.append((self.debug_logging_supported << 0))
        _span.extend([0] * 1)
        if self.a2dp_source_offload_capability_mask > 4294967295:
            print(f"Invalid value for field VendorCapabilities_V_1_03::a2dp_source_offload_capability_mask: {self.a2dp_source_offload_capability_mask} > 4294967295; the value will be truncated")
            self.a2dp_source_offload_capability_mask &= 4294967295
        _span.extend(int.to_bytes((self.a2dp_source_offload_capability_mask << 0), length=4, byteorder='little'))
        if self.bluetooth_quality_report_support > 255:
            print(f"Invalid value for field VendorCapabilities_V_1_03::bluetooth_quality_report_support: {self.bluetooth_quality_report_support} > 255; the value will be truncated")
            self.bluetooth_quality_report_support &= 255
        _span.append((self.bluetooth_quality_report_support << 0))
        if self.dynamic_audio_buffer_support > 4294967295:
            print(f"Invalid value for field VendorCapabilities_V_1_03::dynamic_audio_buffer_support: {self.dynamic_audio_buffer_support} > 4294967295; the value will be truncated")
            self.dynamic_audio_buffer_support &= 4294967295
        _span.extend(int.to_bytes((self.dynamic_audio_buffer_support << 0), length=4, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 24

class BatchScanOpcode(enum.IntEnum):
    ENABLE = 0x1
    SET_STORAGE_PARAMETERS = 0x2
    SET_SCAN_PARAMETERS = 0x3
    READ_RESULT_PARAMETERS = 0x4

@dataclass
class LeBatchScan(Command):
    batch_scan_opcode: BatchScanOpcode = field(kw_only=True, default=BatchScanOpcode.ENABLE)

    def __post_init__(self):
        self.op_code = OpCode.LE_BATCH_SCAN

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScan', bytes]:
        if fields['op_code'] != OpCode.LE_BATCH_SCAN:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['batch_scan_opcode'] = BatchScanOpcode(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeBatchScanEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanSetStorageParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanSetScanParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanReadResultParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeBatchScan(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.batch_scan_opcode << 0))
        _span.extend(payload or self.payload or [])
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class LeBatchScanComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    batch_scan_opcode: BatchScanOpcode = field(kw_only=True, default=BatchScanOpcode.ENABLE)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_BATCH_SCAN:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['batch_scan_opcode'] = BatchScanOpcode(span[1])
        span = span[2:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeBatchScanEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanSetStorageParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanSetScanParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanReadResultParametersCompleteRaw.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanReadResultParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeBatchScanComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.batch_scan_opcode << 0))
        _span.extend(payload or self.payload or [])
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 2

@dataclass
class LeBatchScanEnable(LeBatchScan):
    enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.ENABLE
        self.op_code = OpCode.LE_BATCH_SCAN

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanEnable', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['enable'] = Enable(span[0])
        span = span[1:]
        return LeBatchScanEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.enable << 0))
        return LeBatchScan.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeBatchScanEnableComplete(LeBatchScanComplete):
    

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.ENABLE
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanEnableComplete', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.ENABLE:
            raise Exception("Invalid constraint field values")
        return LeBatchScanEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return LeBatchScanComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeBatchScanSetStorageParameters(LeBatchScan):
    batch_scan_full_max_percentage: int = field(kw_only=True, default=0)
    batch_scan_truncated_max_percentage: int = field(kw_only=True, default=0)
    batch_scan_notify_threshold_percentage: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.SET_STORAGE_PARAMETERS
        self.op_code = OpCode.LE_BATCH_SCAN

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanSetStorageParameters', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.SET_STORAGE_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 3:
            raise Exception('Invalid packet size')
        fields['batch_scan_full_max_percentage'] = span[0]
        fields['batch_scan_truncated_max_percentage'] = span[1]
        fields['batch_scan_notify_threshold_percentage'] = span[2]
        span = span[3:]
        return LeBatchScanSetStorageParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.batch_scan_full_max_percentage > 255:
            print(f"Invalid value for field LeBatchScanSetStorageParameters::batch_scan_full_max_percentage: {self.batch_scan_full_max_percentage} > 255; the value will be truncated")
            self.batch_scan_full_max_percentage &= 255
        _span.append((self.batch_scan_full_max_percentage << 0))
        if self.batch_scan_truncated_max_percentage > 255:
            print(f"Invalid value for field LeBatchScanSetStorageParameters::batch_scan_truncated_max_percentage: {self.batch_scan_truncated_max_percentage} > 255; the value will be truncated")
            self.batch_scan_truncated_max_percentage &= 255
        _span.append((self.batch_scan_truncated_max_percentage << 0))
        if self.batch_scan_notify_threshold_percentage > 255:
            print(f"Invalid value for field LeBatchScanSetStorageParameters::batch_scan_notify_threshold_percentage: {self.batch_scan_notify_threshold_percentage} > 255; the value will be truncated")
            self.batch_scan_notify_threshold_percentage &= 255
        _span.append((self.batch_scan_notify_threshold_percentage << 0))
        return LeBatchScan.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 3

@dataclass
class LeBatchScanSetStorageParametersComplete(LeBatchScanComplete):
    

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.SET_STORAGE_PARAMETERS
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanSetStorageParametersComplete', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.SET_STORAGE_PARAMETERS:
            raise Exception("Invalid constraint field values")
        return LeBatchScanSetStorageParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return LeBatchScanComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class BatchScanDiscardRule(enum.IntEnum):
    OLDEST = 0x0
    WEAKEST_RSSI = 0x1

@dataclass
class LeBatchScanSetScanParameters(LeBatchScan):
    truncated_mode_enabled: int = field(kw_only=True, default=0)
    full_mode_enabled: int = field(kw_only=True, default=0)
    duty_cycle_scan_window_slots: int = field(kw_only=True, default=0)
    duty_cycle_scan_interval_slots: int = field(kw_only=True, default=0)
    own_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    batch_scan_discard_rule: BatchScanDiscardRule = field(kw_only=True, default=BatchScanDiscardRule.OLDEST)

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.SET_SCAN_PARAMETERS
        self.op_code = OpCode.LE_BATCH_SCAN

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanSetScanParameters', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.SET_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['truncated_mode_enabled'] = (span[0] >> 0) & 0x1
        fields['full_mode_enabled'] = (span[0] >> 1) & 0x1
        value_ = int.from_bytes(span[1:5], byteorder='little')
        fields['duty_cycle_scan_window_slots'] = value_
        value_ = int.from_bytes(span[5:9], byteorder='little')
        fields['duty_cycle_scan_interval_slots'] = value_
        fields['own_address_type'] = PeerAddressType(span[9])
        fields['batch_scan_discard_rule'] = BatchScanDiscardRule(span[10])
        span = span[11:]
        return LeBatchScanSetScanParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.truncated_mode_enabled > 1:
            print(f"Invalid value for field LeBatchScanSetScanParameters::truncated_mode_enabled: {self.truncated_mode_enabled} > 1; the value will be truncated")
            self.truncated_mode_enabled &= 1
        if self.full_mode_enabled > 1:
            print(f"Invalid value for field LeBatchScanSetScanParameters::full_mode_enabled: {self.full_mode_enabled} > 1; the value will be truncated")
            self.full_mode_enabled &= 1
        _value = (
            (self.truncated_mode_enabled << 0) |
            (self.full_mode_enabled << 1)
        )
        _span.append(_value)
        if self.duty_cycle_scan_window_slots > 4294967295:
            print(f"Invalid value for field LeBatchScanSetScanParameters::duty_cycle_scan_window_slots: {self.duty_cycle_scan_window_slots} > 4294967295; the value will be truncated")
            self.duty_cycle_scan_window_slots &= 4294967295
        _span.extend(int.to_bytes((self.duty_cycle_scan_window_slots << 0), length=4, byteorder='little'))
        if self.duty_cycle_scan_interval_slots > 4294967295:
            print(f"Invalid value for field LeBatchScanSetScanParameters::duty_cycle_scan_interval_slots: {self.duty_cycle_scan_interval_slots} > 4294967295; the value will be truncated")
            self.duty_cycle_scan_interval_slots &= 4294967295
        _span.extend(int.to_bytes((self.duty_cycle_scan_interval_slots << 0), length=4, byteorder='little'))
        _span.append((self.own_address_type << 0))
        _span.append((self.batch_scan_discard_rule << 0))
        return LeBatchScan.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

@dataclass
class LeBatchScanSetScanParametersComplete(LeBatchScanComplete):
    

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.SET_SCAN_PARAMETERS
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanSetScanParametersComplete', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.SET_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        return LeBatchScanSetScanParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return LeBatchScanComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class BatchScanDataRead(enum.IntEnum):
    TRUNCATED_MODE_DATA = 0x1
    FULL_MODE_DATA = 0x2

@dataclass
class LeBatchScanReadResultParameters(LeBatchScan):
    batch_scan_data_read: BatchScanDataRead = field(kw_only=True, default=BatchScanDataRead.TRUNCATED_MODE_DATA)

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.READ_RESULT_PARAMETERS
        self.op_code = OpCode.LE_BATCH_SCAN

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanReadResultParameters', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.READ_RESULT_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['batch_scan_data_read'] = BatchScanDataRead(span[0])
        span = span[1:]
        return LeBatchScanReadResultParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.batch_scan_data_read << 0))
        return LeBatchScan.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeBatchScanReadResultParametersCompleteRaw(LeBatchScanComplete):
    batch_scan_data_read: BatchScanDataRead = field(kw_only=True, default=BatchScanDataRead.TRUNCATED_MODE_DATA)
    num_of_records: int = field(kw_only=True, default=0)
    raw_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.READ_RESULT_PARAMETERS
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanReadResultParametersCompleteRaw', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.READ_RESULT_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['batch_scan_data_read'] = BatchScanDataRead(span[0])
        fields['num_of_records'] = span[1]
        span = span[2:]
        fields['raw_data'] = list(span)
        span = bytes()
        return LeBatchScanReadResultParametersCompleteRaw(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.batch_scan_data_read << 0))
        if self.num_of_records > 255:
            print(f"Invalid value for field LeBatchScanReadResultParametersCompleteRaw::num_of_records: {self.num_of_records} > 255; the value will be truncated")
            self.num_of_records &= 255
        _span.append((self.num_of_records << 0))
        _span.extend(self.raw_data)
        return LeBatchScanComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.raw_data) * 1 + 2

@dataclass
class LeBatchScanReadResultParametersComplete(LeBatchScanComplete):
    batch_scan_data_read: BatchScanDataRead = field(kw_only=True, default=BatchScanDataRead.TRUNCATED_MODE_DATA)

    def __post_init__(self):
        self.batch_scan_opcode = BatchScanOpcode.READ_RESULT_PARAMETERS
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanReadResultParametersComplete', bytes]:
        if fields['batch_scan_opcode'] != BatchScanOpcode.READ_RESULT_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['batch_scan_data_read'] = BatchScanDataRead(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeBatchScanReadTruncatedResultParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeBatchScanReadFullResultParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeBatchScanReadResultParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.batch_scan_data_read << 0))
        _span.extend(payload or self.payload or [])
        return LeBatchScanComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class TruncatedResult(Packet):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    tx_power: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)
    timestamp: int = field(kw_only=True, default=0)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['TruncatedResult', bytes]:
        fields = {'payload': None}
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['address_type'] = AddressType(span[6])
        fields['tx_power'] = span[7]
        fields['rssi'] = span[8]
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['timestamp'] = value_
        span = span[11:]
        return TruncatedResult(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.address_type << 0))
        if self.tx_power > 255:
            print(f"Invalid value for field TruncatedResult::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        if self.rssi > 255:
            print(f"Invalid value for field TruncatedResult::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        if self.timestamp > 65535:
            print(f"Invalid value for field TruncatedResult::timestamp: {self.timestamp} > 65535; the value will be truncated")
            self.timestamp &= 65535
        _span.extend(int.to_bytes((self.timestamp << 0), length=2, byteorder='little'))
        return bytes(_span)

    @property
    def size(self) -> int:
        return 11

@dataclass
class LeBatchScanReadTruncatedResultParametersComplete(LeBatchScanReadResultParametersComplete):
    results: List[TruncatedResult] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.batch_scan_data_read = BatchScanDataRead.TRUNCATED_MODE_DATA
        self.batch_scan_opcode = BatchScanOpcode.READ_RESULT_PARAMETERS
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanReadTruncatedResultParametersComplete', bytes]:
        if fields['batch_scan_data_read'] != BatchScanDataRead.TRUNCATED_MODE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        results_count = span[0]
        span = span[1:]
        if len(span) < results_count * 11:
            raise Exception('Invalid packet size')
        results = []
        for n in range(results_count):
            results.append(TruncatedResult.parse_all(span[n * 11:(n + 1) * 11]))
        fields['results'] = results
        span = span[results_count * 11:]
        return LeBatchScanReadTruncatedResultParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.results) > 255:
            print(f"Invalid length for field LeBatchScanReadTruncatedResultParametersComplete::results:  {len(self.results)} > 255; the array will be truncated")
            del self.results[255:]
        _span.append((len(self.results) << 0))
        for _elt in self.results:
            _span.extend(_elt.serialize())
        return LeBatchScanReadResultParametersComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.results]) + 1

@dataclass
class FullResult(Packet):
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    address_type: AddressType = field(kw_only=True, default=AddressType.PUBLIC_DEVICE_ADDRESS)
    tx_power: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)
    timestamp: int = field(kw_only=True, default=0)
    adv_packet: bytearray = field(kw_only=True, default_factory=bytearray)
    scan_response: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['FullResult', bytes]:
        fields = {'payload': None}
        if len(span) < 12:
            raise Exception('Invalid packet size')
        fields['bd_addr'] = Address.parse_all(span[0:6])
        fields['address_type'] = AddressType(span[6])
        fields['tx_power'] = span[7]
        fields['rssi'] = span[8]
        value_ = int.from_bytes(span[9:11], byteorder='little')
        fields['timestamp'] = value_
        adv_packet_size = span[11]
        span = span[12:]
        if len(span) < adv_packet_size:
            raise Exception('Invalid packet size')
        fields['adv_packet'] = list(span[:adv_packet_size])
        span = span[adv_packet_size:]
        if len(span) < 1:
            raise Exception('Invalid packet size')
        scan_response_size = span[0]
        span = span[1:]
        if len(span) < scan_response_size:
            raise Exception('Invalid packet size')
        fields['scan_response'] = list(span[:scan_response_size])
        span = span[scan_response_size:]
        return FullResult(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.bd_addr.serialize())
        _span.append((self.address_type << 0))
        if self.tx_power > 255:
            print(f"Invalid value for field FullResult::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        if self.rssi > 255:
            print(f"Invalid value for field FullResult::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        if self.timestamp > 65535:
            print(f"Invalid value for field FullResult::timestamp: {self.timestamp} > 65535; the value will be truncated")
            self.timestamp &= 65535
        _span.extend(int.to_bytes((self.timestamp << 0), length=2, byteorder='little'))
        _span.append(((len(self.adv_packet) * 1) << 0))
        _span.extend(self.adv_packet)
        _span.append(((len(self.scan_response) * 1) << 0))
        _span.extend(self.scan_response)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 13 + (
        len(self.adv_packet) * 1 +
            len(self.scan_response) * 1
        )

@dataclass
class LeBatchScanReadFullResultParametersComplete(LeBatchScanReadResultParametersComplete):
    results: List[FullResult] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.batch_scan_data_read = BatchScanDataRead.FULL_MODE_DATA
        self.batch_scan_opcode = BatchScanOpcode.READ_RESULT_PARAMETERS
        self.command_op_code = OpCode.LE_BATCH_SCAN
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeBatchScanReadFullResultParametersComplete', bytes]:
        if fields['batch_scan_data_read'] != BatchScanDataRead.FULL_MODE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        results_count = span[0]
        span = span[1:]
        results = []
        for n in range(results_count):
            element, span = FullResult.parse(span)
            results.append(element)
        fields['results'] = results
        return LeBatchScanReadFullResultParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.results) > 255:
            print(f"Invalid length for field LeBatchScanReadFullResultParametersComplete::results:  {len(self.results)} > 255; the array will be truncated")
            del self.results[255:]
        _span.append((len(self.results) << 0))
        for _elt in self.results:
            _span.extend(_elt.serialize())
        return LeBatchScanReadResultParametersComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.results]) + 1

@dataclass
class StorageThresholdBreachEvent(VendorSpecificEvent):
    

    def __post_init__(self):
        self.subevent_code = VseSubeventCode.STORAGE_THRESHOLD_BREACH
        self.event_code = EventCode.VENDOR_SPECIFIC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['StorageThresholdBreachEvent', bytes]:
        if fields['subevent_code'] != VseSubeventCode.STORAGE_THRESHOLD_BREACH:
            raise Exception("Invalid constraint field values")
        return StorageThresholdBreachEvent(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return VendorSpecificEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class ApcfOpcode(enum.IntEnum):
    ENABLE = 0x0
    SET_FILTERING_PARAMETERS = 0x1
    BROADCASTER_ADDRESS = 0x2
    SERVICE_UUID = 0x3
    SERVICE_SOLICITATION_UUID = 0x4
    LOCAL_NAME = 0x5
    MANUFACTURER_DATA = 0x6
    SERVICE_DATA = 0x7
    TRANSPORT_DISCOVERY_SERVICE = 0x8
    AD_TYPE_FILTER = 0x9
    READ_EXTENDED_FEATURES = 0xff

@dataclass
class LeApcf(Command):
    apcf_opcode: ApcfOpcode = field(kw_only=True, default=ApcfOpcode.ENABLE)

    def __post_init__(self):
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcf', bytes]:
        if fields['op_code'] != OpCode.LE_APCF:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['apcf_opcode'] = ApcfOpcode(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeApcfEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfSetFilteringParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfBroadcasterAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfServiceUuid.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfServiceSolicitationUuid.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfLocalName.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfManufacturerData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfServiceData.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfAdTypeFilter.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfTransportDiscoveryService.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfReadExtendedFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeApcf(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_opcode << 0))
        _span.extend(payload or self.payload or [])
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class LeApcfComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    apcf_opcode: ApcfOpcode = field(kw_only=True, default=ApcfOpcode.ENABLE)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_APCF:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['apcf_opcode'] = ApcfOpcode(span[1])
        span = span[2:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeApcfEnableComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfSetFilteringParametersComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfBroadcasterAddressComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfServiceUuidComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfServiceSolicitationUuidComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfLocalNameComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfManufacturerDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfServiceDataComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfAdTypeFilterComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfTransportDiscoveryServiceComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfReadExtendedFeaturesComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeApcfComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.apcf_opcode << 0))
        _span.extend(payload or self.payload or [])
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 2

@dataclass
class LeApcfEnable(LeApcf):
    apcf_enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.ENABLE
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfEnable', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['apcf_enable'] = Enable(span[0])
        span = span[1:]
        return LeApcfEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_enable << 0))
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeApcfEnableComplete(LeApcfComplete):
    apcf_enable: Enable = field(kw_only=True, default=Enable.DISABLED)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.ENABLE
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfEnableComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['apcf_enable'] = Enable(span[0])
        span = span[1:]
        return LeApcfEnableComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_enable << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

class ApcfAction(enum.IntEnum):
    ADD = 0x0
    DELETE = 0x1
    CLEAR = 0x2

class DeliveryMode(enum.IntEnum):
    IMMEDIATE = 0x0
    ONFOUND = 0x1
    BATCHED = 0x2

class ApcfFeatureSelection(enum.IntEnum):
    BROADCASTER_ADDRESS = 0x0
    SERVICE_DATA_CHANGE = 0x1
    SERVICE_UUID = 0x2
    SERVICE_SOLICITATION_UUID = 0x3
    LOCAL_NAME = 0x4
    MANUFACTURER_DATA = 0x5
    SERVICE_DATA = 0x6
    TRANSPORT_DISCOVERY_DATA = 0x7
    AD_TYPE = 0x8

@dataclass
class LeApcfSetFilteringParameters(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SET_FILTERING_PARAMETERS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfSetFilteringParameters', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SET_FILTERING_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeApcfAddFilteringParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfDeleteFilteringParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfClearFilteringParameters.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeApcfSetFilteringParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        _span.extend(payload or self.payload or [])
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class LeApcfAddFilteringParameters(LeApcfSetFilteringParameters):
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_feature_selection: int = field(kw_only=True, default=0)
    apcf_list_logic_type: int = field(kw_only=True, default=0)
    apcf_filter_logic_type: int = field(kw_only=True, default=0)
    rssi_high_thresh: int = field(kw_only=True, default=0)
    delivery_mode: DeliveryMode = field(kw_only=True, default=DeliveryMode.IMMEDIATE)
    onfound_timeout: int = field(kw_only=True, default=0)
    onfound_timeout_cnt: int = field(kw_only=True, default=0)
    rssi_low_thresh: int = field(kw_only=True, default=0)
    onlost_timeout: int = field(kw_only=True, default=0)
    num_of_tracking_entries: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_action = ApcfAction.ADD
        self.apcf_opcode = ApcfOpcode.SET_FILTERING_PARAMETERS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfAddFilteringParameters', bytes]:
        if fields['apcf_action'] != ApcfAction.ADD:
            raise Exception("Invalid constraint field values")
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['apcf_filter_index'] = span[0]
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['apcf_feature_selection'] = value_
        value_ = int.from_bytes(span[3:5], byteorder='little')
        fields['apcf_list_logic_type'] = value_
        fields['apcf_filter_logic_type'] = span[5]
        fields['rssi_high_thresh'] = span[6]
        fields['delivery_mode'] = DeliveryMode(span[7])
        value_ = int.from_bytes(span[8:10], byteorder='little')
        fields['onfound_timeout'] = value_
        fields['onfound_timeout_cnt'] = span[10]
        fields['rssi_low_thresh'] = span[11]
        value_ = int.from_bytes(span[12:14], byteorder='little')
        fields['onlost_timeout'] = value_
        value_ = int.from_bytes(span[14:16], byteorder='little')
        fields['num_of_tracking_entries'] = value_
        span = span[16:]
        return LeApcfAddFilteringParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfAddFilteringParameters::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        if self.apcf_feature_selection > 65535:
            print(f"Invalid value for field LeApcfAddFilteringParameters::apcf_feature_selection: {self.apcf_feature_selection} > 65535; the value will be truncated")
            self.apcf_feature_selection &= 65535
        _span.extend(int.to_bytes((self.apcf_feature_selection << 0), length=2, byteorder='little'))
        if self.apcf_list_logic_type > 65535:
            print(f"Invalid value for field LeApcfAddFilteringParameters::apcf_list_logic_type: {self.apcf_list_logic_type} > 65535; the value will be truncated")
            self.apcf_list_logic_type &= 65535
        _span.extend(int.to_bytes((self.apcf_list_logic_type << 0), length=2, byteorder='little'))
        if self.apcf_filter_logic_type > 255:
            print(f"Invalid value for field LeApcfAddFilteringParameters::apcf_filter_logic_type: {self.apcf_filter_logic_type} > 255; the value will be truncated")
            self.apcf_filter_logic_type &= 255
        _span.append((self.apcf_filter_logic_type << 0))
        if self.rssi_high_thresh > 255:
            print(f"Invalid value for field LeApcfAddFilteringParameters::rssi_high_thresh: {self.rssi_high_thresh} > 255; the value will be truncated")
            self.rssi_high_thresh &= 255
        _span.append((self.rssi_high_thresh << 0))
        _span.append((self.delivery_mode << 0))
        if self.onfound_timeout > 65535:
            print(f"Invalid value for field LeApcfAddFilteringParameters::onfound_timeout: {self.onfound_timeout} > 65535; the value will be truncated")
            self.onfound_timeout &= 65535
        _span.extend(int.to_bytes((self.onfound_timeout << 0), length=2, byteorder='little'))
        if self.onfound_timeout_cnt > 255:
            print(f"Invalid value for field LeApcfAddFilteringParameters::onfound_timeout_cnt: {self.onfound_timeout_cnt} > 255; the value will be truncated")
            self.onfound_timeout_cnt &= 255
        _span.append((self.onfound_timeout_cnt << 0))
        if self.rssi_low_thresh > 255:
            print(f"Invalid value for field LeApcfAddFilteringParameters::rssi_low_thresh: {self.rssi_low_thresh} > 255; the value will be truncated")
            self.rssi_low_thresh &= 255
        _span.append((self.rssi_low_thresh << 0))
        if self.onlost_timeout > 65535:
            print(f"Invalid value for field LeApcfAddFilteringParameters::onlost_timeout: {self.onlost_timeout} > 65535; the value will be truncated")
            self.onlost_timeout &= 65535
        _span.extend(int.to_bytes((self.onlost_timeout << 0), length=2, byteorder='little'))
        if self.num_of_tracking_entries > 65535:
            print(f"Invalid value for field LeApcfAddFilteringParameters::num_of_tracking_entries: {self.num_of_tracking_entries} > 65535; the value will be truncated")
            self.num_of_tracking_entries &= 65535
        _span.extend(int.to_bytes((self.num_of_tracking_entries << 0), length=2, byteorder='little'))
        return LeApcfSetFilteringParameters.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 16

@dataclass
class LeApcfDeleteFilteringParameters(LeApcfSetFilteringParameters):
    apcf_filter_index: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_action = ApcfAction.DELETE
        self.apcf_opcode = ApcfOpcode.SET_FILTERING_PARAMETERS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfDeleteFilteringParameters', bytes]:
        if fields['apcf_action'] != ApcfAction.DELETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['apcf_filter_index'] = span[0]
        span = span[1:]
        return LeApcfDeleteFilteringParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfDeleteFilteringParameters::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        return LeApcfSetFilteringParameters.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeApcfClearFilteringParameters(LeApcfSetFilteringParameters):
    

    def __post_init__(self):
        self.apcf_action = ApcfAction.CLEAR
        self.apcf_opcode = ApcfOpcode.SET_FILTERING_PARAMETERS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfClearFilteringParameters', bytes]:
        if fields['apcf_action'] != ApcfAction.CLEAR:
            raise Exception("Invalid constraint field values")
        return LeApcfClearFilteringParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return LeApcfSetFilteringParameters.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeApcfSetFilteringParametersComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SET_FILTERING_PARAMETERS
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfSetFilteringParametersComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SET_FILTERING_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfSetFilteringParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfSetFilteringParametersComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class ApcfApplicationAddressType(enum.IntEnum):
    PUBLIC = 0x0
    RANDOM = 0x1
    NOT_APPLICABLE = 0x2

@dataclass
class LeApcfBroadcasterAddress(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.BROADCASTER_ADDRESS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfBroadcasterAddress', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.BROADCASTER_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return LeApcfAddBroadcasterAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfDeleteBroadcasterAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return LeApcfClearBroadcasterAddress.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return LeApcfBroadcasterAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        _span.extend(payload or self.payload or [])
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class LeApcfAddBroadcasterAddress(LeApcfBroadcasterAddress):
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_broadcaster_address: Address = field(kw_only=True, default_factory=Address)
    apcf_application_address_type: ApcfApplicationAddressType = field(kw_only=True, default=ApcfApplicationAddressType.PUBLIC)

    def __post_init__(self):
        self.apcf_action = ApcfAction.ADD
        self.apcf_opcode = ApcfOpcode.BROADCASTER_ADDRESS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfAddBroadcasterAddress', bytes]:
        if fields['apcf_action'] != ApcfAction.ADD:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['apcf_filter_index'] = span[0]
        fields['apcf_broadcaster_address'] = Address.parse_all(span[1:7])
        fields['apcf_application_address_type'] = ApcfApplicationAddressType(span[7])
        span = span[8:]
        return LeApcfAddBroadcasterAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfAddBroadcasterAddress::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.apcf_broadcaster_address.serialize())
        _span.append((self.apcf_application_address_type << 0))
        return LeApcfBroadcasterAddress.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeApcfDeleteBroadcasterAddress(LeApcfBroadcasterAddress):
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_broadcaster_address: Address = field(kw_only=True, default_factory=Address)
    apcf_application_address_type: ApcfApplicationAddressType = field(kw_only=True, default=ApcfApplicationAddressType.PUBLIC)

    def __post_init__(self):
        self.apcf_action = ApcfAction.DELETE
        self.apcf_opcode = ApcfOpcode.BROADCASTER_ADDRESS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfDeleteBroadcasterAddress', bytes]:
        if fields['apcf_action'] != ApcfAction.DELETE:
            raise Exception("Invalid constraint field values")
        if len(span) < 8:
            raise Exception('Invalid packet size')
        fields['apcf_filter_index'] = span[0]
        fields['apcf_broadcaster_address'] = Address.parse_all(span[1:7])
        fields['apcf_application_address_type'] = ApcfApplicationAddressType(span[7])
        span = span[8:]
        return LeApcfDeleteBroadcasterAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfDeleteBroadcasterAddress::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.apcf_broadcaster_address.serialize())
        _span.append((self.apcf_application_address_type << 0))
        return LeApcfBroadcasterAddress.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 8

@dataclass
class LeApcfClearBroadcasterAddress(LeApcfBroadcasterAddress):
    apcf_filter_index: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_action = ApcfAction.CLEAR
        self.apcf_opcode = ApcfOpcode.BROADCASTER_ADDRESS
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfClearBroadcasterAddress', bytes]:
        if fields['apcf_action'] != ApcfAction.CLEAR:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['apcf_filter_index'] = span[0]
        span = span[1:]
        return LeApcfClearBroadcasterAddress(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfClearBroadcasterAddress::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        return LeApcfBroadcasterAddress.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class LeApcfBroadcasterAddressComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.BROADCASTER_ADDRESS
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfBroadcasterAddressComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.BROADCASTER_ADDRESS:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfBroadcasterAddressComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfBroadcasterAddressComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfServiceUuid(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_filter_index: int = field(kw_only=True, default=0)
    acpf_uuid_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SERVICE_UUID
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfServiceUuid', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SERVICE_UUID:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_filter_index'] = span[1]
        span = span[2:]
        fields['acpf_uuid_data'] = list(span)
        span = bytes()
        return LeApcfServiceUuid(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfServiceUuid::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.acpf_uuid_data)
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.acpf_uuid_data) * 1 + 2

@dataclass
class LeApcfServiceUuidComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SERVICE_UUID
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfServiceUuidComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SERVICE_UUID:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfServiceUuidComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfServiceUuidComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfServiceSolicitationUuid(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_filter_index: int = field(kw_only=True, default=0)
    acpf_uuid_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SERVICE_SOLICITATION_UUID
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfServiceSolicitationUuid', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SERVICE_SOLICITATION_UUID:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_filter_index'] = span[1]
        span = span[2:]
        fields['acpf_uuid_data'] = list(span)
        span = bytes()
        return LeApcfServiceSolicitationUuid(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfServiceSolicitationUuid::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.acpf_uuid_data)
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.acpf_uuid_data) * 1 + 2

@dataclass
class LeApcfServiceSolicitationUuidComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SERVICE_SOLICITATION_UUID
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfServiceSolicitationUuidComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SERVICE_SOLICITATION_UUID:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfServiceSolicitationUuidComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfServiceSolicitationUuidComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfLocalName(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_local_name: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.LOCAL_NAME
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfLocalName', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.LOCAL_NAME:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_filter_index'] = span[1]
        span = span[2:]
        fields['apcf_local_name'] = list(span)
        span = bytes()
        return LeApcfLocalName(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfLocalName::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.apcf_local_name)
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.apcf_local_name) * 1 + 2

@dataclass
class LeApcfLocalNameComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.LOCAL_NAME
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfLocalNameComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.LOCAL_NAME:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfLocalNameComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfLocalNameComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfManufacturerData(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_manufacturer_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.MANUFACTURER_DATA
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfManufacturerData', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.MANUFACTURER_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_filter_index'] = span[1]
        span = span[2:]
        fields['apcf_manufacturer_data'] = list(span)
        span = bytes()
        return LeApcfManufacturerData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfManufacturerData::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.apcf_manufacturer_data)
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.apcf_manufacturer_data) * 1 + 2

@dataclass
class LeApcfManufacturerDataComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.MANUFACTURER_DATA
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfManufacturerDataComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.MANUFACTURER_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfManufacturerDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfManufacturerDataComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfServiceData(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_service_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SERVICE_DATA
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfServiceData', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SERVICE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_filter_index'] = span[1]
        span = span[2:]
        fields['apcf_service_data'] = list(span)
        span = bytes()
        return LeApcfServiceData(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfServiceData::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.apcf_service_data)
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.apcf_service_data) * 1 + 2

@dataclass
class LeApcfServiceDataComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.SERVICE_DATA
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfServiceDataComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.SERVICE_DATA:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfServiceDataComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfServiceDataComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfAdTypeFilter(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_ad_type: int = field(kw_only=True, default=0)
    apcf_ad_data: bytearray = field(kw_only=True, default_factory=bytearray)
    apcf_ad_data_mask: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.AD_TYPE_FILTER
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfAdTypeFilter', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.AD_TYPE_FILTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_filter_index'] = span[1]
        fields['apcf_ad_type'] = span[2]
        apcf_ad_data_size = span[3]
        span = span[4:]
        if len(span) < apcf_ad_data_size:
            raise Exception('Invalid packet size')
        fields['apcf_ad_data'] = list(span[:apcf_ad_data_size])
        span = span[apcf_ad_data_size:]
        fields['apcf_ad_data_mask'] = list(span)
        span = bytes()
        return LeApcfAdTypeFilter(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfAdTypeFilter::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        if self.apcf_ad_type > 255:
            print(f"Invalid value for field LeApcfAdTypeFilter::apcf_ad_type: {self.apcf_ad_type} > 255; the value will be truncated")
            self.apcf_ad_type &= 255
        _span.append((self.apcf_ad_type << 0))
        _span.append(((len(self.apcf_ad_data) * 1) << 0))
        _span.extend(self.apcf_ad_data)
        _span.extend(self.apcf_ad_data_mask)
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4 + (
        len(self.apcf_ad_data) * 1 +
            len(self.apcf_ad_data_mask) * 1
        )

@dataclass
class LeApcfAdTypeFilterComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.AD_TYPE_FILTER
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfAdTypeFilterComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.AD_TYPE_FILTER:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfAdTypeFilterComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfAdTypeFilterComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfTransportDiscoveryService(LeApcf):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_filter_index: int = field(kw_only=True, default=0)
    apcf_transport_discovery_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.TRANSPORT_DISCOVERY_SERVICE
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfTransportDiscoveryService', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.TRANSPORT_DISCOVERY_SERVICE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_filter_index'] = span[1]
        span = span[2:]
        fields['apcf_transport_discovery_data'] = list(span)
        span = bytes()
        return LeApcfTransportDiscoveryService(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeApcfTransportDiscoveryService::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.extend(self.apcf_transport_discovery_data)
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.apcf_transport_discovery_data) * 1 + 2

@dataclass
class LeApcfTransportDiscoveryServiceComplete(LeApcfComplete):
    apcf_action: ApcfAction = field(kw_only=True, default=ApcfAction.ADD)
    apcf_available_spaces: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.TRANSPORT_DISCOVERY_SERVICE
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfTransportDiscoveryServiceComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.TRANSPORT_DISCOVERY_SERVICE:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['apcf_action'] = ApcfAction(span[0])
        fields['apcf_available_spaces'] = span[1]
        span = span[2:]
        return LeApcfTransportDiscoveryServiceComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.apcf_action << 0))
        if self.apcf_available_spaces > 255:
            print(f"Invalid value for field LeApcfTransportDiscoveryServiceComplete::apcf_available_spaces: {self.apcf_available_spaces} > 255; the value will be truncated")
            self.apcf_available_spaces &= 255
        _span.append((self.apcf_available_spaces << 0))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class LeApcfReadExtendedFeatures(LeApcf):
    

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.READ_EXTENDED_FEATURES
        self.op_code = OpCode.LE_APCF

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfReadExtendedFeatures', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.READ_EXTENDED_FEATURES:
            raise Exception("Invalid constraint field values")
        return LeApcfReadExtendedFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return LeApcf.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeApcfReadExtendedFeaturesComplete(LeApcfComplete):
    transport_discovery_data_filter: int = field(kw_only=True, default=0)
    ad_type_filter: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.apcf_opcode = ApcfOpcode.READ_EXTENDED_FEATURES
        self.command_op_code = OpCode.LE_APCF
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeApcfReadExtendedFeaturesComplete', bytes]:
        if fields['apcf_opcode'] != ApcfOpcode.READ_EXTENDED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['transport_discovery_data_filter'] = (value_ >> 0) & 0x1
        fields['ad_type_filter'] = (value_ >> 1) & 0x1
        span = span[2:]
        return LeApcfReadExtendedFeaturesComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.transport_discovery_data_filter > 1:
            print(f"Invalid value for field LeApcfReadExtendedFeaturesComplete::transport_discovery_data_filter: {self.transport_discovery_data_filter} > 1; the value will be truncated")
            self.transport_discovery_data_filter &= 1
        if self.ad_type_filter > 1:
            print(f"Invalid value for field LeApcfReadExtendedFeaturesComplete::ad_type_filter: {self.ad_type_filter} > 1; the value will be truncated")
            self.ad_type_filter &= 1
        _value = (
            (self.transport_discovery_data_filter << 0) |
            (self.ad_type_filter << 1)
        )
        _span.extend(int.to_bytes(_value, length=2, byteorder='little'))
        return LeApcfComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

class AdvertiserState(enum.IntEnum):
    ADVERTISER_FOUND = 0x0
    ADVERTISER_LOST = 0x1

class AdvtInfoPresent(enum.IntEnum):
    ADVT_INFO_PRESENT = 0x0
    ADVT_INFO_NOT_PRESENT = 0x1

@dataclass
class AdvtInfo(Packet):
    tx_power: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)
    timestamp: int = field(kw_only=True, default=0)
    adv_packet: bytearray = field(kw_only=True, default_factory=bytearray)
    scan_data_resp: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['AdvtInfo', bytes]:
        fields = {'payload': None}
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['tx_power'] = span[0]
        fields['rssi'] = span[1]
        value_ = int.from_bytes(span[2:4], byteorder='little')
        fields['timestamp'] = value_
        adv_packet_size = span[4]
        span = span[5:]
        if len(span) < adv_packet_size:
            raise Exception('Invalid packet size')
        fields['adv_packet'] = list(span[:adv_packet_size])
        span = span[adv_packet_size:]
        if len(span) < 1:
            raise Exception('Invalid packet size')
        scan_data_resp_size = span[0]
        span = span[1:]
        if len(span) < scan_data_resp_size:
            raise Exception('Invalid packet size')
        fields['scan_data_resp'] = list(span[:scan_data_resp_size])
        span = span[scan_data_resp_size:]
        return AdvtInfo(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.tx_power > 255:
            print(f"Invalid value for field AdvtInfo::tx_power: {self.tx_power} > 255; the value will be truncated")
            self.tx_power &= 255
        _span.append((self.tx_power << 0))
        if self.rssi > 255:
            print(f"Invalid value for field AdvtInfo::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        if self.timestamp > 65535:
            print(f"Invalid value for field AdvtInfo::timestamp: {self.timestamp} > 65535; the value will be truncated")
            self.timestamp &= 65535
        _span.extend(int.to_bytes((self.timestamp << 0), length=2, byteorder='little'))
        _span.append(((len(self.adv_packet) * 1) << 0))
        _span.extend(self.adv_packet)
        _span.append(((len(self.scan_data_resp) * 1) << 0))
        _span.extend(self.scan_data_resp)
        return bytes(_span)

    @property
    def size(self) -> int:
        return 6 + (
        len(self.adv_packet) * 1 +
            len(self.scan_data_resp) * 1
        )

@dataclass
class LeAdvertisementTrackingEvent(VendorSpecificEvent):
    apcf_filter_index: int = field(kw_only=True, default=0)
    advertiser_state: AdvertiserState = field(kw_only=True, default=AdvertiserState.ADVERTISER_FOUND)
    advt_info_present: AdvtInfoPresent = field(kw_only=True, default=AdvtInfoPresent.ADVT_INFO_PRESENT)
    advertiser_address: Address = field(kw_only=True, default_factory=Address)
    advertiser_address_type: PeerAddressType = field(kw_only=True, default=PeerAddressType.PUBLIC_DEVICE_OR_IDENTITY_ADDRESS)
    advt_info: List[AdvtInfo] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.subevent_code = VseSubeventCode.LE_ADVERTISEMENT_TRACKING
        self.event_code = EventCode.VENDOR_SPECIFIC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeAdvertisementTrackingEvent', bytes]:
        if fields['subevent_code'] != VseSubeventCode.LE_ADVERTISEMENT_TRACKING:
            raise Exception("Invalid constraint field values")
        if len(span) < 10:
            raise Exception('Invalid packet size')
        fields['apcf_filter_index'] = span[0]
        fields['advertiser_state'] = AdvertiserState(span[1])
        fields['advt_info_present'] = AdvtInfoPresent(span[2])
        fields['advertiser_address'] = Address.parse_all(span[3:9])
        fields['advertiser_address_type'] = PeerAddressType(span[9])
        span = span[10:]
        advt_info = []
        while len(span) > 0:
            element, span = AdvtInfo.parse(span)
            advt_info.append(element)
        fields['advt_info'] = advt_info
        return LeAdvertisementTrackingEvent(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.apcf_filter_index > 255:
            print(f"Invalid value for field LeAdvertisementTrackingEvent::apcf_filter_index: {self.apcf_filter_index} > 255; the value will be truncated")
            self.apcf_filter_index &= 255
        _span.append((self.apcf_filter_index << 0))
        _span.append((self.advertiser_state << 0))
        _span.append((self.advt_info_present << 0))
        _span.extend(self.advertiser_address.serialize())
        _span.append((self.advertiser_address_type << 0))
        for _elt in self.advt_info:
            _span.extend(_elt.serialize())
        return VendorSpecificEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.advt_info]) + 10

@dataclass
class LeGetControllerActivityEnergyInfo(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.LE_GET_CONTROLLER_ACTIVITY_ENERGY_INFO

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGetControllerActivityEnergyInfo', bytes]:
        if fields['op_code'] != OpCode.LE_GET_CONTROLLER_ACTIVITY_ENERGY_INFO:
            raise Exception("Invalid constraint field values")
        return LeGetControllerActivityEnergyInfo(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class LeGetControllerActivityEnergyInfoComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    total_tx_time_ms: int = field(kw_only=True, default=0)
    total_rx_time_ms: int = field(kw_only=True, default=0)
    total_idle_time_ms: int = field(kw_only=True, default=0)
    total_energy_used: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_GET_CONTROLLER_ACTIVITY_ENERGY_INFO
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeGetControllerActivityEnergyInfoComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_GET_CONTROLLER_ACTIVITY_ENERGY_INFO:
            raise Exception("Invalid constraint field values")
        if len(span) < 17:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        value_ = int.from_bytes(span[1:5], byteorder='little')
        fields['total_tx_time_ms'] = value_
        value_ = int.from_bytes(span[5:9], byteorder='little')
        fields['total_rx_time_ms'] = value_
        value_ = int.from_bytes(span[9:13], byteorder='little')
        fields['total_idle_time_ms'] = value_
        value_ = int.from_bytes(span[13:17], byteorder='little')
        fields['total_energy_used'] = value_
        span = span[17:]
        return LeGetControllerActivityEnergyInfoComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.total_tx_time_ms > 4294967295:
            print(f"Invalid value for field LeGetControllerActivityEnergyInfoComplete::total_tx_time_ms: {self.total_tx_time_ms} > 4294967295; the value will be truncated")
            self.total_tx_time_ms &= 4294967295
        _span.extend(int.to_bytes((self.total_tx_time_ms << 0), length=4, byteorder='little'))
        if self.total_rx_time_ms > 4294967295:
            print(f"Invalid value for field LeGetControllerActivityEnergyInfoComplete::total_rx_time_ms: {self.total_rx_time_ms} > 4294967295; the value will be truncated")
            self.total_rx_time_ms &= 4294967295
        _span.extend(int.to_bytes((self.total_rx_time_ms << 0), length=4, byteorder='little'))
        if self.total_idle_time_ms > 4294967295:
            print(f"Invalid value for field LeGetControllerActivityEnergyInfoComplete::total_idle_time_ms: {self.total_idle_time_ms} > 4294967295; the value will be truncated")
            self.total_idle_time_ms &= 4294967295
        _span.extend(int.to_bytes((self.total_idle_time_ms << 0), length=4, byteorder='little'))
        if self.total_energy_used > 4294967295:
            print(f"Invalid value for field LeGetControllerActivityEnergyInfoComplete::total_energy_used: {self.total_energy_used} > 4294967295; the value will be truncated")
            self.total_energy_used &= 4294967295
        _span.extend(int.to_bytes((self.total_energy_used << 0), length=4, byteorder='little'))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 17

class LeExScanType(enum.IntEnum):
    PASSIVE = 0x0
    ACTIVE = 0x1

class LeExScanFilterPolicy(enum.IntEnum):
    ACCEPT_ALL = 0x0
    FILTER_ACCEPT_LIST_ONLY = 0x1

@dataclass
class LeExSetScanParameters(Command):
    le_ex_scan_type: LeExScanType = field(kw_only=True, default=LeExScanType.PASSIVE)
    le_ex_scan_interval: int = field(kw_only=True, default=0)
    le_ex_scan_window: int = field(kw_only=True, default=0)
    own_address_type: OwnAddressType = field(kw_only=True, default=OwnAddressType.PUBLIC_DEVICE_ADDRESS)
    le_ex_scan_filter_policy: LeExScanFilterPolicy = field(kw_only=True, default=LeExScanFilterPolicy.ACCEPT_ALL)

    def __post_init__(self):
        self.op_code = OpCode.LE_EX_SET_SCAN_PARAMETERS

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeExSetScanParameters', bytes]:
        if fields['op_code'] != OpCode.LE_EX_SET_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 11:
            raise Exception('Invalid packet size')
        fields['le_ex_scan_type'] = LeExScanType(span[0])
        value_ = int.from_bytes(span[1:5], byteorder='little')
        fields['le_ex_scan_interval'] = value_
        value_ = int.from_bytes(span[5:9], byteorder='little')
        fields['le_ex_scan_window'] = value_
        fields['own_address_type'] = OwnAddressType(span[9])
        fields['le_ex_scan_filter_policy'] = LeExScanFilterPolicy(span[10])
        span = span[11:]
        return LeExSetScanParameters(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.le_ex_scan_type << 0))
        if self.le_ex_scan_interval > 4294967295:
            print(f"Invalid value for field LeExSetScanParameters::le_ex_scan_interval: {self.le_ex_scan_interval} > 4294967295; the value will be truncated")
            self.le_ex_scan_interval &= 4294967295
        _span.extend(int.to_bytes((self.le_ex_scan_interval << 0), length=4, byteorder='little'))
        if self.le_ex_scan_window > 4294967295:
            print(f"Invalid value for field LeExSetScanParameters::le_ex_scan_window: {self.le_ex_scan_window} > 4294967295; the value will be truncated")
            self.le_ex_scan_window &= 4294967295
        _span.extend(int.to_bytes((self.le_ex_scan_window << 0), length=4, byteorder='little'))
        _span.append((self.own_address_type << 0))
        _span.append((self.le_ex_scan_filter_policy << 0))
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 11

@dataclass
class LeExSetScanParametersComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.LE_EX_SET_SCAN_PARAMETERS
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['LeExSetScanParametersComplete', bytes]:
        if fields['command_op_code'] != OpCode.LE_EX_SET_SCAN_PARAMETERS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return LeExSetScanParametersComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class GetControllerDebugInfo(Command):
    

    def __post_init__(self):
        self.op_code = OpCode.GET_CONTROLLER_DEBUG_INFO

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['GetControllerDebugInfo', bytes]:
        if fields['op_code'] != OpCode.GET_CONTROLLER_DEBUG_INFO:
            raise Exception("Invalid constraint field values")
        return GetControllerDebugInfo(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class GetControllerDebugInfoComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)

    def __post_init__(self):
        self.command_op_code = OpCode.GET_CONTROLLER_DEBUG_INFO
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['GetControllerDebugInfoComplete', bytes]:
        if fields['command_op_code'] != OpCode.GET_CONTROLLER_DEBUG_INFO:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        span = span[1:]
        return GetControllerDebugInfoComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class ControllerDebugInfoEvent(VendorSpecificEvent):
    debug_block_byte_offset_start: int = field(kw_only=True, default=0)
    last_block: int = field(kw_only=True, default=0)
    debug_data: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subevent_code = VseSubeventCode.CONTROLLER_DEBUG_INFO
        self.event_code = EventCode.VENDOR_SPECIFIC

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['ControllerDebugInfoEvent', bytes]:
        if fields['subevent_code'] != VseSubeventCode.CONTROLLER_DEBUG_INFO:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:2], byteorder='little')
        fields['debug_block_byte_offset_start'] = value_
        fields['last_block'] = span[2]
        value_ = int.from_bytes(span[3:5], byteorder='little')
        debug_data_size = value_
        span = span[5:]
        if len(span) < debug_data_size:
            raise Exception('Invalid packet size')
        fields['debug_data'] = list(span[:debug_data_size])
        span = span[debug_data_size:]
        return ControllerDebugInfoEvent(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.debug_block_byte_offset_start > 65535:
            print(f"Invalid value for field ControllerDebugInfoEvent::debug_block_byte_offset_start: {self.debug_block_byte_offset_start} > 65535; the value will be truncated")
            self.debug_block_byte_offset_start &= 65535
        _span.extend(int.to_bytes((self.debug_block_byte_offset_start << 0), length=2, byteorder='little'))
        if self.last_block > 255:
            print(f"Invalid value for field ControllerDebugInfoEvent::last_block: {self.last_block} > 255; the value will be truncated")
            self.last_block &= 255
        _span.append((self.last_block << 0))
        _span.extend(int.to_bytes(((len(self.debug_data) * 1) << 0), length=2, byteorder='little'))
        _span.extend(self.debug_data)
        return VendorSpecificEvent.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.debug_data) * 1 + 5

class MsftSubcommandOpcode(enum.IntEnum):
    MSFT_READ_SUPPORTED_FEATURES = 0x0
    MSFT_MONITOR_RSSI = 0x1
    MSFT_CANCEL_MONITOR_RSSI = 0x2
    MSFT_LE_MONITOR_ADV = 0x3
    MSFT_LE_CANCEL_MONITOR_ADV = 0x4
    MSFT_LE_SET_ADV_FILTER_ENABLE = 0x5
    MSFT_READ_ABSOLUTE_RSSI = 0x6

@dataclass
class MsftCommand(Command):
    subcommand_opcode: MsftSubcommandOpcode = field(kw_only=True, default=MsftSubcommandOpcode.MSFT_READ_SUPPORTED_FEATURES)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftCommand', bytes]:
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['subcommand_opcode'] = MsftSubcommandOpcode(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return MsftReadSupportedFeatures.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeMonitorAdv.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeCancelMonitorAdv.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeSetAdvFilterEnable.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return MsftCommand(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.subcommand_opcode << 0))
        _span.extend(payload or self.payload or [])
        return Command.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class MsftReadSupportedFeatures(MsftCommand):
    

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_READ_SUPPORTED_FEATURES

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftReadSupportedFeatures', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_READ_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        return MsftReadSupportedFeatures(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return MsftCommand.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class MsftLeMonitorAdvConditionType(enum.IntEnum):
    MSFT_CONDITION_TYPE_PATTERNS = 0x1
    MSFT_CONDITION_TYPE_UUID = 0x2
    MSFT_CONDITION_TYPE_IRK_RESOLUTION = 0x3
    MSFT_CONDITION_TYPE_ADDRESS = 0x4

class MsftLeMonitorAdvConditionUuidType(enum.IntEnum):
    MSFT_CONDITION_UUID_TYPE_16_BIT = 0x1
    MSFT_CONDITION_UUID_TYPE_32_BIT = 0x2
    MSFT_CONDITION_UUID_TYPE_128_BIT = 0x3

@dataclass
class MsftLeMonitorAdv(MsftCommand):
    rssi_threshold_high: int = field(kw_only=True, default=0)
    rssi_threshold_low: int = field(kw_only=True, default=0)
    rssi_threshold_low_time_interval: int = field(kw_only=True, default=0)
    rssi_sampling_period: int = field(kw_only=True, default=0)
    condition_type: MsftLeMonitorAdvConditionType = field(kw_only=True, default=MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_PATTERNS)

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorAdv', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV:
            raise Exception("Invalid constraint field values")
        if len(span) < 5:
            raise Exception('Invalid packet size')
        fields['rssi_threshold_high'] = span[0]
        fields['rssi_threshold_low'] = span[1]
        fields['rssi_threshold_low_time_interval'] = span[2]
        fields['rssi_sampling_period'] = span[3]
        fields['condition_type'] = MsftLeMonitorAdvConditionType(span[4])
        span = span[5:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return MsftLeMonitorAdvConditionPatterns.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeMonitorAdvConditionUuid.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return MsftLeMonitorAdv(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.rssi_threshold_high > 255:
            print(f"Invalid value for field MsftLeMonitorAdv::rssi_threshold_high: {self.rssi_threshold_high} > 255; the value will be truncated")
            self.rssi_threshold_high &= 255
        _span.append((self.rssi_threshold_high << 0))
        if self.rssi_threshold_low > 255:
            print(f"Invalid value for field MsftLeMonitorAdv::rssi_threshold_low: {self.rssi_threshold_low} > 255; the value will be truncated")
            self.rssi_threshold_low &= 255
        _span.append((self.rssi_threshold_low << 0))
        if self.rssi_threshold_low_time_interval > 255:
            print(f"Invalid value for field MsftLeMonitorAdv::rssi_threshold_low_time_interval: {self.rssi_threshold_low_time_interval} > 255; the value will be truncated")
            self.rssi_threshold_low_time_interval &= 255
        _span.append((self.rssi_threshold_low_time_interval << 0))
        if self.rssi_sampling_period > 255:
            print(f"Invalid value for field MsftLeMonitorAdv::rssi_sampling_period: {self.rssi_sampling_period} > 255; the value will be truncated")
            self.rssi_sampling_period &= 255
        _span.append((self.rssi_sampling_period << 0))
        _span.append((self.condition_type << 0))
        _span.extend(payload or self.payload or [])
        return MsftCommand.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 5

@dataclass
class MsftLeMonitorAdvConditionPattern(Packet):
    ad_type: int = field(kw_only=True, default=0)
    start_of_pattern: int = field(kw_only=True, default=0)
    pattern: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['MsftLeMonitorAdvConditionPattern', bytes]:
        fields = {'payload': None}
        if len(span) < 3:
            raise Exception('Invalid packet size')
        pattern_size = span[0]
        fields['ad_type'] = span[1]
        fields['start_of_pattern'] = span[2]
        span = span[3:]
        if len(span) < pattern_size - +2:
            raise Exception('Invalid packet size')
        fields['pattern'] = list(span[:pattern_size - +2])
        span = span[pattern_size - +2:]
        return MsftLeMonitorAdvConditionPattern(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append(((len(self.pattern) * 1 + +2) << 0))
        if self.ad_type > 255:
            print(f"Invalid value for field MsftLeMonitorAdvConditionPattern::ad_type: {self.ad_type} > 255; the value will be truncated")
            self.ad_type &= 255
        _span.append((self.ad_type << 0))
        if self.start_of_pattern > 255:
            print(f"Invalid value for field MsftLeMonitorAdvConditionPattern::start_of_pattern: {self.start_of_pattern} > 255; the value will be truncated")
            self.start_of_pattern &= 255
        _span.append((self.start_of_pattern << 0))
        _span.extend(self.pattern)
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.pattern) * 1 + 3

@dataclass
class MsftLeMonitorAdvConditionPatterns(MsftLeMonitorAdv):
    patterns: List[MsftLeMonitorAdvConditionPattern] = field(kw_only=True, default_factory=list)

    def __post_init__(self):
        self.condition_type = MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_PATTERNS
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorAdvConditionPatterns', bytes]:
        if fields['condition_type'] != MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_PATTERNS:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        patterns_count = span[0]
        span = span[1:]
        patterns = []
        for n in range(patterns_count):
            element, span = MsftLeMonitorAdvConditionPattern.parse(span)
            patterns.append(element)
        fields['patterns'] = patterns
        return MsftLeMonitorAdvConditionPatterns(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if len(self.patterns) > 255:
            print(f"Invalid length for field MsftLeMonitorAdvConditionPatterns::patterns:  {len(self.patterns)} > 255; the array will be truncated")
            del self.patterns[255:]
        _span.append((len(self.patterns) << 0))
        for _elt in self.patterns:
            _span.extend(_elt.serialize())
        return MsftLeMonitorAdv.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return sum([elt.size for elt in self.patterns]) + 1

@dataclass
class MsftLeMonitorAdvConditionUuid(MsftLeMonitorAdv):
    uuid_type: MsftLeMonitorAdvConditionUuidType = field(kw_only=True, default=MsftLeMonitorAdvConditionUuidType.MSFT_CONDITION_UUID_TYPE_16_BIT)

    def __post_init__(self):
        self.condition_type = MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_UUID
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorAdvConditionUuid', bytes]:
        if fields['condition_type'] != MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_UUID:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['uuid_type'] = MsftLeMonitorAdvConditionUuidType(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return MsftLeMonitorAdvConditionUuid2.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeMonitorAdvConditionUuid4.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeMonitorAdvConditionUuid16.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return MsftLeMonitorAdvConditionUuid(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.uuid_type << 0))
        _span.extend(payload or self.payload or [])
        return MsftLeMonitorAdv.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class MsftLeMonitorAdvConditionUuid2(MsftLeMonitorAdvConditionUuid):
    uuid2: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.uuid_type = MsftLeMonitorAdvConditionUuidType.MSFT_CONDITION_UUID_TYPE_16_BIT
        self.condition_type = MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_UUID
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorAdvConditionUuid2', bytes]:
        if fields['uuid_type'] != MsftLeMonitorAdvConditionUuidType.MSFT_CONDITION_UUID_TYPE_16_BIT:
            raise Exception("Invalid constraint field values")
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['uuid2'] = list(span[:2])
        span = span[2:]
        return MsftLeMonitorAdvConditionUuid2(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.uuid2)
        return MsftLeMonitorAdvConditionUuid.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 2

@dataclass
class MsftLeMonitorAdvConditionUuid4(MsftLeMonitorAdvConditionUuid):
    uuid4: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.uuid_type = MsftLeMonitorAdvConditionUuidType.MSFT_CONDITION_UUID_TYPE_32_BIT
        self.condition_type = MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_UUID
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorAdvConditionUuid4', bytes]:
        if fields['uuid_type'] != MsftLeMonitorAdvConditionUuidType.MSFT_CONDITION_UUID_TYPE_32_BIT:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['uuid4'] = list(span[:4])
        span = span[4:]
        return MsftLeMonitorAdvConditionUuid4(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.uuid4)
        return MsftLeMonitorAdvConditionUuid.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class MsftLeMonitorAdvConditionUuid16(MsftLeMonitorAdvConditionUuid):
    uuid16: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.uuid_type = MsftLeMonitorAdvConditionUuidType.MSFT_CONDITION_UUID_TYPE_128_BIT
        self.condition_type = MsftLeMonitorAdvConditionType.MSFT_CONDITION_TYPE_UUID
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorAdvConditionUuid16', bytes]:
        if fields['uuid_type'] != MsftLeMonitorAdvConditionUuidType.MSFT_CONDITION_UUID_TYPE_128_BIT:
            raise Exception("Invalid constraint field values")
        if len(span) < 16:
            raise Exception('Invalid packet size')
        fields['uuid16'] = list(span[:16])
        span = span[16:]
        return MsftLeMonitorAdvConditionUuid16(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.extend(self.uuid16)
        return MsftLeMonitorAdvConditionUuid.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 16

@dataclass
class MsftLeCancelMonitorAdv(MsftCommand):
    monitor_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_CANCEL_MONITOR_ADV

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeCancelMonitorAdv', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_LE_CANCEL_MONITOR_ADV:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['monitor_handle'] = span[0]
        span = span[1:]
        return MsftLeCancelMonitorAdv(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.monitor_handle > 255:
            print(f"Invalid value for field MsftLeCancelMonitorAdv::monitor_handle: {self.monitor_handle} > 255; the value will be truncated")
            self.monitor_handle &= 255
        _span.append((self.monitor_handle << 0))
        return MsftCommand.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class MsftLeSetAdvFilterEnable(MsftCommand):
    enable: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_SET_ADV_FILTER_ENABLE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeSetAdvFilterEnable', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_LE_SET_ADV_FILTER_ENABLE:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['enable'] = span[0]
        span = span[1:]
        return MsftLeSetAdvFilterEnable(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.enable > 255:
            print(f"Invalid value for field MsftLeSetAdvFilterEnable::enable: {self.enable} > 255; the value will be truncated")
            self.enable &= 255
        _span.append((self.enable << 0))
        return MsftCommand.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class MsftCommandComplete(CommandComplete):
    status: ErrorCode = field(kw_only=True, default=ErrorCode.STATUS_UNKNOWN)
    subcommand_opcode: MsftSubcommandOpcode = field(kw_only=True, default=MsftSubcommandOpcode.MSFT_READ_SUPPORTED_FEATURES)

    def __post_init__(self):
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftCommandComplete', bytes]:
        if len(span) < 2:
            raise Exception('Invalid packet size')
        fields['status'] = ErrorCode(span[0])
        fields['subcommand_opcode'] = MsftSubcommandOpcode(span[1])
        span = span[2:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return MsftReadSupportedFeaturesCommandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeMonitorAdvCommandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeCancelMonitorAdvCommandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeSetAdvFilterEnableCommandComplete.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return MsftCommandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        _span.append((self.subcommand_opcode << 0))
        _span.extend(payload or self.payload or [])
        return CommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.payload) + 2

@dataclass
class MsftReadSupportedFeaturesCommandComplete(MsftCommandComplete):
    supported_features: int = field(kw_only=True, default=0)
    prefix: bytearray = field(kw_only=True, default_factory=bytearray)

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_READ_SUPPORTED_FEATURES
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftReadSupportedFeaturesCommandComplete', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_READ_SUPPORTED_FEATURES:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        value_ = int.from_bytes(span[0:8], byteorder='little')
        fields['supported_features'] = value_
        prefix_size = span[8]
        span = span[9:]
        if len(span) < prefix_size:
            raise Exception('Invalid packet size')
        fields['prefix'] = list(span[:prefix_size])
        span = span[prefix_size:]
        return MsftReadSupportedFeaturesCommandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.supported_features > 18446744073709551615:
            print(f"Invalid value for field MsftReadSupportedFeaturesCommandComplete::supported_features: {self.supported_features} > 18446744073709551615; the value will be truncated")
            self.supported_features &= 18446744073709551615
        _span.extend(int.to_bytes((self.supported_features << 0), length=8, byteorder='little'))
        _span.append(((len(self.prefix) * 1) << 0))
        _span.extend(self.prefix)
        return MsftCommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return len(self.prefix) * 1 + 9

@dataclass
class MsftLeMonitorAdvCommandComplete(MsftCommandComplete):
    monitor_handle: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorAdvCommandComplete', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_LE_MONITOR_ADV:
            raise Exception("Invalid constraint field values")
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['monitor_handle'] = span[0]
        span = span[1:]
        return MsftLeMonitorAdvCommandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.monitor_handle > 255:
            print(f"Invalid value for field MsftLeMonitorAdvCommandComplete::monitor_handle: {self.monitor_handle} > 255; the value will be truncated")
            self.monitor_handle &= 255
        _span.append((self.monitor_handle << 0))
        return MsftCommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 1

@dataclass
class MsftLeCancelMonitorAdvCommandComplete(MsftCommandComplete):
    

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_CANCEL_MONITOR_ADV
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeCancelMonitorAdvCommandComplete', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_LE_CANCEL_MONITOR_ADV:
            raise Exception("Invalid constraint field values")
        return MsftLeCancelMonitorAdvCommandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return MsftCommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

@dataclass
class MsftLeSetAdvFilterEnableCommandComplete(MsftCommandComplete):
    

    def __post_init__(self):
        self.subcommand_opcode = MsftSubcommandOpcode.MSFT_LE_SET_ADV_FILTER_ENABLE
        self.event_code = EventCode.COMMAND_COMPLETE

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeSetAdvFilterEnableCommandComplete', bytes]:
        if fields['subcommand_opcode'] != MsftSubcommandOpcode.MSFT_LE_SET_ADV_FILTER_ENABLE:
            raise Exception("Invalid constraint field values")
        return MsftLeSetAdvFilterEnableCommandComplete(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        return MsftCommandComplete.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 0

class MsftEventCode(enum.IntEnum):
    MSFT_RSSI_EVENT = 0x1
    MSFT_LE_MONITOR_DEVICE_EVENT = 0x2

class MsftEventStatus(enum.IntEnum):
    MSFT_EVENT_STATUS_SUCCESS = 0x0
    MSFT_EVENT_STATUS_FAILURE = 0x1

@dataclass
class MsftEventPayload(Packet):
    msft_event_code: MsftEventCode = field(kw_only=True, default=MsftEventCode.MSFT_RSSI_EVENT)

    def __post_init__(self):
        pass

    @staticmethod
    def parse(span: bytes) -> Tuple['MsftEventPayload', bytes]:
        fields = {'payload': None}
        if len(span) < 1:
            raise Exception('Invalid packet size')
        fields['msft_event_code'] = MsftEventCode(span[0])
        span = span[1:]
        payload = span
        span = bytes([])
        fields['payload'] = payload
        try:
            return MsftRssiEventPayload.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        try:
            return MsftLeMonitorDeviceEventPayload.parse(fields.copy(), payload)
        except Exception as exn:
            pass
        return MsftEventPayload(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.msft_event_code << 0))
        _span.extend(payload or self.payload or [])
        return bytes(_span)

    @property
    def size(self) -> int:
        return len(self.payload) + 1

@dataclass
class MsftRssiEventPayload(MsftEventPayload):
    status: MsftEventStatus = field(kw_only=True, default=MsftEventStatus.MSFT_EVENT_STATUS_SUCCESS)
    connection_handle: int = field(kw_only=True, default=0)
    rssi: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.msft_event_code = MsftEventCode.MSFT_RSSI_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftRssiEventPayload', bytes]:
        if fields['msft_event_code'] != MsftEventCode.MSFT_RSSI_EVENT:
            raise Exception("Invalid constraint field values")
        if len(span) < 4:
            raise Exception('Invalid packet size')
        fields['status'] = MsftEventStatus(span[0])
        value_ = int.from_bytes(span[1:3], byteorder='little')
        fields['connection_handle'] = value_
        fields['rssi'] = span[3]
        span = span[4:]
        return MsftRssiEventPayload(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        _span.append((self.status << 0))
        if self.connection_handle > 65535:
            print(f"Invalid value for field MsftRssiEventPayload::connection_handle: {self.connection_handle} > 65535; the value will be truncated")
            self.connection_handle &= 65535
        _span.extend(int.to_bytes((self.connection_handle << 0), length=2, byteorder='little'))
        if self.rssi > 255:
            print(f"Invalid value for field MsftRssiEventPayload::rssi: {self.rssi} > 255; the value will be truncated")
            self.rssi &= 255
        _span.append((self.rssi << 0))
        return MsftEventPayload.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 4

@dataclass
class MsftLeMonitorDeviceEventPayload(MsftEventPayload):
    address_type: int = field(kw_only=True, default=0)
    bd_addr: Address = field(kw_only=True, default_factory=Address)
    monitor_handle: int = field(kw_only=True, default=0)
    monitor_state: int = field(kw_only=True, default=0)

    def __post_init__(self):
        self.msft_event_code = MsftEventCode.MSFT_LE_MONITOR_DEVICE_EVENT

    @staticmethod
    def parse(fields: dict, span: bytes) -> Tuple['MsftLeMonitorDeviceEventPayload', bytes]:
        if fields['msft_event_code'] != MsftEventCode.MSFT_LE_MONITOR_DEVICE_EVENT:
            raise Exception("Invalid constraint field values")
        if len(span) < 9:
            raise Exception('Invalid packet size')
        fields['address_type'] = span[0]
        fields['bd_addr'] = Address.parse_all(span[1:7])
        fields['monitor_handle'] = span[7]
        fields['monitor_state'] = span[8]
        span = span[9:]
        return MsftLeMonitorDeviceEventPayload(**fields), span

    def serialize(self, payload: bytes = None) -> bytes:
        _span = bytearray()
        if self.address_type > 255:
            print(f"Invalid value for field MsftLeMonitorDeviceEventPayload::address_type: {self.address_type} > 255; the value will be truncated")
            self.address_type &= 255
        _span.append((self.address_type << 0))
        _span.extend(self.bd_addr.serialize())
        if self.monitor_handle > 255:
            print(f"Invalid value for field MsftLeMonitorDeviceEventPayload::monitor_handle: {self.monitor_handle} > 255; the value will be truncated")
            self.monitor_handle &= 255
        _span.append((self.monitor_handle << 0))
        if self.monitor_state > 255:
            print(f"Invalid value for field MsftLeMonitorDeviceEventPayload::monitor_state: {self.monitor_state} > 255; the value will be truncated")
            self.monitor_state &= 255
        _span.append((self.monitor_state << 0))
        return MsftEventPayload.serialize(self, payload = bytes(_span))

    @property
    def size(self) -> int:
        return 9
