# coding: utf-8

"""
    Slack Web API

    One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

    The version of the OpenAPI document: 1.7.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Optional, Union
from typing_extensions import Annotated
from slack_ti.models.default_success_template import DefaultSuccessTemplate
from slack_ti.models.files_comments_delete_schema import FilesCommentsDeleteSchema
from slack_ti.models.files_delete_schema import FilesDeleteSchema
from slack_ti.models.files_info_schema import FilesInfoSchema
from slack_ti.models.files_list_schema import FilesListSchema
from slack_ti.models.files_revoke_public_url_schema import FilesRevokePublicURLSchema
from slack_ti.models.files_shared_public_url_schema import FilesSharedPublicURLSchema
from slack_ti.models.files_upload_schema import FilesUploadSchema

from slack_ti.api_client import ApiClient, RequestSerialized
from slack_ti.api_response import ApiResponse
from slack_ti.rest import RESTResponseType


class FilesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def files_comments_delete_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to delete a comment from.")] = None,
        id: Annotated[Optional[StrictStr], Field(description="The comment to delete.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> FilesCommentsDeleteSchema:
        """files_comments_delete_0

        Deletes an existing comment on a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to delete a comment from.
        :type file: str
        :param id: The comment to delete.
        :type id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_comments_delete_0_serialize(
            token=token,
            file=file,
            id=id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesCommentsDeleteSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_comments_delete_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to delete a comment from.")] = None,
        id: Annotated[Optional[StrictStr], Field(description="The comment to delete.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[FilesCommentsDeleteSchema]:
        """files_comments_delete_0

        Deletes an existing comment on a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to delete a comment from.
        :type file: str
        :param id: The comment to delete.
        :type id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_comments_delete_0_serialize(
            token=token,
            file=file,
            id=id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesCommentsDeleteSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_comments_delete_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to delete a comment from.")] = None,
        id: Annotated[Optional[StrictStr], Field(description="The comment to delete.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_comments_delete_0

        Deletes an existing comment on a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to delete a comment from.
        :type file: str
        :param id: The comment to delete.
        :type id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_comments_delete_0_serialize(
            token=token,
            file=file,
            id=id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesCommentsDeleteSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_comments_delete_0_serialize(
        self,
        token,
        file,
        id,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if file is not None:
            _form_params.append(('file', file))
        if id is not None:
            _form_params.append(('id', id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.comments.delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_delete(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="ID of file to delete.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> FilesDeleteSchema:
        """files_delete

        Deletes a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: ID of file to delete.
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_delete_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesDeleteSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_delete_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="ID of file to delete.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[FilesDeleteSchema]:
        """files_delete

        Deletes a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: ID of file to delete.
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_delete_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesDeleteSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_delete_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="ID of file to delete.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_delete

        Deletes a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: ID of file to delete.
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_delete_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesDeleteSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_delete_serialize(
        self,
        token,
        file,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if file is not None:
            _form_params.append(('file', file))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:read`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        count: Optional[StrictStr] = None,
        page: Optional[StrictStr] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> FilesInfoSchema:
        """files_info

        Gets information about a file.

        :param token: Authentication token. Requires scope: `files:read`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param count:
        :type count: str
        :param page:
        :type page: str
        :param limit: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.
        :type limit: int
        :param cursor: Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details.
        :type cursor: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_info_serialize(
            token=token,
            file=file,
            count=count,
            page=page,
            limit=limit,
            cursor=cursor,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesInfoSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_info_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:read`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        count: Optional[StrictStr] = None,
        page: Optional[StrictStr] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[FilesInfoSchema]:
        """files_info

        Gets information about a file.

        :param token: Authentication token. Requires scope: `files:read`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param count:
        :type count: str
        :param page:
        :type page: str
        :param limit: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.
        :type limit: int
        :param cursor: Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details.
        :type cursor: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_info_serialize(
            token=token,
            file=file,
            count=count,
            page=page,
            limit=limit,
            cursor=cursor,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesInfoSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_info_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:read`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        count: Optional[StrictStr] = None,
        page: Optional[StrictStr] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_info

        Gets information about a file.

        :param token: Authentication token. Requires scope: `files:read`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param count:
        :type count: str
        :param page:
        :type page: str
        :param limit: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.
        :type limit: int
        :param cursor: Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](/docs/pagination) for more details.
        :type cursor: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_info_serialize(
            token=token,
            file=file,
            count=count,
            page=page,
            limit=limit,
            cursor=cursor,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesInfoSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_info_serialize(
        self,
        token,
        file,
        count,
        page,
        limit,
        cursor,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if file is not None:
            
            _query_params.append(('file', file))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files.info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_list(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:read`")] = None,
        user: Annotated[Optional[StrictStr], Field(description="Filter files created by a single user.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Filter files appearing in a specific channel, indicated by its ID.")] = None,
        ts_from: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created after this timestamp (inclusive).")] = None,
        ts_to: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created before this timestamp (inclusive).")] = None,
        types: Annotated[Optional[StrictStr], Field(description="Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.")] = None,
        count: Optional[StrictStr] = None,
        page: Optional[StrictStr] = None,
        show_files_hidden_by_limit: Annotated[Optional[StrictBool], Field(description="Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> FilesListSchema:
        """files_list

        List for a team, in a channel, or from a user with applied filters.

        :param token: Authentication token. Requires scope: `files:read`
        :type token: str
        :param user: Filter files created by a single user.
        :type user: str
        :param channel: Filter files appearing in a specific channel, indicated by its ID.
        :type channel: str
        :param ts_from: Filter files created after this timestamp (inclusive).
        :type ts_from: float
        :param ts_to: Filter files created before this timestamp (inclusive).
        :type ts_to: float
        :param types: Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.
        :type types: str
        :param count:
        :type count: str
        :param page:
        :type page: str
        :param show_files_hidden_by_limit: Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.
        :type show_files_hidden_by_limit: bool
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_list_serialize(
            token=token,
            user=user,
            channel=channel,
            ts_from=ts_from,
            ts_to=ts_to,
            types=types,
            count=count,
            page=page,
            show_files_hidden_by_limit=show_files_hidden_by_limit,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesListSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_list_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:read`")] = None,
        user: Annotated[Optional[StrictStr], Field(description="Filter files created by a single user.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Filter files appearing in a specific channel, indicated by its ID.")] = None,
        ts_from: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created after this timestamp (inclusive).")] = None,
        ts_to: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created before this timestamp (inclusive).")] = None,
        types: Annotated[Optional[StrictStr], Field(description="Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.")] = None,
        count: Optional[StrictStr] = None,
        page: Optional[StrictStr] = None,
        show_files_hidden_by_limit: Annotated[Optional[StrictBool], Field(description="Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[FilesListSchema]:
        """files_list

        List for a team, in a channel, or from a user with applied filters.

        :param token: Authentication token. Requires scope: `files:read`
        :type token: str
        :param user: Filter files created by a single user.
        :type user: str
        :param channel: Filter files appearing in a specific channel, indicated by its ID.
        :type channel: str
        :param ts_from: Filter files created after this timestamp (inclusive).
        :type ts_from: float
        :param ts_to: Filter files created before this timestamp (inclusive).
        :type ts_to: float
        :param types: Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.
        :type types: str
        :param count:
        :type count: str
        :param page:
        :type page: str
        :param show_files_hidden_by_limit: Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.
        :type show_files_hidden_by_limit: bool
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_list_serialize(
            token=token,
            user=user,
            channel=channel,
            ts_from=ts_from,
            ts_to=ts_to,
            types=types,
            count=count,
            page=page,
            show_files_hidden_by_limit=show_files_hidden_by_limit,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesListSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_list_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:read`")] = None,
        user: Annotated[Optional[StrictStr], Field(description="Filter files created by a single user.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Filter files appearing in a specific channel, indicated by its ID.")] = None,
        ts_from: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created after this timestamp (inclusive).")] = None,
        ts_to: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created before this timestamp (inclusive).")] = None,
        types: Annotated[Optional[StrictStr], Field(description="Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.")] = None,
        count: Optional[StrictStr] = None,
        page: Optional[StrictStr] = None,
        show_files_hidden_by_limit: Annotated[Optional[StrictBool], Field(description="Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_list

        List for a team, in a channel, or from a user with applied filters.

        :param token: Authentication token. Requires scope: `files:read`
        :type token: str
        :param user: Filter files created by a single user.
        :type user: str
        :param channel: Filter files appearing in a specific channel, indicated by its ID.
        :type channel: str
        :param ts_from: Filter files created after this timestamp (inclusive).
        :type ts_from: float
        :param ts_to: Filter files created before this timestamp (inclusive).
        :type ts_to: float
        :param types: Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.
        :type types: str
        :param count:
        :type count: str
        :param page:
        :type page: str
        :param show_files_hidden_by_limit: Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.
        :type show_files_hidden_by_limit: bool
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_list_serialize(
            token=token,
            user=user,
            channel=channel,
            ts_from=ts_from,
            ts_to=ts_to,
            types=types,
            count=count,
            page=page,
            show_files_hidden_by_limit=show_files_hidden_by_limit,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesListSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_list_serialize(
        self,
        token,
        user,
        channel,
        ts_from,
        ts_to,
        types,
        count,
        page,
        show_files_hidden_by_limit,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if user is not None:
            
            _query_params.append(('user', user))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if ts_from is not None:
            
            _query_params.append(('ts_from', ts_from))
            
        if ts_to is not None:
            
            _query_params.append(('ts_to', ts_to))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if show_files_hidden_by_limit is not None:
            
            _query_params.append(('show_files_hidden_by_limit', show_files_hidden_by_limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files.list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_remote_add_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of the file being shared.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="type of file")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="URL of the remote file.")] = None,
        preview_image: Annotated[Optional[StrictStr], Field(description="Preview of the document via `multipart/form-data`.")] = None,
        indexable_file_contents: Annotated[Optional[StrictStr], Field(description="A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> DefaultSuccessTemplate:
        """files_remote_add_0

        Adds a file from a remote service

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :param title: Title of the file being shared.
        :type title: str
        :param filetype: type of file
        :type filetype: str
        :param external_url: URL of the remote file.
        :type external_url: str
        :param preview_image: Preview of the document via `multipart/form-data`.
        :type preview_image: str
        :param indexable_file_contents: A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
        :type indexable_file_contents: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_add_0_serialize(
            token=token,
            external_id=external_id,
            title=title,
            filetype=filetype,
            external_url=external_url,
            preview_image=preview_image,
            indexable_file_contents=indexable_file_contents,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_remote_add_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of the file being shared.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="type of file")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="URL of the remote file.")] = None,
        preview_image: Annotated[Optional[StrictStr], Field(description="Preview of the document via `multipart/form-data`.")] = None,
        indexable_file_contents: Annotated[Optional[StrictStr], Field(description="A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[DefaultSuccessTemplate]:
        """files_remote_add_0

        Adds a file from a remote service

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :param title: Title of the file being shared.
        :type title: str
        :param filetype: type of file
        :type filetype: str
        :param external_url: URL of the remote file.
        :type external_url: str
        :param preview_image: Preview of the document via `multipart/form-data`.
        :type preview_image: str
        :param indexable_file_contents: A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
        :type indexable_file_contents: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_add_0_serialize(
            token=token,
            external_id=external_id,
            title=title,
            filetype=filetype,
            external_url=external_url,
            preview_image=preview_image,
            indexable_file_contents=indexable_file_contents,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_remote_add_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of the file being shared.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="type of file")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="URL of the remote file.")] = None,
        preview_image: Annotated[Optional[StrictStr], Field(description="Preview of the document via `multipart/form-data`.")] = None,
        indexable_file_contents: Annotated[Optional[StrictStr], Field(description="A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_remote_add_0

        Adds a file from a remote service

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :param title: Title of the file being shared.
        :type title: str
        :param filetype: type of file
        :type filetype: str
        :param external_url: URL of the remote file.
        :type external_url: str
        :param preview_image: Preview of the document via `multipart/form-data`.
        :type preview_image: str
        :param indexable_file_contents: A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
        :type indexable_file_contents: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_add_0_serialize(
            token=token,
            external_id=external_id,
            title=title,
            filetype=filetype,
            external_url=external_url,
            preview_image=preview_image,
            indexable_file_contents=indexable_file_contents,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_remote_add_0_serialize(
        self,
        token,
        external_id,
        title,
        filetype,
        external_url,
        preview_image,
        indexable_file_contents,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(('token', token))
        if external_id is not None:
            _form_params.append(('external_id', external_id))
        if title is not None:
            _form_params.append(('title', title))
        if filetype is not None:
            _form_params.append(('filetype', filetype))
        if external_url is not None:
            _form_params.append(('external_url', external_url))
        if preview_image is not None:
            _form_params.append(('preview_image', preview_image))
        if indexable_file_contents is not None:
            _form_params.append(('indexable_file_contents', indexable_file_contents))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.remote.add',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_remote_info_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:read`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> DefaultSuccessTemplate:
        """files_remote_info_0

        Retrieve information about a remote file added to Slack

        :param token: Authentication token. Requires scope: `remote_files:read`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_info_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_remote_info_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:read`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[DefaultSuccessTemplate]:
        """files_remote_info_0

        Retrieve information about a remote file added to Slack

        :param token: Authentication token. Requires scope: `remote_files:read`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_info_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_remote_info_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:read`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_remote_info_0

        Retrieve information about a remote file added to Slack

        :param token: Authentication token. Requires scope: `remote_files:read`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_info_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_remote_info_0_serialize(
        self,
        token,
        file,
        external_id,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if file is not None:
            
            _query_params.append(('file', file))
            
        if external_id is not None:
            
            _query_params.append(('external_id', external_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files.remote.info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_remote_list_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:read`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Filter files appearing in a specific channel, indicated by its ID.")] = None,
        ts_from: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created after this timestamp (inclusive).")] = None,
        ts_to: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created before this timestamp (inclusive).")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of items to return.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> DefaultSuccessTemplate:
        """files_remote_list_0

        Retrieve information about a remote file added to Slack

        :param token: Authentication token. Requires scope: `remote_files:read`
        :type token: str
        :param channel: Filter files appearing in a specific channel, indicated by its ID.
        :type channel: str
        :param ts_from: Filter files created after this timestamp (inclusive).
        :type ts_from: float
        :param ts_to: Filter files created before this timestamp (inclusive).
        :type ts_to: float
        :param limit: The maximum number of items to return.
        :type limit: int
        :param cursor: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
        :type cursor: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_list_0_serialize(
            token=token,
            channel=channel,
            ts_from=ts_from,
            ts_to=ts_to,
            limit=limit,
            cursor=cursor,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_remote_list_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:read`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Filter files appearing in a specific channel, indicated by its ID.")] = None,
        ts_from: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created after this timestamp (inclusive).")] = None,
        ts_to: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created before this timestamp (inclusive).")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of items to return.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[DefaultSuccessTemplate]:
        """files_remote_list_0

        Retrieve information about a remote file added to Slack

        :param token: Authentication token. Requires scope: `remote_files:read`
        :type token: str
        :param channel: Filter files appearing in a specific channel, indicated by its ID.
        :type channel: str
        :param ts_from: Filter files created after this timestamp (inclusive).
        :type ts_from: float
        :param ts_to: Filter files created before this timestamp (inclusive).
        :type ts_to: float
        :param limit: The maximum number of items to return.
        :type limit: int
        :param cursor: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
        :type cursor: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_list_0_serialize(
            token=token,
            channel=channel,
            ts_from=ts_from,
            ts_to=ts_to,
            limit=limit,
            cursor=cursor,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_remote_list_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:read`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Filter files appearing in a specific channel, indicated by its ID.")] = None,
        ts_from: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created after this timestamp (inclusive).")] = None,
        ts_to: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter files created before this timestamp (inclusive).")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of items to return.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_remote_list_0

        Retrieve information about a remote file added to Slack

        :param token: Authentication token. Requires scope: `remote_files:read`
        :type token: str
        :param channel: Filter files appearing in a specific channel, indicated by its ID.
        :type channel: str
        :param ts_from: Filter files created after this timestamp (inclusive).
        :type ts_from: float
        :param ts_to: Filter files created before this timestamp (inclusive).
        :type ts_to: float
        :param limit: The maximum number of items to return.
        :type limit: int
        :param cursor: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
        :type cursor: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_list_0_serialize(
            token=token,
            channel=channel,
            ts_from=ts_from,
            ts_to=ts_to,
            limit=limit,
            cursor=cursor,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_remote_list_0_serialize(
        self,
        token,
        channel,
        ts_from,
        ts_to,
        limit,
        cursor,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if ts_from is not None:
            
            _query_params.append(('ts_from', ts_from))
            
        if ts_to is not None:
            
            _query_params.append(('ts_to', ts_to))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files.remote.list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_remote_remove_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> DefaultSuccessTemplate:
        """files_remote_remove_0

        Remove a remote file.

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_remove_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_remote_remove_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[DefaultSuccessTemplate]:
        """files_remote_remove_0

        Remove a remote file.

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_remove_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_remote_remove_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_remote_remove_0

        Remove a remote file.

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_remove_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_remote_remove_0_serialize(
        self,
        token,
        file,
        external_id,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(('token', token))
        if file is not None:
            _form_params.append(('file', file))
        if external_id is not None:
            _form_params.append(('external_id', external_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.remote.remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_remote_share_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:share`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.")] = None,
        channels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of channel IDs where the file will be shared.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> DefaultSuccessTemplate:
        """files_remote_share_0

        Share a remote file into a channel.

        :param token: Authentication token. Requires scope: `remote_files:share`
        :type token: str
        :param file: Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.
        :type file: str
        :param external_id: The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.
        :type external_id: str
        :param channels: Comma-separated list of channel IDs where the file will be shared.
        :type channels: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_share_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            channels=channels,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_remote_share_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:share`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.")] = None,
        channels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of channel IDs where the file will be shared.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[DefaultSuccessTemplate]:
        """files_remote_share_0

        Share a remote file into a channel.

        :param token: Authentication token. Requires scope: `remote_files:share`
        :type token: str
        :param file: Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.
        :type file: str
        :param external_id: The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.
        :type external_id: str
        :param channels: Comma-separated list of channel IDs where the file will be shared.
        :type channels: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_share_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            channels=channels,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_remote_share_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:share`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.")] = None,
        channels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of channel IDs where the file will be shared.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_remote_share_0

        Share a remote file into a channel.

        :param token: Authentication token. Requires scope: `remote_files:share`
        :type token: str
        :param file: Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.
        :type file: str
        :param external_id: The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.
        :type external_id: str
        :param channels: Comma-separated list of channel IDs where the file will be shared.
        :type channels: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_share_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            channels=channels,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_remote_share_0_serialize(
        self,
        token,
        file,
        external_id,
        channels,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if file is not None:
            
            _query_params.append(('file', file))
            
        if external_id is not None:
            
            _query_params.append(('external_id', external_id))
            
        if channels is not None:
            
            _query_params.append(('channels', channels))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files.remote.share',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_remote_update_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of the file being shared.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="type of file")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="URL of the remote file.")] = None,
        preview_image: Annotated[Optional[StrictStr], Field(description="Preview of the document via `multipart/form-data`.")] = None,
        indexable_file_contents: Annotated[Optional[StrictStr], Field(description="File containing contents that can be used to improve searchability for the remote file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> DefaultSuccessTemplate:
        """files_remote_update_0

        Updates an existing remote file.

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :param title: Title of the file being shared.
        :type title: str
        :param filetype: type of file
        :type filetype: str
        :param external_url: URL of the remote file.
        :type external_url: str
        :param preview_image: Preview of the document via `multipart/form-data`.
        :type preview_image: str
        :param indexable_file_contents: File containing contents that can be used to improve searchability for the remote file.
        :type indexable_file_contents: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_update_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            title=title,
            filetype=filetype,
            external_url=external_url,
            preview_image=preview_image,
            indexable_file_contents=indexable_file_contents,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_remote_update_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of the file being shared.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="type of file")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="URL of the remote file.")] = None,
        preview_image: Annotated[Optional[StrictStr], Field(description="Preview of the document via `multipart/form-data`.")] = None,
        indexable_file_contents: Annotated[Optional[StrictStr], Field(description="File containing contents that can be used to improve searchability for the remote file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[DefaultSuccessTemplate]:
        """files_remote_update_0

        Updates an existing remote file.

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :param title: Title of the file being shared.
        :type title: str
        :param filetype: type of file
        :type filetype: str
        :param external_url: URL of the remote file.
        :type external_url: str
        :param preview_image: Preview of the document via `multipart/form-data`.
        :type preview_image: str
        :param indexable_file_contents: File containing contents that can be used to improve searchability for the remote file.
        :type indexable_file_contents: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_update_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            title=title,
            filetype=filetype,
            external_url=external_url,
            preview_image=preview_image,
            indexable_file_contents=indexable_file_contents,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_remote_update_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `remote_files:write`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="Specify a file by providing its ID.")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="Creator defined GUID for the file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of the file being shared.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="type of file")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="URL of the remote file.")] = None,
        preview_image: Annotated[Optional[StrictStr], Field(description="Preview of the document via `multipart/form-data`.")] = None,
        indexable_file_contents: Annotated[Optional[StrictStr], Field(description="File containing contents that can be used to improve searchability for the remote file.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_remote_update_0

        Updates an existing remote file.

        :param token: Authentication token. Requires scope: `remote_files:write`
        :type token: str
        :param file: Specify a file by providing its ID.
        :type file: str
        :param external_id: Creator defined GUID for the file.
        :type external_id: str
        :param title: Title of the file being shared.
        :type title: str
        :param filetype: type of file
        :type filetype: str
        :param external_url: URL of the remote file.
        :type external_url: str
        :param preview_image: Preview of the document via `multipart/form-data`.
        :type preview_image: str
        :param indexable_file_contents: File containing contents that can be used to improve searchability for the remote file.
        :type indexable_file_contents: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_remote_update_0_serialize(
            token=token,
            file=file,
            external_id=external_id,
            title=title,
            filetype=filetype,
            external_url=external_url,
            preview_image=preview_image,
            indexable_file_contents=indexable_file_contents,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DefaultSuccessTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_remote_update_0_serialize(
        self,
        token,
        file,
        external_id,
        title,
        filetype,
        external_url,
        preview_image,
        indexable_file_contents,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(('token', token))
        if file is not None:
            _form_params.append(('file', file))
        if external_id is not None:
            _form_params.append(('external_id', external_id))
        if title is not None:
            _form_params.append(('title', title))
        if filetype is not None:
            _form_params.append(('filetype', filetype))
        if external_url is not None:
            _form_params.append(('external_url', external_url))
        if preview_image is not None:
            _form_params.append(('preview_image', preview_image))
        if indexable_file_contents is not None:
            _form_params.append(('indexable_file_contents', indexable_file_contents))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.remote.update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_revoke_public_url(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to revoke")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> FilesRevokePublicURLSchema:
        """files_revoke_public_url

        Revokes public/external sharing access for a file

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to revoke
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_revoke_public_url_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesRevokePublicURLSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_revoke_public_url_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to revoke")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[FilesRevokePublicURLSchema]:
        """files_revoke_public_url

        Revokes public/external sharing access for a file

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to revoke
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_revoke_public_url_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesRevokePublicURLSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_revoke_public_url_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to revoke")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_revoke_public_url

        Revokes public/external sharing access for a file

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to revoke
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_revoke_public_url_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesRevokePublicURLSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_revoke_public_url_serialize(
        self,
        token,
        file,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if file is not None:
            _form_params.append(('file', file))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.revokePublicURL',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_shared_public_url(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to share")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> FilesSharedPublicURLSchema:
        """files_shared_public_url

        Enables a file for public/external sharing.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to share
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_shared_public_url_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesSharedPublicURLSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_shared_public_url_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to share")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[FilesSharedPublicURLSchema]:
        """files_shared_public_url

        Enables a file for public/external sharing.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to share
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_shared_public_url_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesSharedPublicURLSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_shared_public_url_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File to share")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_shared_public_url

        Enables a file for public/external sharing.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File to share
        :type file: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_shared_public_url_serialize(
            token=token,
            file=file,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesSharedPublicURLSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_shared_public_url_serialize(
        self,
        token,
        file,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if file is not None:
            _form_params.append(('file', file))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.sharedPublicURL',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )




    @validate_call
    def files_upload(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.")] = None,
        content: Annotated[Optional[StrictStr], Field(description="File contents via a POST variable. If omitting this parameter, you must provide a `file`.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="A [file type](/types/file#file_types) identifier.")] = None,
        filename: Annotated[Optional[StrictStr], Field(description="Filename of file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of file.")] = None,
        initial_comment: Annotated[Optional[StrictStr], Field(description="The message text introducing the file in specified `channels`.")] = None,
        channels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of channel names or IDs where the file will be shared.")] = None,
        thread_ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> FilesUploadSchema:
        """files_upload

        Uploads or creates a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.
        :type file: str
        :param content: File contents via a POST variable. If omitting this parameter, you must provide a `file`.
        :type content: str
        :param filetype: A [file type](/types/file#file_types) identifier.
        :type filetype: str
        :param filename: Filename of file.
        :type filename: str
        :param title: Title of file.
        :type title: str
        :param initial_comment: The message text introducing the file in specified `channels`.
        :type initial_comment: str
        :param channels: Comma-separated list of channel names or IDs where the file will be shared.
        :type channels: str
        :param thread_ts: Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead.
        :type thread_ts: float
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_upload_serialize(
            token=token,
            file=file,
            content=content,
            filetype=filetype,
            filename=filename,
            title=title,
            initial_comment=initial_comment,
            channels=channels,
            thread_ts=thread_ts,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesUploadSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def files_upload_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.")] = None,
        content: Annotated[Optional[StrictStr], Field(description="File contents via a POST variable. If omitting this parameter, you must provide a `file`.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="A [file type](/types/file#file_types) identifier.")] = None,
        filename: Annotated[Optional[StrictStr], Field(description="Filename of file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of file.")] = None,
        initial_comment: Annotated[Optional[StrictStr], Field(description="The message text introducing the file in specified `channels`.")] = None,
        channels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of channel names or IDs where the file will be shared.")] = None,
        thread_ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> ApiResponse[FilesUploadSchema]:
        """files_upload

        Uploads or creates a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.
        :type file: str
        :param content: File contents via a POST variable. If omitting this parameter, you must provide a `file`.
        :type content: str
        :param filetype: A [file type](/types/file#file_types) identifier.
        :type filetype: str
        :param filename: Filename of file.
        :type filename: str
        :param title: Title of file.
        :type title: str
        :param initial_comment: The message text introducing the file in specified `channels`.
        :type initial_comment: str
        :param channels: Comma-separated list of channel names or IDs where the file will be shared.
        :type channels: str
        :param thread_ts: Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead.
        :type thread_ts: float
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_upload_serialize(
            token=token,
            file=file,
            content=content,
            filetype=filetype,
            filename=filename,
            title=title,
            initial_comment=initial_comment,
            channels=channels,
            thread_ts=thread_ts,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesUploadSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def files_upload_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `files:write:user`")] = None,
        file: Annotated[Optional[StrictStr], Field(description="File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.")] = None,
        content: Annotated[Optional[StrictStr], Field(description="File contents via a POST variable. If omitting this parameter, you must provide a `file`.")] = None,
        filetype: Annotated[Optional[StrictStr], Field(description="A [file type](/types/file#file_types) identifier.")] = None,
        filename: Annotated[Optional[StrictStr], Field(description="Filename of file.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title of file.")] = None,
        initial_comment: Annotated[Optional[StrictStr], Field(description="The message text introducing the file in specified `channels`.")] = None,
        channels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of channel names or IDs where the file will be shared.")] = None,
        thread_ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead.")] = None,
        request_timeout__: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        request_auth__: Optional[Dict[StrictStr, Any]] = None,
        content_type__: Optional[StrictStr] = None,
        headers__: Optional[Dict[StrictStr, Any]] = None,
        host__: Optional[StrictStr] = None,
    ) -> RESTResponseType:
        """files_upload

        Uploads or creates a file.

        :param token: Authentication token. Requires scope: `files:write:user`
        :type token: str
        :param file: File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.
        :type file: str
        :param content: File contents via a POST variable. If omitting this parameter, you must provide a `file`.
        :type content: str
        :param filetype: A [file type](/types/file#file_types) identifier.
        :type filetype: str
        :param filename: Filename of file.
        :type filename: str
        :param title: Title of file.
        :type title: str
        :param initial_comment: The message text introducing the file in specified `channels`.
        :type initial_comment: str
        :param channels: Comma-separated list of channel names or IDs where the file will be shared.
        :type channels: str
        :param thread_ts: Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead.
        :type thread_ts: float
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._files_upload_serialize(
            token=token,
            file=file,
            content=content,
            filetype=filetype,
            filename=filename,
            title=title,
            initial_comment=initial_comment,
            channels=channels,
            thread_ts=thread_ts,
            request_auth__=request_auth__,
            content_type__=content_type__,
            headers__=headers__,
            host__=host__
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesUploadSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            request_timeout__=request_timeout__
        )
        return response_data.response


    def _files_upload_serialize(
        self,
        token,
        file,
        content,
        filetype,
        filename,
        title,
        initial_comment,
        channels,
        thread_ts,
        request_auth__,
        content_type__,
        headers__,
        host__,
    ) -> RequestSerialized:


        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = headers__ or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(('token', token))
        if file is not None:
            _form_params.append(('file', file))
        if content is not None:
            _form_params.append(('content', content))
        if filetype is not None:
            _form_params.append(('filetype', filetype))
        if filename is not None:
            _form_params.append(('filename', filename))
        if title is not None:
            _form_params.append(('title', title))
        if initial_comment is not None:
            _form_params.append(('initial_comment', initial_comment))
        if channels is not None:
            _form_params.append(('channels', channels))
        if thread_ts is not None:
            _form_params.append(('thread_ts', thread_ts))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if content_type__:
            _header_params['Content-Type'] = content_type__
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files.upload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            host__=host__,
            request_auth__=request_auth__
        )


