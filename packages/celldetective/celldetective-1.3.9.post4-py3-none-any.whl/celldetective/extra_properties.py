"""
Copyright Â© 2022 Laboratoire Adhesion et Inflammation, Authored by Remy Torro, 
Ksenija Dervanova.

Add extra properties to measure using regionprops (measure_features). 
The functions must take "regionmask" as the first argument, corresponding
to the binary mask of each cell of interest generated by regionprops 
and an optional "intensity_image" second argument, i.e. the associated 
multichannel image crop. The measurement will be named after the function
name. If a function function() has several outputs (e.g. due to a multichannel image),
they will be labelled with an index as function-0, function-1... A routine 
automatically replacements keywords "intensity-0", "intensity-1" and so on,
with the actual name of the intensity channel (e.g. "intensity-0" -> 
"brightfield_channel"). Due to this indexing behavior, avoid using digits 
in the function names and prefer text instead: "intensity-99()" --> 
"intensity-ninety-nine()".

New functions appear automatically in the ConfigMeasurements widget of the
GUI.

"""

import warnings

import numpy as np
from scipy.ndimage import distance_transform_edt, center_of_mass
from scipy.spatial.distance import euclidean
from celldetective.utils import interpolate_nan, contour_of_instance_segmentation
import skimage.measure as skm
from stardist import fill_label_holes
from celldetective.segmentation import segment_frame_from_thresholds
from sklearn.metrics import r2_score


# def area_detected_in_ricm(regionmask, intensity_image, target_channel='adhesion_channel'):

# 	instructions = {
# 		"thresholds": [
# 			0.02,
# 			1000
# 		],
# 		"filters": [
# 			[
# 				"subtract",
# 				1
# 			],
# 			[
# 				"abs",
# 				2
# 			],
# 			[
# 				"gauss",
# 				0.8
# 			]
# 		],
# 		#"marker_min_distance": 1,
# 		#"marker_footprint_size": 10,
# 		"feature_queries": [
# 			"eccentricity > 0.99 or area < 60"
# 		],
# 	}
	
# 	lbl = segment_frame_from_thresholds(intensity_image, fill_holes=True, do_watershed=False, equalize_reference=None, edge_exclusion=False, **instructions)
# 	lbl[lbl>0] = 1 # instance to binary
# 	lbl[~regionmask] = 0 # make sure we don't measure stuff outside cell

# 	return np.sum(lbl)

def fraction_of_area_detected_in_intensity(regionmask, intensity_image, target_channel='adhesion_channel'):

	instructions = {
		"thresholds": [
			0.02,
			1000
		],
		"filters": [
			[
				"subtract",
				1
			],
			[
				"abs",
				2
			],
			[
				"gauss",
				0.8
			]
		],
	}
	
	lbl = segment_frame_from_thresholds(intensity_image, do_watershed=False, fill_holes=True, equalize_reference=None, edge_exclusion=False, **instructions)
	lbl[lbl>0] = 1 # instance to binary
	lbl[~regionmask] = 0 # make sure we don't measure stuff outside cell
	
	return float(np.sum(lbl)) / float(np.sum(regionmask))

def area_detected_in_intensity(regionmask, intensity_image, target_channel='adhesion_channel'):

	instructions = {
		"thresholds": [
			0.02,
			1000
		],
		"filters": [
			[
				"subtract",
				1
			],
			[
				"abs",
				2
			],
			[
				"gauss",
				0.8
			]
		],
	}
	
	lbl = segment_frame_from_thresholds(intensity_image, do_watershed=False, fill_holes=True, equalize_reference=None, edge_exclusion=False, **instructions)
	lbl[lbl>0] = 1 # instance to binary
	lbl[~regionmask] = 0 # make sure we don't measure stuff outside cell
	
	return float(np.sum(lbl))


def area_dark_intensity(regionmask, intensity_image, target_channel='adhesion_channel', fill_holes=True): #, target_channel='adhesion_channel'
	
	subregion = (intensity_image < 0.95)*regionmask # under one, under 0.8, under 0.6, whatever value!
	if fill_holes:
		subregion = skm.label(subregion, connectivity=2, background=0)
		subregion = fill_label_holes(subregion)
		subregion[subregion>0] = 1
	
	return float(np.sum(subregion))


def fraction_of_area_dark_intensity(regionmask, intensity_image, target_channel='adhesion_channel', fill_holes=True): #, target_channel='adhesion_channel'
	
	subregion = (intensity_image < 0.95)*regionmask # under one, under 0.8, under 0.6, whatever value!
	if fill_holes:
		subregion = skm.label(subregion, connectivity=2, background=0)
		subregion = fill_label_holes(subregion)
		subregion[subregion>0] = 1
	
	return float(np.sum(subregion)) / float(np.sum(regionmask))


def intensity_percentile_ninety_nine(regionmask, intensity_image):
	return np.nanpercentile(intensity_image[regionmask],99)

def intensity_percentile_ninety_five(regionmask, intensity_image):
	return np.nanpercentile(intensity_image[regionmask],95)

def intensity_percentile_ninety(regionmask, intensity_image):
	return np.nanpercentile(intensity_image[regionmask],90)

def intensity_percentile_seventy_five(regionmask, intensity_image):
	return np.nanpercentile(intensity_image[regionmask],75)

def intensity_percentile_fifty(regionmask, intensity_image):
	return np.nanpercentile(intensity_image[regionmask],50)

def intensity_percentile_twenty_five(regionmask, intensity_image):
	return np.nanpercentile(intensity_image[regionmask],25)

# STD

def intensity_std(regionmask, intensity_image):
	return np.nanstd(intensity_image[regionmask])


def intensity_median(regionmask, intensity_image):
	return np.nanmedian(intensity_image[regionmask])

def intensity_nanmean(regionmask, intensity_image):
	
	if np.all(intensity_image==0):
		return np.nan
	else:
		return np.nanmean(intensity_image[regionmask])

def intensity_center_of_mass_displacement(regionmask, intensity_image):

	if np.any(intensity_image!=intensity_image):
		intensity_image = interpolate_nan(intensity_image.copy())

	if not np.all(intensity_image.flatten()==0):
		
		y, x = np.mgrid[:regionmask.shape[0], :regionmask.shape[1]]
		xtemp = x.copy()
		ytemp = y.copy()

		intensity_image[intensity_image<=0.] = 0. #important to clip as negative intensities misbehave with center of mass
		intensity_weighted_center = center_of_mass(intensity_image*regionmask, regionmask, 1)
		centroid_x = intensity_weighted_center[1]
		centroid_y = intensity_weighted_center[0]

		geometric_centroid_x = np.sum(xtemp * regionmask) / np.sum(regionmask)
		geometric_centroid_y = np.sum(ytemp * regionmask) / np.sum(regionmask)
		distance = np.sqrt((geometric_centroid_y - centroid_y)**2 + (geometric_centroid_x - centroid_x)**2)

		delta_x = geometric_centroid_x - centroid_x
		delta_y = geometric_centroid_y - centroid_y
		direction_arctan = np.arctan2(delta_y, delta_x) * 180 / np.pi

		return distance, direction_arctan, centroid_x - geometric_centroid_x, centroid_y - geometric_centroid_y

	else:
		return np.nan, np.nan, np.nan, np.nan


def intensity_center_of_mass_displacement_edge(regionmask, intensity_image):

	if np.any(intensity_image!=intensity_image):
		intensity_image = interpolate_nan(intensity_image.copy())

	edge_mask = contour_of_instance_segmentation(regionmask, 3)
	
	if not np.all(intensity_image.flatten()==0) and np.sum(edge_mask)>0:
		
		y, x = np.mgrid[:edge_mask.shape[0], :edge_mask.shape[1]]
		xtemp = x.copy()
		ytemp = y.copy()
		
		intensity_image[intensity_image<=0.] = 0. #important to clip as negative intensities misbehave with center of mass
		intensity_weighted_center = center_of_mass(intensity_image*edge_mask, edge_mask, 1)
		centroid_x = intensity_weighted_center[1]
		centroid_y = intensity_weighted_center[0]

		#centroid_x = np.sum(xtemp * intensity_image) / np.sum(intensity_image)
		geometric_centroid_x = np.sum(xtemp * regionmask) / np.sum(regionmask)
		geometric_centroid_y = np.sum(ytemp * regionmask) / np.sum(regionmask)
		
		distance = np.sqrt((geometric_centroid_y - centroid_y)**2 + (geometric_centroid_x - centroid_x)**2)

		delta_x = geometric_centroid_x - centroid_x
		delta_y = geometric_centroid_y - centroid_y
		direction_arctan = np.arctan2(delta_y, delta_x) * 180 / np.pi

		return distance, direction_arctan, centroid_x - geometric_centroid_x, centroid_y - geometric_centroid_y
	else:
		return np.nan, np.nan, np.nan, np.nan


def intensity_radial_gradient(regionmask, intensity_image):

	"""
	Determine if intensities are following a linear gradient from center to edge of the cell.
	"""
	
	if np.any(intensity_image!=intensity_image):
		intensity_image = interpolate_nan(intensity_image.copy())
	
	# try:
	warnings.filterwarnings('ignore', message="Polyfit may be poorly conditioned")
	
	# intensities
	y = intensity_image[regionmask].flatten()

	# distance to edge
	x = distance_transform_edt(regionmask.copy())
	x = x[regionmask].flatten()
	x = max(x) - x # origin at center of cells

	params = np.polyfit(x, y, 1)
	line = np.poly1d(params)
	# coef > 0 --> more signal at edge than center, coef < 0 --> more signal at center than edge

	r2 = r2_score(y, line(x))
	
	return line.coefficients[0], line.coefficients[1], r2
