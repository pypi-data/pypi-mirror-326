import os, sys
import fdsreader as fds
import numpy as np
import plotly.express as px
from plotly.graph_objects import Figure
if 'nt' in sys.builtin_module_names:
    import winapps

from typing import List, Tuple, Union
from fdsreader import Simulation
from theng.models import Model

fds.settings.IGNORE_ERRORS = True

class FDSModel(Model, Simulation):
    """Represents a single FDS / PyroSim simulation and it's results.
    
    This class is a thin wrapper around the `Simulation <https://firedynamics.github.io/fdsreader/simulation.html>`_ class of fdsreader.

    Args:
        results_file_name (str): The basename of the .smv Results file generated by FDS
    """
    
    def __init__(self, results_file_name: str):
        
        Model.__init__(self, results_file_name, ".fds")
        Simulation.__init__(self, results_file_name)
        
    def take_screenshot(
        self, 
        ssview: str | List[str], 
        ssname: str | List[str] | None = None, 
        sswidth: int = 800, 
        ssheight: int = 600, 
        sstime: float | int = 0
    ) -> List[str]:
        """ Uses the Thunderhead Results Viewer to generate a screenshot of a simulation using the given parameters.
        
        Args:
            ssview (Union[str, List[str]]): Name or list of Names of Views to capture in the screenshot(s) 
            ssname (Union[str, List[str], None]): Name or list of Names to give to the captured screenshot(s)
            sswidth (int): Width (in pixels) of the screenshot(s)
            ssheight (int): Height (in pixels) of the screenshot(s)
            sstime (Union[float, int]): Simulation Time when the screenshot(s) should be captured
            
        Returns:
            A list of str paths to the generated screenshot(s)
        """
        if 'nt' in sys.builtin_module_names:
            apps = [app for app in winapps.search_installed("pyrosim")]
            app = apps[0]
            
            results_path = f"{app.install_location}{os.sep}PyroSimResults.exe"
            return super()._take_screenshot(results_path, ssview, ssname, sswidth, ssheight, sstime)
        else:
            self._log.error("Tried to take a screenshot on a non-Windows platform")
            
    def plot_max_slice_2d(self, slice_id: str, geom_mask: bool = True) -> Tuple[Figure, List[Union[float, dict]]]:
        """ Function to plot the values of a 2D slice at the timestep where it's maximum value occurs

        Args:
            slice_id (str): The ID of the slice to plot
            geom_mask (bool): Whether or not to apply the geometry mask to the slice data (Makes cells filled with Obstructions transparent)
        
        Returns:
            A Tuple containing the Plotted Figure and a List of data points. The list contains the Maximum Value, the Time step when the Maximum Value occurs, 
            and a Dictionary containing the coordinate where the Maximum value occurs, in that order.
        """  
        # Get the specified Slice data
        slice = self.slices.get_by_id(slice_id)
        if geom_mask:
            data = slice.to_global(fill=np.nan, masked=True)
        else:
            data = slice.to_global()
            
        # Detect Slice Extent directions
        extent_dirs = slice.extent_dirs
            
        # Get the timestep index, and axes coordinates of the maximum value of the Slice array
        t, axis_1, axis_2 = np.unravel_index(np.nanargmax(data), data.shape)
        
        # Get the maximum value
        max_value = np.nanmax(data)
        
        # Get the maximum time
        max_time = slice.times[t]
        
        # Convert coordinate indeces to Simulation Coordinates
        coordinates = slice.get_coordinates()
        
        # Get axes names
        axis_1_name = extent_dirs[0]
        axis_2_name = extent_dirs[1]
        axis_3_name = 'x' if 'x' not in extent_dirs else 'y' if 'y' not in extent_dirs else 'z'
        
        # Get coordinate values of max value location
        axis_1 = coordinates[axis_1_name][axis_1]
        axis_2 = coordinates[axis_2_name][axis_2]
        axis_3 = coordinates[axis_3_name][0]
        
        # Get slice of all values at the maximum Value Time
        max_slice = data[t,:,:].T
        
        # Plot the data as multichannel RGB data, viewing from the +X direction
        fig = px.imshow(max_slice,
                        labels={'x': f"{axis_1_name} Position(m)", "y": f"{axis_2_name} Position (m)"},
                        origin="lower",
                        title=f"{slice_id} Maximum Value; t={round(max_time, 2)}s",
                        x=coordinates[axis_1_name],
                        y=coordinates[axis_2_name],
                        color_continuous_scale=["blue", "aqua", "lime", "yellow", "orange", "red"]
                        )
        
        # Return the figure
        return (fig, max_value, max_time, {axis_1_name: axis_1, axis_2_name: axis_2, axis_3_name: axis_3})